{
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/Migrations.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 19,
                    "vulnerability_code": "    function setCompleted(uint completed) public restricted {\n\n        lastCompletedMigration = completed;\n",
                    "message": "Migrations.setCompleted (Migrations.sol#17-19) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "    function upgrade(address newAddress) public restricted {\n\n        Migrations upgraded = Migrations(newAddress);\n\n        upgraded.setCompleted(lastCompletedMigration);\n",
                    "message": "Migrations.upgrade (Migrations.sol#21-24) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": "Detected issues with version pragma in Migrations.sol:\n\t- pragma solidity^0.5.0 (Migrations.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/libs/NoteUtilsTest.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(valid, \"AZTEC array index is out of bounds\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(valid, \"AZTEC array index is out of bounds\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_26"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": 28,
                    "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n\n        uint len\n\n    ) {\n\n        assembly {\n\n            // first word = the raw byte length\n\n            // second word = the actual number of entries (hence the 0x20 offset)\n\n            len := mload(add(_proofOutputsOrNotes, 0x20))\n\n        }\n",
                    "message": "NoteUtils.getLength (NoteUtilsTest.sol#20-28) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n\n        bytes memory out\n\n    ) {\n\n        bool valid;\n\n        assembly {\n\n            // check that i < the number of entries\n\n            valid := lt(\n\n                _i,\n\n                mload(add(_proofOutputsOrNotes, 0x20))\n\n            )\n\n            // memory map of the array is as follows:\n\n            // 0x00 - 0x20 : byte length of array\n\n            // 0x20 - 0x40 : n, the number of entries\n\n            // 0x40 - 0x40 + (0x20 * i) : relative memory offset to start of i'th entry (i <= n)\n\n\n\n            // Step 1: compute location of relative memory offset: _proofOutputsOrNotes + 0x40 + (0x20 * i) \n\n            // Step 2: loaded relative offset and add to _proofOutputsOrNotes to get absolute memory location\n\n            out := add(\n\n                mload(\n\n                    add(\n\n                        add(_proofOutputsOrNotes, 0x40),\n\n                        mul(_i, 0x20)\n\n                    )\n\n                ),\n\n                _proofOutputsOrNotes\n\n            )\n\n        }\n\n        require(valid, \"AZTEC array index is out of bounds\");\n",
                    "message": "NoteUtils.get (NoteUtilsTest.sol#36-64) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n\n        bytes memory inputNotes,\n\n        bytes memory outputNotes,\n\n        address publicOwner,\n\n        int256 publicValue\n\n    ) {\n\n        assembly {\n\n            // memory map of a proofOutput:\n\n            // 0x00 - 0x20 : byte length of proofOutput\n\n            // 0x20 - 0x40 : relative offset to inputNotes\n\n            // 0x40 - 0x60 : relative offset to outputNotes\n\n            // 0x60 - 0x80 : publicOwner\n\n            // 0x80 - 0xa0 : publicValue\n\n            // 0xa0 - 0xc0 : challenge\n\n            inputNotes := add(_proofOutput, mload(add(_proofOutput, 0x20)))\n\n            outputNotes := add(_proofOutput, mload(add(_proofOutput, 0x40)))\n\n            publicOwner := and(\n\n                mload(add(_proofOutput, 0x60)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            publicValue := mload(add(_proofOutput, 0x80))\n\n        }\n",
                    "message": "NoteUtils.extractProofOutput (NoteUtilsTest.sol#76-98) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n\n        bytes32 challenge\n\n    ) {\n\n        assembly {\n\n            challenge := mload(add(_proofOutput, 0xa0))\n\n        }\n",
                    "message": "NoteUtils.extractChallenge (NoteUtilsTest.sol#105-111) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n\n            address owner,\n\n            bytes32 noteHash,\n\n            bytes memory metadata\n\n    ) {\n\n        assembly {\n\n            // memory map of a note:\n\n            // 0x00 - 0x20 : byte length of note\n\n            // 0x20 - 0x40 : note type\n\n            // 0x40 - 0x60 : owner\n\n            // 0x60 - 0x80 : noteHash\n\n            // 0x80 - 0xa0 : start of metadata byte array\n\n            owner := and(\n\n                mload(add(_note, 0x40)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            noteHash := mload(add(_note, 0x60))\n\n            metadata := add(_note, 0x80)\n\n        }\n",
                    "message": "NoteUtils.extractNote (NoteUtilsTest.sol#120-139) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n\n        uint256 noteType\n\n    ) {\n\n        assembly {\n\n            noteType := mload(add(_note, 0x20))\n\n        }\n",
                    "message": "NoteUtils.getNoteType (NoteUtilsTest.sol#146-152) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": 28,
                    "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n\n        uint len\n\n    ) {\n\n        assembly {\n\n            // first word = the raw byte length\n\n            // second word = the actual number of entries (hence the 0x20 offset)\n\n            len := mload(add(_proofOutputsOrNotes, 0x20))\n\n        }\n",
                    "message": "NoteUtils.getLength uses assembly (NoteUtilsTest.sol#20-28)\n\t- NoteUtilsTest.sol#23-27\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n\n        bytes memory out\n\n    ) {\n\n        bool valid;\n\n        assembly {\n\n            // check that i < the number of entries\n\n            valid := lt(\n\n                _i,\n\n                mload(add(_proofOutputsOrNotes, 0x20))\n\n            )\n\n            // memory map of the array is as follows:\n\n            // 0x00 - 0x20 : byte length of array\n\n            // 0x20 - 0x40 : n, the number of entries\n\n            // 0x40 - 0x40 + (0x20 * i) : relative memory offset to start of i'th entry (i <= n)\n\n\n\n            // Step 1: compute location of relative memory offset: _proofOutputsOrNotes + 0x40 + (0x20 * i) \n\n            // Step 2: loaded relative offset and add to _proofOutputsOrNotes to get absolute memory location\n\n            out := add(\n\n                mload(\n\n                    add(\n\n                        add(_proofOutputsOrNotes, 0x40),\n\n                        mul(_i, 0x20)\n\n                    )\n\n                ),\n\n                _proofOutputsOrNotes\n\n            )\n\n        }\n\n        require(valid, \"AZTEC array index is out of bounds\");\n",
                    "message": "NoteUtils.get uses assembly (NoteUtilsTest.sol#36-64)\n\t- NoteUtilsTest.sol#40-62\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n\n        bytes memory inputNotes,\n\n        bytes memory outputNotes,\n\n        address publicOwner,\n\n        int256 publicValue\n\n    ) {\n\n        assembly {\n\n            // memory map of a proofOutput:\n\n            // 0x00 - 0x20 : byte length of proofOutput\n\n            // 0x20 - 0x40 : relative offset to inputNotes\n\n            // 0x40 - 0x60 : relative offset to outputNotes\n\n            // 0x60 - 0x80 : publicOwner\n\n            // 0x80 - 0xa0 : publicValue\n\n            // 0xa0 - 0xc0 : challenge\n\n            inputNotes := add(_proofOutput, mload(add(_proofOutput, 0x20)))\n\n            outputNotes := add(_proofOutput, mload(add(_proofOutput, 0x40)))\n\n            publicOwner := and(\n\n                mload(add(_proofOutput, 0x60)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            publicValue := mload(add(_proofOutput, 0x80))\n\n        }\n",
                    "message": "NoteUtils.extractProofOutput uses assembly (NoteUtilsTest.sol#76-98)\n\t- NoteUtilsTest.sol#82-97\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n\n        bytes32 challenge\n\n    ) {\n\n        assembly {\n\n            challenge := mload(add(_proofOutput, 0xa0))\n\n        }\n",
                    "message": "NoteUtils.extractChallenge uses assembly (NoteUtilsTest.sol#105-111)\n\t- NoteUtilsTest.sol#108-110\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n\n            address owner,\n\n            bytes32 noteHash,\n\n            bytes memory metadata\n\n    ) {\n\n        assembly {\n\n            // memory map of a note:\n\n            // 0x00 - 0x20 : byte length of note\n\n            // 0x20 - 0x40 : note type\n\n            // 0x40 - 0x60 : owner\n\n            // 0x60 - 0x80 : noteHash\n\n            // 0x80 - 0xa0 : start of metadata byte array\n\n            owner := and(\n\n                mload(add(_note, 0x40)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            noteHash := mload(add(_note, 0x60))\n\n            metadata := add(_note, 0x80)\n\n        }\n",
                    "message": "NoteUtils.extractNote uses assembly (NoteUtilsTest.sol#120-139)\n\t- NoteUtilsTest.sol#125-138\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n\n        uint256 noteType\n\n    ) {\n\n        assembly {\n\n            noteType := mload(add(_note, 0x20))\n\n        }\n",
                    "message": "NoteUtils.getNoteType uses assembly (NoteUtilsTest.sol#146-152)\n\t- NoteUtilsTest.sol#149-151\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) public pure returns (\n\n        uint len\n\n    ) {\n\n        return _proofOutputsOrNotes.getLength();\n",
                    "message": "NoteUtilsTest.getLength (NoteUtilsTest.sol#175-179) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": 191,
                    "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) public pure returns (\n\n        bytes memory out\n\n    ) {\n\n        return _proofOutputsOrNotes.get(_i);\n",
                    "message": "NoteUtilsTest.get (NoteUtilsTest.sol#187-191) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) public pure returns (\n\n        bytes memory inputNotes,\n\n        bytes memory outputNotes,\n\n        address publicOwner,\n\n        int256 publicValue\n\n    ) {\n\n        return _proofOutput.extractProofOutput();\n",
                    "message": "NoteUtilsTest.extractProofOutput (NoteUtilsTest.sol#203-210) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": 221,
                    "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) public pure returns (\n\n        bytes32 challenge\n\n    ) {\n\n        return _proofOutput.extractChallenge();\n",
                    "message": "NoteUtilsTest.extractChallenge (NoteUtilsTest.sol#217-221) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": 236,
                    "vulnerability_code": "    function extractNote(bytes memory _note) public pure returns (\n\n        address owner,\n\n        bytes32 noteHash,\n\n        bytes memory metadata\n\n    ) {\n\n        return _note.extractNote();\n",
                    "message": "NoteUtilsTest.extractNote (NoteUtilsTest.sol#230-236) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": 247,
                    "vulnerability_code": "    function getNoteType(bytes memory _note) public pure returns (\n\n        uint256 noteType\n\n    ) {\n\n        return _note.getNoteType();\n",
                    "message": "NoteUtilsTest.getNoteType (NoteUtilsTest.sol#243-247) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in NoteUtilsTest.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (NoteUtilsTest.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (NoteUtilsTest.sol#157): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) public pure returns (\n",
                    "message": "Parameter '_proofOutputsOrNotes' of NoteUtilsTest.getLength (NoteUtilsTest.sol#175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) public pure returns (\n",
                    "message": "Parameter '_proofOutputsOrNotes' of NoteUtilsTest.get (NoteUtilsTest.sol#187) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) public pure returns (\n",
                    "message": "Parameter '_i' of NoteUtilsTest.get (NoteUtilsTest.sol#187) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) public pure returns (\n",
                    "message": "Parameter '_proofOutput' of NoteUtilsTest.extractProofOutput (NoteUtilsTest.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) public pure returns (\n",
                    "message": "Parameter '_proofOutput' of NoteUtilsTest.extractChallenge (NoteUtilsTest.sol#217) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractNote(bytes memory _note) public pure returns (\n",
                    "message": "Parameter '_note' of NoteUtilsTest.extractNote (NoteUtilsTest.sol#230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNoteType(bytes memory _note) public pure returns (\n",
                    "message": "Parameter '_note' of NoteUtilsTest.getNoteType (NoteUtilsTest.sol#243) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) public pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractNote(bytes memory _note) public pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/libs/LibEIP712.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message (LibEIP712.sol#46-72) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature (LibEIP712.sol#78-119) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message uses assembly (LibEIP712.sol#46-72)\n\t- LibEIP712.sol#60-71\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature uses assembly (LibEIP712.sol#78-119)\n\t- LibEIP712.sol#83-113\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in LibEIP712.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (LibEIP712.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (LibEIP712.sol#30) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/libs/SafeMath8.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c < 256, \"uint8 mul triggered integer overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b <= a, \"uint8 sub triggered integer underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"uint8 add triggered integer overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c < 256, \"uint8 mul triggered integer overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b <= a, \"uint8 sub triggered integer underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"uint8 add triggered integer overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <= 0.6.0;\n",
                    "message": "Detected issues with version pragma in SafeMath8.sol:\n\t- pragma solidity>=0.5.0<=0.6.0 (SafeMath8.sol#3): is has a complex pragma\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <= 0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <= 0.6.0;\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/libs/SafeMath8Test.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c < 256, \"uint8 mul triggered integer overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b <= a, \"uint8 sub triggered integer underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"uint8 add triggered integer overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c < 256, \"uint8 mul triggered integer overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b <= a, \"uint8 sub triggered integer underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"uint8 add triggered integer overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <= 0.6.0;\n",
                    "message": "Different versions of Solidity is used in SafeMath8Test.sol:\n\t- Version used: ['>=0.5.0<0.6.0', '>=0.5.0<=0.6.0']\n\t- SafeMath8Test.sol#3 declares pragma solidity>=0.5.0<=0.6.0\n\t- SafeMath8Test.sol#63-65 declares pragma solidity>=0.5.0<0.6.0\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function _mul(uint8 a, uint8 b) public pure returns (uint8) {\n\n        return(a.mul(b));\n\n    }\n\n\n",
                    "message": "SafeMath8Test._mul (SafeMath8Test.sol#68-72) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": 76,
                    "vulnerability_code": "    function _add(uint8 a, uint8 b) public pure returns (uint8) {\n\n        return(a.add(b));\n\n    }\n\n\n",
                    "message": "SafeMath8Test._add (SafeMath8Test.sol#72-76) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": 79,
                    "vulnerability_code": "    function _sub(uint8 a, uint8 b) public pure returns (uint8) {\n\n        return(a.sub(b));\n\n    }\n",
                    "message": "SafeMath8Test._sub (SafeMath8Test.sol#76-79) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <= 0.6.0;\n",
                    "message": "Detected issues with version pragma in SafeMath8Test.sol:\n\t- pragma solidity>=0.5.0<=0.6.0 (SafeMath8Test.sol#3): is has a complex pragma\n\t- pragma solidity>=0.5.0<0.6.0 (SafeMath8Test.sol#63-65): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function _mul(uint8 a, uint8 b) public pure returns (uint8) {\n\n        return(a.mul(b));\n\n    }\n\n\n",
                    "message": "Function 'SafeMath8Test._mul' (SafeMath8Test.sol#68-72) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": 76,
                    "vulnerability_code": "    function _add(uint8 a, uint8 b) public pure returns (uint8) {\n\n        return(a.add(b));\n\n    }\n\n\n",
                    "message": "Function 'SafeMath8Test._add' (SafeMath8Test.sol#72-76) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": 79,
                    "vulnerability_code": "    function _sub(uint8 a, uint8 b) public pure returns (uint8) {\n\n        return(a.sub(b));\n\n    }\n",
                    "message": "Function 'SafeMath8Test._sub' (SafeMath8Test.sol#76-79) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <= 0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <= 0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/libs/LibEIP712Test.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_13"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message (LibEIP712Test.sol#46-72) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature (LibEIP712Test.sol#78-119) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message uses assembly (LibEIP712Test.sol#46-72)\n\t- LibEIP712Test.sol#60-71\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature uses assembly (LibEIP712Test.sol#78-119)\n\t- LibEIP712Test.sol#83-113\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": 142,
                    "vulnerability_code": "    function _hashEIP712Message(bytes32 _hashStruct)\n\n        public\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        _result = super.hashEIP712Message(_hashStruct);\n",
                    "message": "LibEIP712Test._hashEIP712Message (LibEIP712Test.sol#136-142) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function _recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) public view returns (address _signer) {\n\n        _signer = super.recoverSignature(_message, _signature);\n",
                    "message": "LibEIP712Test._recoverSignature (LibEIP712Test.sol#148-153) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in LibEIP712Test.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (LibEIP712Test.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (LibEIP712Test.sol#124): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (LibEIP712Test.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": 142,
                    "vulnerability_code": "    function _hashEIP712Message(bytes32 _hashStruct)\n\n        public\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        _result = super.hashEIP712Message(_hashStruct);\n",
                    "message": "Function 'LibEIP712Test._hashEIP712Message' (LibEIP712Test.sol#136-142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": "Parameter '_hashStruct' of LibEIP712Test._hashEIP712Message (LibEIP712Test.sol#136) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function _recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) public view returns (address _signer) {\n\n        _signer = super.recoverSignature(_message, _signature);\n",
                    "message": "Function 'LibEIP712Test._recoverSignature' (LibEIP712Test.sol#148-153) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32 _message,\n",
                    "message": "Parameter '_message' of LibEIP712Test._recoverSignature (LibEIP712Test.sol#149) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory _signature\n",
                    "message": "Parameter '_signature' of LibEIP712Test._recoverSignature (LibEIP712Test.sol#150) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/libs/NoteUtils.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(valid, \"AZTEC array index is out of bounds\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(valid, \"AZTEC array index is out of bounds\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_13"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": 28,
                    "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n\n        uint len\n\n    ) {\n\n        assembly {\n\n            // first word = the raw byte length\n\n            // second word = the actual number of entries (hence the 0x20 offset)\n\n            len := mload(add(_proofOutputsOrNotes, 0x20))\n\n        }\n",
                    "message": "NoteUtils.getLength (NoteUtils.sol#20-28) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n\n        bytes memory out\n\n    ) {\n\n        bool valid;\n\n        assembly {\n\n            // check that i < the number of entries\n\n            valid := lt(\n\n                _i,\n\n                mload(add(_proofOutputsOrNotes, 0x20))\n\n            )\n\n            // memory map of the array is as follows:\n\n            // 0x00 - 0x20 : byte length of array\n\n            // 0x20 - 0x40 : n, the number of entries\n\n            // 0x40 - 0x40 + (0x20 * i) : relative memory offset to start of i'th entry (i <= n)\n\n\n\n            // Step 1: compute location of relative memory offset: _proofOutputsOrNotes + 0x40 + (0x20 * i) \n\n            // Step 2: loaded relative offset and add to _proofOutputsOrNotes to get absolute memory location\n\n            out := add(\n\n                mload(\n\n                    add(\n\n                        add(_proofOutputsOrNotes, 0x40),\n\n                        mul(_i, 0x20)\n\n                    )\n\n                ),\n\n                _proofOutputsOrNotes\n\n            )\n\n        }\n\n        require(valid, \"AZTEC array index is out of bounds\");\n",
                    "message": "NoteUtils.get (NoteUtils.sol#36-64) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n\n        bytes memory inputNotes,\n\n        bytes memory outputNotes,\n\n        address publicOwner,\n\n        int256 publicValue\n\n    ) {\n\n        assembly {\n\n            // memory map of a proofOutput:\n\n            // 0x00 - 0x20 : byte length of proofOutput\n\n            // 0x20 - 0x40 : relative offset to inputNotes\n\n            // 0x40 - 0x60 : relative offset to outputNotes\n\n            // 0x60 - 0x80 : publicOwner\n\n            // 0x80 - 0xa0 : publicValue\n\n            // 0xa0 - 0xc0 : challenge\n\n            inputNotes := add(_proofOutput, mload(add(_proofOutput, 0x20)))\n\n            outputNotes := add(_proofOutput, mload(add(_proofOutput, 0x40)))\n\n            publicOwner := and(\n\n                mload(add(_proofOutput, 0x60)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            publicValue := mload(add(_proofOutput, 0x80))\n\n        }\n",
                    "message": "NoteUtils.extractProofOutput (NoteUtils.sol#76-98) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n\n        bytes32 challenge\n\n    ) {\n\n        assembly {\n\n            challenge := mload(add(_proofOutput, 0xa0))\n\n        }\n",
                    "message": "NoteUtils.extractChallenge (NoteUtils.sol#105-111) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n\n            address owner,\n\n            bytes32 noteHash,\n\n            bytes memory metadata\n\n    ) {\n\n        assembly {\n\n            // memory map of a note:\n\n            // 0x00 - 0x20 : byte length of note\n\n            // 0x20 - 0x40 : note type\n\n            // 0x40 - 0x60 : owner\n\n            // 0x60 - 0x80 : noteHash\n\n            // 0x80 - 0xa0 : start of metadata byte array\n\n            owner := and(\n\n                mload(add(_note, 0x40)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            noteHash := mload(add(_note, 0x60))\n\n            metadata := add(_note, 0x80)\n\n        }\n",
                    "message": "NoteUtils.extractNote (NoteUtils.sol#120-139) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n\n        uint256 noteType\n\n    ) {\n\n        assembly {\n\n            noteType := mload(add(_note, 0x20))\n\n        }\n",
                    "message": "NoteUtils.getNoteType (NoteUtils.sol#146-152) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": 28,
                    "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n\n        uint len\n\n    ) {\n\n        assembly {\n\n            // first word = the raw byte length\n\n            // second word = the actual number of entries (hence the 0x20 offset)\n\n            len := mload(add(_proofOutputsOrNotes, 0x20))\n\n        }\n",
                    "message": "NoteUtils.getLength uses assembly (NoteUtils.sol#20-28)\n\t- NoteUtils.sol#23-27\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n\n        bytes memory out\n\n    ) {\n\n        bool valid;\n\n        assembly {\n\n            // check that i < the number of entries\n\n            valid := lt(\n\n                _i,\n\n                mload(add(_proofOutputsOrNotes, 0x20))\n\n            )\n\n            // memory map of the array is as follows:\n\n            // 0x00 - 0x20 : byte length of array\n\n            // 0x20 - 0x40 : n, the number of entries\n\n            // 0x40 - 0x40 + (0x20 * i) : relative memory offset to start of i'th entry (i <= n)\n\n\n\n            // Step 1: compute location of relative memory offset: _proofOutputsOrNotes + 0x40 + (0x20 * i) \n\n            // Step 2: loaded relative offset and add to _proofOutputsOrNotes to get absolute memory location\n\n            out := add(\n\n                mload(\n\n                    add(\n\n                        add(_proofOutputsOrNotes, 0x40),\n\n                        mul(_i, 0x20)\n\n                    )\n\n                ),\n\n                _proofOutputsOrNotes\n\n            )\n\n        }\n\n        require(valid, \"AZTEC array index is out of bounds\");\n",
                    "message": "NoteUtils.get uses assembly (NoteUtils.sol#36-64)\n\t- NoteUtils.sol#40-62\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n\n        bytes memory inputNotes,\n\n        bytes memory outputNotes,\n\n        address publicOwner,\n\n        int256 publicValue\n\n    ) {\n\n        assembly {\n\n            // memory map of a proofOutput:\n\n            // 0x00 - 0x20 : byte length of proofOutput\n\n            // 0x20 - 0x40 : relative offset to inputNotes\n\n            // 0x40 - 0x60 : relative offset to outputNotes\n\n            // 0x60 - 0x80 : publicOwner\n\n            // 0x80 - 0xa0 : publicValue\n\n            // 0xa0 - 0xc0 : challenge\n\n            inputNotes := add(_proofOutput, mload(add(_proofOutput, 0x20)))\n\n            outputNotes := add(_proofOutput, mload(add(_proofOutput, 0x40)))\n\n            publicOwner := and(\n\n                mload(add(_proofOutput, 0x60)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            publicValue := mload(add(_proofOutput, 0x80))\n\n        }\n",
                    "message": "NoteUtils.extractProofOutput uses assembly (NoteUtils.sol#76-98)\n\t- NoteUtils.sol#82-97\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n\n        bytes32 challenge\n\n    ) {\n\n        assembly {\n\n            challenge := mload(add(_proofOutput, 0xa0))\n\n        }\n",
                    "message": "NoteUtils.extractChallenge uses assembly (NoteUtils.sol#105-111)\n\t- NoteUtils.sol#108-110\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n\n            address owner,\n\n            bytes32 noteHash,\n\n            bytes memory metadata\n\n    ) {\n\n        assembly {\n\n            // memory map of a note:\n\n            // 0x00 - 0x20 : byte length of note\n\n            // 0x20 - 0x40 : note type\n\n            // 0x40 - 0x60 : owner\n\n            // 0x60 - 0x80 : noteHash\n\n            // 0x80 - 0xa0 : start of metadata byte array\n\n            owner := and(\n\n                mload(add(_note, 0x40)),\n\n                0xffffffffffffffffffffffffffffffffffffffff\n\n            )\n\n            noteHash := mload(add(_note, 0x60))\n\n            metadata := add(_note, 0x80)\n\n        }\n",
                    "message": "NoteUtils.extractNote uses assembly (NoteUtils.sol#120-139)\n\t- NoteUtils.sol#125-138\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n\n        uint256 noteType\n\n    ) {\n\n        assembly {\n\n            noteType := mload(add(_note, 0x20))\n\n        }\n",
                    "message": "NoteUtils.getNoteType uses assembly (NoteUtils.sol#146-152)\n\t- NoteUtils.sol#149-151\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in NoteUtils.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (NoteUtils.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getLength(bytes memory _proofOutputsOrNotes) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function get(bytes memory _proofOutputsOrNotes, uint _i) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractChallenge(bytes memory _proofOutput) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getNoteType(bytes memory _note) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractProofOutput(bytes memory _proofOutput) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function extractNote(bytes memory _note) internal pure returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/libs/GenericABIEncoder.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function encodeProofOutputsOne(\n\n        uint noteInfo,\n\n        uint publicOwner,\n\n        uint publicValue\n\n    ) public pure returns (bytes memory) {\n\n        assembly {\n\n            mstore(0x160, 0x20)\n\n            // 0x180 = size of proofOutputs in bytes\n\n            mstore(0x1a0, 0x01) // number of proof outputs\n\n            mstore(0x1c0, 0x60) // relative offset to start of proofOutputs\n\n        }\n\n        uint size = 0x80 + encodeProofOutput(\n\n            0x1e0,\n\n            (noteInfo & 0xff),\n\n            (noteInfo >> 8) & 0xff,\n\n            (noteInfo >> 16) & 0xffff,\n\n            (noteInfo >> 32) & 0xffff,\n\n            (noteInfo >> 48) & 0xffff,\n\n            publicOwner,\n\n            publicValue\n\n        );\n\n        assembly {\n\n            mstore(0x180, sub(size, 0x40))\n\n            return(0x160, size)\n\n        }\n",
                    "message": "GenericABIEncoder.encodeProofOutputsOne (GenericABIEncoder.sol#10-35) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 190,
                    "vulnerability_code": "    function encodeProofOutput(\n\n        uint freePtr,\n\n        uint numNotes,\n\n        uint numInputNotes,\n\n        uint offsetToNotes,\n\n        uint ownerPtr,\n\n        uint metadataPtr,\n\n        uint publicOwner,\n\n        uint publicValue\n\n    ) internal pure returns (uint proofOutputSize) {\n\n        assembly {\n\n            // memory map of proofOutput\n\n            // 0x00 - 0x20 - byte length\n\n            // 0x20 - 0x40 - offset to inputNotes\n\n            // 0x40 - 0x60 - offset to outputNotes\n\n            // 0x60 - 0x80 - publicOnwner\n\n            // 0x80 - 0xa0 - publicValue\n\n            mstore(add(freePtr, 0x20), 0xa0)\n\n            mstore(add(freePtr, 0x60), publicOwner)\n\n            mstore(add(freePtr, 0x80), publicValue)\n\n            proofOutputSize := encodeInputNotes(\n\n                add(freePtr, 0xa0),\n\n                numInputNotes,\n\n                add(offsetToNotes, 0x20),\n\n                ownerPtr\n\n            )\n\n           \n\n            mstore(add(freePtr, 0x40), add(proofOutputSize, 0xa0))\n\n\n\n            proofOutputSize := add(\n\n                proofOutputSize,\n\n                encodeOutputNotes(\n\n                    add(add(freePtr, 0xa0), proofOutputSize),\n\n                    sub(numNotes, numInputNotes),\n\n                    add(offsetToNotes, mul(numInputNotes, 0xc0)),\n\n                    add(ownerPtr, mul(numInputNotes, 0x20)),\n\n                    add(metadataPtr, mul(numInputNotes, 0x20))\n\n                )\n\n            )\n\n            proofOutputSize := add(proofOutputSize, 0xa0)\n\n            mstore(freePtr, sub(proofOutputSize, 0x20))\n\n\n\n            function encodeInputNotes(memPtr, len, notePtr, ownerPtr) -> inputNotesLength {\n\n                mstore(0x00, 0x01)\n\n                // memory map for input notes\n\n                // 0x00 - 0x20 - byte length\n\n                // 0x20 - 0x40 - number of notes\n\n                // 0x40 - xxxx - offsets to note entries\n\n                mstore(add(memPtr, 0x20), len) // length of input notes\n\n                \n\n                notePtr := add(memPtr, add(0x40, mul(len, 0x20)))\n\n                for { let i := 0 } lt(i, len) { i := add(i, 0x01) } {\n\n                    // write the relative offset to this note entry\n\n                    mstore(add(0x40, add(memPtr, mul(i, 0x20))), sub(notePtr, memPtr))\n\n\n\n                    let noteIndex := add(notePtr, mul(i, 0xc0))\n\n                    // copy notes\n\n                    calldatacopy(0x20, noteIndex, 0x80)\n\n\n\n                    mstore(notePtr, 0xc0) // length of note\n\n                    mstore(add(notePtr, 0x20), 0x01) // note type\n\n                    mstore(add(notePtr, 0x40), calldataload(add(ownerPtr, mul(i, 0xc0)))) // note owner\n\n                    mstore(add(notePtr, 0x60), keccak256(0x00, 0xa0)) // note hash\n\n                    mstore(add(notePtr, 0x80), 0x40) // metadata length\n\n                    mstore(             // gamma\n\n                        add(notePtr, 0xa0),\n\n                        or(\n\n                            mload(0x20),\n\n                            mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n                    // store compressed note coordinate sigma in `s + 0xa0`\n\n                    mstore(\n\n                        add(notePtr, 0xc0),\n\n                        or(\n\n                            mload(0x60),\n\n                            mul(\n\n                            and(mload(0x80), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n\n\n                    notePtr := add(notePtr, 0xe0)\n\n                }\n\n\n\n                mstore(memPtr, sub(sub(notePtr, memPtr), 0x20)) // store input note length at memPtr\n\n                inputNotesLength := sub(notePtr, memPtr)\n\n            }\n\n\n\n            function encodeOutputNotes(memPtr, len, notePtr, ownerPtr, metadataPtr) -> outputNotesLength {\n\n                mstore(0x00, 0x01)\n\n                // memory map for input notes\n\n                // 0x00 - 0x20 - byte length\n\n                // 0x20 - 0x40 - number of notes\n\n                // 0x40 - xxxx - offsets to note entries\n\n                mstore(add(memPtr, 0x20), len) // length of output notes\n\n                \n\n                notePtr := add(memPtr, add(0x40, mul(len, 0x20)))\n\n                for { let i := 0 } lt(i, len) { i := add(i, 0x01) } {\n\n                    // write the relative offset to this note entry\n\n                    mstore(add(0x40, add(memPtr, mul(i, 0x20))), sub(notePtr, memPtr))\n\n\n\n                    let noteIndex := add(notePtr, mul(i, 0xc0))\n\n                    let metadataIndex := calldataload(add(metadataPtr, add(0x20, mul(i, 0x20))))\n\n                    let metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n                    // copy notes\n\n                    calldatacopy(0x20, noteIndex, 0x80)\n\n\n\n                    mstore(notePtr, 0xc0) // length of note\n\n                    mstore(add(notePtr, 0x20), 0x01) // note type\n\n                    mstore(add(notePtr, 0x40), calldataload(add(ownerPtr, mul(i, 0xc0)))) // note owner\n\n                    mstore(add(notePtr, 0x60), keccak256(0x00, 0xa0)) // note hash\n\n                    mstore(add(notePtr, 0x80), add(0x40, metadataLength)) // metadata length\n\n                    mstore(             // gamma\n\n                        add(notePtr, 0xa0),\n\n                        or(\n\n                            mload(0x20),\n\n                            mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n                    // store compressed note coordinate sigma in `s + 0xa0`\n\n                    mstore(\n\n                        add(notePtr, 0xc0),\n\n                        or(\n\n                            mload(0x60),\n\n                            mul(\n\n                            and(mload(0x80), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n                    calldatacopy(\n\n                        add(notePtr, 0xe0),\n\n                        add(metadataIndex, sub(metadataPtr, 0x20)),\n\n                        metadataLength\n\n                    )\n\n\n\n                    notePtr := add(notePtr, add(0xe0, metadataLength))\n\n                }\n\n\n\n                mstore(memPtr, sub(sub(notePtr, memPtr), 0x20)) // store input note length at memPtr\n\n                outputNotesLength := sub(notePtr, memPtr)\n\n            }\n\n\n\n        }\n",
                    "message": "GenericABIEncoder.encodeProofOutput (GenericABIEncoder.sol#37-190) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function encodeProofOutputsOne(\n\n        uint noteInfo,\n\n        uint publicOwner,\n\n        uint publicValue\n\n    ) public pure returns (bytes memory) {\n\n        assembly {\n\n            mstore(0x160, 0x20)\n\n            // 0x180 = size of proofOutputs in bytes\n\n            mstore(0x1a0, 0x01) // number of proof outputs\n\n            mstore(0x1c0, 0x60) // relative offset to start of proofOutputs\n\n        }\n\n        uint size = 0x80 + encodeProofOutput(\n\n            0x1e0,\n\n            (noteInfo & 0xff),\n\n            (noteInfo >> 8) & 0xff,\n\n            (noteInfo >> 16) & 0xffff,\n\n            (noteInfo >> 32) & 0xffff,\n\n            (noteInfo >> 48) & 0xffff,\n\n            publicOwner,\n\n            publicValue\n\n        );\n\n        assembly {\n\n            mstore(0x180, sub(size, 0x40))\n\n            return(0x160, size)\n\n        }\n",
                    "message": "GenericABIEncoder.encodeProofOutputsOne uses assembly (GenericABIEncoder.sol#10-35)\n\t- GenericABIEncoder.sol#15-20\n\t- GenericABIEncoder.sol#31-34\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 190,
                    "vulnerability_code": "    function encodeProofOutput(\n\n        uint freePtr,\n\n        uint numNotes,\n\n        uint numInputNotes,\n\n        uint offsetToNotes,\n\n        uint ownerPtr,\n\n        uint metadataPtr,\n\n        uint publicOwner,\n\n        uint publicValue\n\n    ) internal pure returns (uint proofOutputSize) {\n\n        assembly {\n\n            // memory map of proofOutput\n\n            // 0x00 - 0x20 - byte length\n\n            // 0x20 - 0x40 - offset to inputNotes\n\n            // 0x40 - 0x60 - offset to outputNotes\n\n            // 0x60 - 0x80 - publicOnwner\n\n            // 0x80 - 0xa0 - publicValue\n\n            mstore(add(freePtr, 0x20), 0xa0)\n\n            mstore(add(freePtr, 0x60), publicOwner)\n\n            mstore(add(freePtr, 0x80), publicValue)\n\n            proofOutputSize := encodeInputNotes(\n\n                add(freePtr, 0xa0),\n\n                numInputNotes,\n\n                add(offsetToNotes, 0x20),\n\n                ownerPtr\n\n            )\n\n           \n\n            mstore(add(freePtr, 0x40), add(proofOutputSize, 0xa0))\n\n\n\n            proofOutputSize := add(\n\n                proofOutputSize,\n\n                encodeOutputNotes(\n\n                    add(add(freePtr, 0xa0), proofOutputSize),\n\n                    sub(numNotes, numInputNotes),\n\n                    add(offsetToNotes, mul(numInputNotes, 0xc0)),\n\n                    add(ownerPtr, mul(numInputNotes, 0x20)),\n\n                    add(metadataPtr, mul(numInputNotes, 0x20))\n\n                )\n\n            )\n\n            proofOutputSize := add(proofOutputSize, 0xa0)\n\n            mstore(freePtr, sub(proofOutputSize, 0x20))\n\n\n\n            function encodeInputNotes(memPtr, len, notePtr, ownerPtr) -> inputNotesLength {\n\n                mstore(0x00, 0x01)\n\n                // memory map for input notes\n\n                // 0x00 - 0x20 - byte length\n\n                // 0x20 - 0x40 - number of notes\n\n                // 0x40 - xxxx - offsets to note entries\n\n                mstore(add(memPtr, 0x20), len) // length of input notes\n\n                \n\n                notePtr := add(memPtr, add(0x40, mul(len, 0x20)))\n\n                for { let i := 0 } lt(i, len) { i := add(i, 0x01) } {\n\n                    // write the relative offset to this note entry\n\n                    mstore(add(0x40, add(memPtr, mul(i, 0x20))), sub(notePtr, memPtr))\n\n\n\n                    let noteIndex := add(notePtr, mul(i, 0xc0))\n\n                    // copy notes\n\n                    calldatacopy(0x20, noteIndex, 0x80)\n\n\n\n                    mstore(notePtr, 0xc0) // length of note\n\n                    mstore(add(notePtr, 0x20), 0x01) // note type\n\n                    mstore(add(notePtr, 0x40), calldataload(add(ownerPtr, mul(i, 0xc0)))) // note owner\n\n                    mstore(add(notePtr, 0x60), keccak256(0x00, 0xa0)) // note hash\n\n                    mstore(add(notePtr, 0x80), 0x40) // metadata length\n\n                    mstore(             // gamma\n\n                        add(notePtr, 0xa0),\n\n                        or(\n\n                            mload(0x20),\n\n                            mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n                    // store compressed note coordinate sigma in `s + 0xa0`\n\n                    mstore(\n\n                        add(notePtr, 0xc0),\n\n                        or(\n\n                            mload(0x60),\n\n                            mul(\n\n                            and(mload(0x80), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n\n\n                    notePtr := add(notePtr, 0xe0)\n\n                }\n\n\n\n                mstore(memPtr, sub(sub(notePtr, memPtr), 0x20)) // store input note length at memPtr\n\n                inputNotesLength := sub(notePtr, memPtr)\n\n            }\n\n\n\n            function encodeOutputNotes(memPtr, len, notePtr, ownerPtr, metadataPtr) -> outputNotesLength {\n\n                mstore(0x00, 0x01)\n\n                // memory map for input notes\n\n                // 0x00 - 0x20 - byte length\n\n                // 0x20 - 0x40 - number of notes\n\n                // 0x40 - xxxx - offsets to note entries\n\n                mstore(add(memPtr, 0x20), len) // length of output notes\n\n                \n\n                notePtr := add(memPtr, add(0x40, mul(len, 0x20)))\n\n                for { let i := 0 } lt(i, len) { i := add(i, 0x01) } {\n\n                    // write the relative offset to this note entry\n\n                    mstore(add(0x40, add(memPtr, mul(i, 0x20))), sub(notePtr, memPtr))\n\n\n\n                    let noteIndex := add(notePtr, mul(i, 0xc0))\n\n                    let metadataIndex := calldataload(add(metadataPtr, add(0x20, mul(i, 0x20))))\n\n                    let metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n                    // copy notes\n\n                    calldatacopy(0x20, noteIndex, 0x80)\n\n\n\n                    mstore(notePtr, 0xc0) // length of note\n\n                    mstore(add(notePtr, 0x20), 0x01) // note type\n\n                    mstore(add(notePtr, 0x40), calldataload(add(ownerPtr, mul(i, 0xc0)))) // note owner\n\n                    mstore(add(notePtr, 0x60), keccak256(0x00, 0xa0)) // note hash\n\n                    mstore(add(notePtr, 0x80), add(0x40, metadataLength)) // metadata length\n\n                    mstore(             // gamma\n\n                        add(notePtr, 0xa0),\n\n                        or(\n\n                            mload(0x20),\n\n                            mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n                    // store compressed note coordinate sigma in `s + 0xa0`\n\n                    mstore(\n\n                        add(notePtr, 0xc0),\n\n                        or(\n\n                            mload(0x60),\n\n                            mul(\n\n                            and(mload(0x80), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                            )\n\n                        )\n\n                    )\n\n                    calldatacopy(\n\n                        add(notePtr, 0xe0),\n\n                        add(metadataIndex, sub(metadataPtr, 0x20)),\n\n                        metadataLength\n\n                    )\n\n\n\n                    notePtr := add(notePtr, add(0xe0, metadataLength))\n\n                }\n\n\n\n                mstore(memPtr, sub(sub(notePtr, memPtr), 0x20)) // store input note length at memPtr\n\n                outputNotesLength := sub(notePtr, memPtr)\n\n            }\n\n\n\n        }\n",
                    "message": "GenericABIEncoder.encodeProofOutput uses assembly (GenericABIEncoder.sol#37-190)\n\t- GenericABIEncoder.sol#47-189\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function encodeProofOutputsOne(\n\n        uint noteInfo,\n\n        uint publicOwner,\n\n        uint publicValue\n\n    ) public pure returns (bytes memory) {\n\n        assembly {\n\n            mstore(0x160, 0x20)\n\n            // 0x180 = size of proofOutputs in bytes\n\n            mstore(0x1a0, 0x01) // number of proof outputs\n\n            mstore(0x1c0, 0x60) // relative offset to start of proofOutputs\n\n        }\n\n        uint size = 0x80 + encodeProofOutput(\n\n            0x1e0,\n\n            (noteInfo & 0xff),\n\n            (noteInfo >> 8) & 0xff,\n\n            (noteInfo >> 16) & 0xffff,\n\n            (noteInfo >> 32) & 0xffff,\n\n            (noteInfo >> 48) & 0xffff,\n\n            publicOwner,\n\n            publicValue\n\n        );\n\n        assembly {\n\n            mstore(0x180, sub(size, 0x40))\n\n            return(0x160, size)\n\n        }\n",
                    "message": "GenericABIEncoder.encodeProofOutputsOne (GenericABIEncoder.sol#10-35) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in GenericABIEncoder.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (GenericABIEncoder.sol#3): it allows old versions\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private constant NOTE_TYPE = 1;\n",
                    "message": "GenericABIEncoder.NOTE_TYPE (GenericABIEncoder.sol#7) is never used in GenericABIEncoder\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint size = 0x80 + encodeProofOutput(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            0x1e0,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (noteInfo & 0xff),\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (noteInfo >> 8) & 0xff,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (noteInfo >> 16) & 0xffff,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (noteInfo >> 32) & 0xffff,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (noteInfo >> 48) & 0xffff,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeProofOutputsOne(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeProofOutput(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private constant NOTE_TYPE = 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeProofOutputsOne(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeProofOutput(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/ACE/validators/joinSplit/JoinSplitABIEncoderTest.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_11"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 281,
                    "vulnerability_code": "    function encodeAndExit(bytes32 domainHash) internal view {\n\n        bytes32 typeHash = JOIN_SPLIT_SIGNATURE_TYPE_HASH;\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x184))\n\n            let n := calldataload(notes)\n\n            let m := calldataload(0x124)\n\n            let inputOwners := add(0x124, calldataload(0x1c4)) // one word after inputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1e4)) // one word after outputOwners = 1st\n\n            let signatures := add(0x124, calldataload(0x1a4)) // one word after signatures = 1st\n\n            let metadata := add(0x144, calldataload(0x204)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // 0x00 - 0x160  = scratch data for EIP712 signature computation and note hash computation\n\n            // JOIN_SPLIT_SIGNATURE struct hash variables\n\n            // 0x80 = type hash\n\n            // 0xa0 = proof object (65793)\n\n            // 0xc0 = noteHash\n\n            // 0xe0 = challenge\n\n            // 0x100 = sender\n\n            // type hash of 'JOIN_SPLIT_SIGNATURE'\n\n            mstore(0x80, typeHash)\n\n            mstore(0xa0, 0x10101)\n\n            mstore(0xe0, calldataload(0x144)) // challenge\n\n            mstore(0x100, calldataload(0x24))\n\n\n\n            // EIP712 Signature variables\n\n            // 0x13e - 0x140 = 0x1901\n\n            // 0x140 - 0x160 = domainHash\n\n            // 0x160 - 0x180 = structHash\n\n            mstore(0x120, 0x1901)\n\n            mstore(0x140, domainHash) // domain hash\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x280\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = type\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, calldataload(0x164))             // publicOwner\n\n            // store kPublic. If kPublic is negative, store correct signed representation,\n\n            // relative to 2^256, not to the order of the bn128 group\n\n            let kPublic := calldataload(sub(add(notes, mul(calldataload(notes), 0xc0)), 0xa0))\n\n            switch gt(kPublic, 10944121435919637611123202872628637544274182200208017171849102093287904247808)\n\n            case 1 {\n\n                mstore(0x260, sub(kPublic, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001))\n\n            }\n\n            case 0 {\n\n                mstore(0x260, kPublic)\n\n            }\n\n\n\n            mstore(0x280, calldataload(0x144))                    // store challenge\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to input signatures\n\n                let signatureIndex := add(signatures, mul(i, 0x60))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // note type\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n                // construct EIP712 signature parameters\n\n                mstore(0xc0, keccak256(0x00, 0xa0)) // note hash\n\n                mstore(0x80, typeHash)              // typeHash - eip signature params\n\n                // construct EIP712 signature message\n\n                mstore(0x160, keccak256(0x80, 0xa0))\n\n                mstore(0x00, keccak256(0x13e, 0x42))\n\n                // recover address of EIP712 signature\n\n                mstore(0x20, and(calldataload(signatureIndex), 0xff)) // get 8-bit v\n\n                calldatacopy(0x40, add(signatureIndex, 0x20), 0x40) // copy r, s into memory\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (1)\n\n                mstore(add(s, 0x20), 0x01)\n\n                mstore(0x80, typeHash)\n\n                mstore(0xa0, 0x10101)   // proof id 0x010101\n\n                \n\n                // store note owner in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(inputOwners, mul(i, 0x20))))\n\n\n\n                let t := staticcall(gas, 0x01, 0x00, 0x80, 0x00, 0x20)\n\n                let owner := mload(add(s, 0x40))\n\n                let recoveredAddress := mload(0x00)\n\n\n\n                // Check recovered address matches now owner, throw if not\n\n                if iszero(eq(recoveredAddress, owner)) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                } \n\n\n\n                if iszero(owner) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                } \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), mload(0xc0))\n\n                // store note metadata length in `s + 0x60` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // transition between input and output notes\n\n            // store total length of inputNotes at 1st index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // note type\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (1)\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            mstore(0x1e0, add(0xa0, notesLength)) // store length of proofOutput at 0x160\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
                    "message": "JoinSplitABIEncoder.encodeAndExit (JoinSplitABIEncoderTest.sol#43-281) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": 355,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message (JoinSplitABIEncoderTest.sol#329-355) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": 402,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature (JoinSplitABIEncoderTest.sol#361-402) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 281,
                    "vulnerability_code": "    function encodeAndExit(bytes32 domainHash) internal view {\n\n        bytes32 typeHash = JOIN_SPLIT_SIGNATURE_TYPE_HASH;\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x184))\n\n            let n := calldataload(notes)\n\n            let m := calldataload(0x124)\n\n            let inputOwners := add(0x124, calldataload(0x1c4)) // one word after inputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1e4)) // one word after outputOwners = 1st\n\n            let signatures := add(0x124, calldataload(0x1a4)) // one word after signatures = 1st\n\n            let metadata := add(0x144, calldataload(0x204)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // 0x00 - 0x160  = scratch data for EIP712 signature computation and note hash computation\n\n            // JOIN_SPLIT_SIGNATURE struct hash variables\n\n            // 0x80 = type hash\n\n            // 0xa0 = proof object (65793)\n\n            // 0xc0 = noteHash\n\n            // 0xe0 = challenge\n\n            // 0x100 = sender\n\n            // type hash of 'JOIN_SPLIT_SIGNATURE'\n\n            mstore(0x80, typeHash)\n\n            mstore(0xa0, 0x10101)\n\n            mstore(0xe0, calldataload(0x144)) // challenge\n\n            mstore(0x100, calldataload(0x24))\n\n\n\n            // EIP712 Signature variables\n\n            // 0x13e - 0x140 = 0x1901\n\n            // 0x140 - 0x160 = domainHash\n\n            // 0x160 - 0x180 = structHash\n\n            mstore(0x120, 0x1901)\n\n            mstore(0x140, domainHash) // domain hash\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x280\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = type\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, calldataload(0x164))             // publicOwner\n\n            // store kPublic. If kPublic is negative, store correct signed representation,\n\n            // relative to 2^256, not to the order of the bn128 group\n\n            let kPublic := calldataload(sub(add(notes, mul(calldataload(notes), 0xc0)), 0xa0))\n\n            switch gt(kPublic, 10944121435919637611123202872628637544274182200208017171849102093287904247808)\n\n            case 1 {\n\n                mstore(0x260, sub(kPublic, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001))\n\n            }\n\n            case 0 {\n\n                mstore(0x260, kPublic)\n\n            }\n\n\n\n            mstore(0x280, calldataload(0x144))                    // store challenge\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to input signatures\n\n                let signatureIndex := add(signatures, mul(i, 0x60))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // note type\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n                // construct EIP712 signature parameters\n\n                mstore(0xc0, keccak256(0x00, 0xa0)) // note hash\n\n                mstore(0x80, typeHash)              // typeHash - eip signature params\n\n                // construct EIP712 signature message\n\n                mstore(0x160, keccak256(0x80, 0xa0))\n\n                mstore(0x00, keccak256(0x13e, 0x42))\n\n                // recover address of EIP712 signature\n\n                mstore(0x20, and(calldataload(signatureIndex), 0xff)) // get 8-bit v\n\n                calldatacopy(0x40, add(signatureIndex, 0x20), 0x40) // copy r, s into memory\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (1)\n\n                mstore(add(s, 0x20), 0x01)\n\n                mstore(0x80, typeHash)\n\n                mstore(0xa0, 0x10101)   // proof id 0x010101\n\n                \n\n                // store note owner in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(inputOwners, mul(i, 0x20))))\n\n\n\n                let t := staticcall(gas, 0x01, 0x00, 0x80, 0x00, 0x20)\n\n                let owner := mload(add(s, 0x40))\n\n                let recoveredAddress := mload(0x00)\n\n\n\n                // Check recovered address matches now owner, throw if not\n\n                if iszero(eq(recoveredAddress, owner)) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                } \n\n\n\n                if iszero(owner) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                } \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), mload(0xc0))\n\n                // store note metadata length in `s + 0x60` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // transition between input and output notes\n\n            // store total length of inputNotes at 1st index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // note type\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (1)\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            mstore(0x1e0, add(0xa0, notesLength)) // store length of proofOutput at 0x160\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
                    "message": "JoinSplitABIEncoder.encodeAndExit uses assembly (JoinSplitABIEncoderTest.sol#43-281)\n\t- JoinSplitABIEncoderTest.sol#45-280\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": 355,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message uses assembly (JoinSplitABIEncoderTest.sol#329-355)\n\t- JoinSplitABIEncoderTest.sol#343-354\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": 402,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature uses assembly (JoinSplitABIEncoderTest.sol#361-402)\n\t- JoinSplitABIEncoderTest.sol#366-396\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in JoinSplitABIEncoderTest.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitABIEncoderTest.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitABIEncoderTest.sol#286): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitABIEncoderTest.sol#407): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (JoinSplitABIEncoderTest.sol#313) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata, \n",
                    "message": "Parameter '' of JoinSplitABIEncoderTest.validateJoinSplit (JoinSplitABIEncoderTest.sol#412) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address, \n",
                    "message": "Parameter '_scope_0' of JoinSplitABIEncoderTest.validateJoinSplit (JoinSplitABIEncoderTest.sol#413) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6] calldata\n",
                    "message": "Parameter '_scope_1' of JoinSplitABIEncoderTest.validateJoinSplit (JoinSplitABIEncoderTest.sol#414) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validateJoinSplit(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeAndExit(bytes32 domainHash) internal view {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 343,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/ACE/validators/joinSplit/JoinSplitABIEncoder.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 281,
                    "vulnerability_code": "    function encodeAndExit(bytes32 domainHash) internal view {\n\n        bytes32 typeHash = JOIN_SPLIT_SIGNATURE_TYPE_HASH;\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x184))\n\n            let n := calldataload(notes)\n\n            let m := calldataload(0x124)\n\n            let inputOwners := add(0x124, calldataload(0x1c4)) // one word after inputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1e4)) // one word after outputOwners = 1st\n\n            let signatures := add(0x124, calldataload(0x1a4)) // one word after signatures = 1st\n\n            let metadata := add(0x144, calldataload(0x204)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // 0x00 - 0x160  = scratch data for EIP712 signature computation and note hash computation\n\n            // JOIN_SPLIT_SIGNATURE struct hash variables\n\n            // 0x80 = type hash\n\n            // 0xa0 = proof object (65793)\n\n            // 0xc0 = noteHash\n\n            // 0xe0 = challenge\n\n            // 0x100 = sender\n\n            // type hash of 'JOIN_SPLIT_SIGNATURE'\n\n            mstore(0x80, typeHash)\n\n            mstore(0xa0, 0x10101)\n\n            mstore(0xe0, calldataload(0x144)) // challenge\n\n            mstore(0x100, calldataload(0x24))\n\n\n\n            // EIP712 Signature variables\n\n            // 0x13e - 0x140 = 0x1901\n\n            // 0x140 - 0x160 = domainHash\n\n            // 0x160 - 0x180 = structHash\n\n            mstore(0x120, 0x1901)\n\n            mstore(0x140, domainHash) // domain hash\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x280\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = type\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, calldataload(0x164))             // publicOwner\n\n            // store kPublic. If kPublic is negative, store correct signed representation,\n\n            // relative to 2^256, not to the order of the bn128 group\n\n            let kPublic := calldataload(sub(add(notes, mul(calldataload(notes), 0xc0)), 0xa0))\n\n            switch gt(kPublic, 10944121435919637611123202872628637544274182200208017171849102093287904247808)\n\n            case 1 {\n\n                mstore(0x260, sub(kPublic, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001))\n\n            }\n\n            case 0 {\n\n                mstore(0x260, kPublic)\n\n            }\n\n\n\n            mstore(0x280, calldataload(0x144))                    // store challenge\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to input signatures\n\n                let signatureIndex := add(signatures, mul(i, 0x60))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // note type\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n                // construct EIP712 signature parameters\n\n                mstore(0xc0, keccak256(0x00, 0xa0)) // note hash\n\n                mstore(0x80, typeHash)              // typeHash - eip signature params\n\n                // construct EIP712 signature message\n\n                mstore(0x160, keccak256(0x80, 0xa0))\n\n                mstore(0x00, keccak256(0x13e, 0x42))\n\n                // recover address of EIP712 signature\n\n                mstore(0x20, and(calldataload(signatureIndex), 0xff)) // get 8-bit v\n\n                calldatacopy(0x40, add(signatureIndex, 0x20), 0x40) // copy r, s into memory\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (1)\n\n                mstore(add(s, 0x20), 0x01)\n\n                mstore(0x80, typeHash)\n\n                mstore(0xa0, 0x10101)   // proof id 0x010101\n\n                \n\n                // store note owner in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(inputOwners, mul(i, 0x20))))\n\n\n\n                let t := staticcall(gas, 0x01, 0x00, 0x80, 0x00, 0x20)\n\n                let owner := mload(add(s, 0x40))\n\n                let recoveredAddress := mload(0x00)\n\n\n\n                // Check recovered address matches now owner, throw if not\n\n                if iszero(eq(recoveredAddress, owner)) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                } \n\n\n\n                if iszero(owner) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                } \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), mload(0xc0))\n\n                // store note metadata length in `s + 0x60` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // transition between input and output notes\n\n            // store total length of inputNotes at 1st index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // note type\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (1)\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            mstore(0x1e0, add(0xa0, notesLength)) // store length of proofOutput at 0x160\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
                    "message": "JoinSplitABIEncoder.encodeAndExit (JoinSplitABIEncoder.sol#43-281) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 281,
                    "vulnerability_code": "    function encodeAndExit(bytes32 domainHash) internal view {\n\n        bytes32 typeHash = JOIN_SPLIT_SIGNATURE_TYPE_HASH;\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x184))\n\n            let n := calldataload(notes)\n\n            let m := calldataload(0x124)\n\n            let inputOwners := add(0x124, calldataload(0x1c4)) // one word after inputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1e4)) // one word after outputOwners = 1st\n\n            let signatures := add(0x124, calldataload(0x1a4)) // one word after signatures = 1st\n\n            let metadata := add(0x144, calldataload(0x204)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // 0x00 - 0x160  = scratch data for EIP712 signature computation and note hash computation\n\n            // JOIN_SPLIT_SIGNATURE struct hash variables\n\n            // 0x80 = type hash\n\n            // 0xa0 = proof object (65793)\n\n            // 0xc0 = noteHash\n\n            // 0xe0 = challenge\n\n            // 0x100 = sender\n\n            // type hash of 'JOIN_SPLIT_SIGNATURE'\n\n            mstore(0x80, typeHash)\n\n            mstore(0xa0, 0x10101)\n\n            mstore(0xe0, calldataload(0x144)) // challenge\n\n            mstore(0x100, calldataload(0x24))\n\n\n\n            // EIP712 Signature variables\n\n            // 0x13e - 0x140 = 0x1901\n\n            // 0x140 - 0x160 = domainHash\n\n            // 0x160 - 0x180 = structHash\n\n            mstore(0x120, 0x1901)\n\n            mstore(0x140, domainHash) // domain hash\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x280\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = type\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, calldataload(0x164))             // publicOwner\n\n            // store kPublic. If kPublic is negative, store correct signed representation,\n\n            // relative to 2^256, not to the order of the bn128 group\n\n            let kPublic := calldataload(sub(add(notes, mul(calldataload(notes), 0xc0)), 0xa0))\n\n            switch gt(kPublic, 10944121435919637611123202872628637544274182200208017171849102093287904247808)\n\n            case 1 {\n\n                mstore(0x260, sub(kPublic, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001))\n\n            }\n\n            case 0 {\n\n                mstore(0x260, kPublic)\n\n            }\n\n\n\n            mstore(0x280, calldataload(0x144))                    // store challenge\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to input signatures\n\n                let signatureIndex := add(signatures, mul(i, 0x60))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // note type\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n                // construct EIP712 signature parameters\n\n                mstore(0xc0, keccak256(0x00, 0xa0)) // note hash\n\n                mstore(0x80, typeHash)              // typeHash - eip signature params\n\n                // construct EIP712 signature message\n\n                mstore(0x160, keccak256(0x80, 0xa0))\n\n                mstore(0x00, keccak256(0x13e, 0x42))\n\n                // recover address of EIP712 signature\n\n                mstore(0x20, and(calldataload(signatureIndex), 0xff)) // get 8-bit v\n\n                calldatacopy(0x40, add(signatureIndex, 0x20), 0x40) // copy r, s into memory\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (1)\n\n                mstore(add(s, 0x20), 0x01)\n\n                mstore(0x80, typeHash)\n\n                mstore(0xa0, 0x10101)   // proof id 0x010101\n\n                \n\n                // store note owner in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(inputOwners, mul(i, 0x20))))\n\n\n\n                let t := staticcall(gas, 0x01, 0x00, 0x80, 0x00, 0x20)\n\n                let owner := mload(add(s, 0x40))\n\n                let recoveredAddress := mload(0x00)\n\n\n\n                // Check recovered address matches now owner, throw if not\n\n                if iszero(eq(recoveredAddress, owner)) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                } \n\n\n\n                if iszero(owner) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                } \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), mload(0xc0))\n\n                // store note metadata length in `s + 0x60` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // transition between input and output notes\n\n            // store total length of inputNotes at 1st index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // note type\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (1)\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            mstore(0x1e0, add(0xa0, notesLength)) // store length of proofOutput at 0x160\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
                    "message": "JoinSplitABIEncoder.encodeAndExit uses assembly (JoinSplitABIEncoder.sol#43-281)\n\t- JoinSplitABIEncoder.sol#45-280\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in JoinSplitABIEncoder.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitABIEncoder.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeAndExit(bytes32 domainHash) internal view {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/ACE/validators/joinSplit/JoinSplit.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_15"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-state",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "JoinSplitInterface.EIP712_DOMAIN_HASH (JoinSplit.sol#411) shadows:\n\t- LibEIP712.EIP712_DOMAIN_HASH (JoinSplit.sol#313)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 281,
                    "vulnerability_code": "    function encodeAndExit(bytes32 domainHash) internal view {\n\n        bytes32 typeHash = JOIN_SPLIT_SIGNATURE_TYPE_HASH;\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x184))\n\n            let n := calldataload(notes)\n\n            let m := calldataload(0x124)\n\n            let inputOwners := add(0x124, calldataload(0x1c4)) // one word after inputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1e4)) // one word after outputOwners = 1st\n\n            let signatures := add(0x124, calldataload(0x1a4)) // one word after signatures = 1st\n\n            let metadata := add(0x144, calldataload(0x204)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // 0x00 - 0x160  = scratch data for EIP712 signature computation and note hash computation\n\n            // JOIN_SPLIT_SIGNATURE struct hash variables\n\n            // 0x80 = type hash\n\n            // 0xa0 = proof object (65793)\n\n            // 0xc0 = noteHash\n\n            // 0xe0 = challenge\n\n            // 0x100 = sender\n\n            // type hash of 'JOIN_SPLIT_SIGNATURE'\n\n            mstore(0x80, typeHash)\n\n            mstore(0xa0, 0x10101)\n\n            mstore(0xe0, calldataload(0x144)) // challenge\n\n            mstore(0x100, calldataload(0x24))\n\n\n\n            // EIP712 Signature variables\n\n            // 0x13e - 0x140 = 0x1901\n\n            // 0x140 - 0x160 = domainHash\n\n            // 0x160 - 0x180 = structHash\n\n            mstore(0x120, 0x1901)\n\n            mstore(0x140, domainHash) // domain hash\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x280\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = type\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, calldataload(0x164))             // publicOwner\n\n            // store kPublic. If kPublic is negative, store correct signed representation,\n\n            // relative to 2^256, not to the order of the bn128 group\n\n            let kPublic := calldataload(sub(add(notes, mul(calldataload(notes), 0xc0)), 0xa0))\n\n            switch gt(kPublic, 10944121435919637611123202872628637544274182200208017171849102093287904247808)\n\n            case 1 {\n\n                mstore(0x260, sub(kPublic, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001))\n\n            }\n\n            case 0 {\n\n                mstore(0x260, kPublic)\n\n            }\n\n\n\n            mstore(0x280, calldataload(0x144))                    // store challenge\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to input signatures\n\n                let signatureIndex := add(signatures, mul(i, 0x60))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // note type\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n                // construct EIP712 signature parameters\n\n                mstore(0xc0, keccak256(0x00, 0xa0)) // note hash\n\n                mstore(0x80, typeHash)              // typeHash - eip signature params\n\n                // construct EIP712 signature message\n\n                mstore(0x160, keccak256(0x80, 0xa0))\n\n                mstore(0x00, keccak256(0x13e, 0x42))\n\n                // recover address of EIP712 signature\n\n                mstore(0x20, and(calldataload(signatureIndex), 0xff)) // get 8-bit v\n\n                calldatacopy(0x40, add(signatureIndex, 0x20), 0x40) // copy r, s into memory\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (1)\n\n                mstore(add(s, 0x20), 0x01)\n\n                mstore(0x80, typeHash)\n\n                mstore(0xa0, 0x10101)   // proof id 0x010101\n\n                \n\n                // store note owner in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(inputOwners, mul(i, 0x20))))\n\n\n\n                let t := staticcall(gas, 0x01, 0x00, 0x80, 0x00, 0x20)\n\n                let owner := mload(add(s, 0x40))\n\n                let recoveredAddress := mload(0x00)\n\n\n\n                // Check recovered address matches now owner, throw if not\n\n                if iszero(eq(recoveredAddress, owner)) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                } \n\n\n\n                if iszero(owner) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                } \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), mload(0xc0))\n\n                // store note metadata length in `s + 0x60` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // transition between input and output notes\n\n            // store total length of inputNotes at 1st index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // note type\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (1)\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            mstore(0x1e0, add(0xa0, notesLength)) // store length of proofOutput at 0x160\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
                    "message": "JoinSplitABIEncoder.encodeAndExit (JoinSplit.sol#43-281) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": 355,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message (JoinSplit.sol#329-355) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": 402,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature (JoinSplit.sol#361-402) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 281,
                    "vulnerability_code": "    function encodeAndExit(bytes32 domainHash) internal view {\n\n        bytes32 typeHash = JOIN_SPLIT_SIGNATURE_TYPE_HASH;\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x184))\n\n            let n := calldataload(notes)\n\n            let m := calldataload(0x124)\n\n            let inputOwners := add(0x124, calldataload(0x1c4)) // one word after inputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1e4)) // one word after outputOwners = 1st\n\n            let signatures := add(0x124, calldataload(0x1a4)) // one word after signatures = 1st\n\n            let metadata := add(0x144, calldataload(0x204)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // 0x00 - 0x160  = scratch data for EIP712 signature computation and note hash computation\n\n            // JOIN_SPLIT_SIGNATURE struct hash variables\n\n            // 0x80 = type hash\n\n            // 0xa0 = proof object (65793)\n\n            // 0xc0 = noteHash\n\n            // 0xe0 = challenge\n\n            // 0x100 = sender\n\n            // type hash of 'JOIN_SPLIT_SIGNATURE'\n\n            mstore(0x80, typeHash)\n\n            mstore(0xa0, 0x10101)\n\n            mstore(0xe0, calldataload(0x144)) // challenge\n\n            mstore(0x100, calldataload(0x24))\n\n\n\n            // EIP712 Signature variables\n\n            // 0x13e - 0x140 = 0x1901\n\n            // 0x140 - 0x160 = domainHash\n\n            // 0x160 - 0x180 = structHash\n\n            mstore(0x120, 0x1901)\n\n            mstore(0x140, domainHash) // domain hash\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x280\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = type\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, calldataload(0x164))             // publicOwner\n\n            // store kPublic. If kPublic is negative, store correct signed representation,\n\n            // relative to 2^256, not to the order of the bn128 group\n\n            let kPublic := calldataload(sub(add(notes, mul(calldataload(notes), 0xc0)), 0xa0))\n\n            switch gt(kPublic, 10944121435919637611123202872628637544274182200208017171849102093287904247808)\n\n            case 1 {\n\n                mstore(0x260, sub(kPublic, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001))\n\n            }\n\n            case 0 {\n\n                mstore(0x260, kPublic)\n\n            }\n\n\n\n            mstore(0x280, calldataload(0x144))                    // store challenge\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to input signatures\n\n                let signatureIndex := add(signatures, mul(i, 0x60))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // note type\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n                // construct EIP712 signature parameters\n\n                mstore(0xc0, keccak256(0x00, 0xa0)) // note hash\n\n                mstore(0x80, typeHash)              // typeHash - eip signature params\n\n                // construct EIP712 signature message\n\n                mstore(0x160, keccak256(0x80, 0xa0))\n\n                mstore(0x00, keccak256(0x13e, 0x42))\n\n                // recover address of EIP712 signature\n\n                mstore(0x20, and(calldataload(signatureIndex), 0xff)) // get 8-bit v\n\n                calldatacopy(0x40, add(signatureIndex, 0x20), 0x40) // copy r, s into memory\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (1)\n\n                mstore(add(s, 0x20), 0x01)\n\n                mstore(0x80, typeHash)\n\n                mstore(0xa0, 0x10101)   // proof id 0x010101\n\n                \n\n                // store note owner in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(inputOwners, mul(i, 0x20))))\n\n\n\n                let t := staticcall(gas, 0x01, 0x00, 0x80, 0x00, 0x20)\n\n                let owner := mload(add(s, 0x40))\n\n                let recoveredAddress := mload(0x00)\n\n\n\n                // Check recovered address matches now owner, throw if not\n\n                if iszero(eq(recoveredAddress, owner)) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                } \n\n\n\n                if iszero(owner) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                } \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), mload(0xc0))\n\n                // store note metadata length in `s + 0x60` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // transition between input and output notes\n\n            // store total length of inputNotes at 1st index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // note type\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (1)\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            mstore(0x1e0, add(0xa0, notesLength)) // store length of proofOutput at 0x160\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
                    "message": "JoinSplitABIEncoder.encodeAndExit uses assembly (JoinSplit.sol#43-281)\n\t- JoinSplit.sol#45-280\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": 355,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message uses assembly (JoinSplit.sol#329-355)\n\t- JoinSplit.sol#343-354\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": 402,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature uses assembly (JoinSplit.sol#361-402)\n\t- JoinSplit.sol#366-396\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": 818,
                    "vulnerability_code": "    function() external {\n\n        bytes32 domainHash = EIP712_DOMAIN_HASH;\n\n        assembly {\n\n            // We don't check for function signatures,\n\n            // there's only one function that ever gets called: validateJoinSplit()\n\n            // We still assume calldata is offset by 4 bytes so that we can represent this contract\n\n            // through a compatible ABI\n\n            validateJoinSplit()\n\n\n\n            // if we get to here, the proof is valid. We now 'fall through' the assembly block\n\n            // and into JoinSplitABI.validateJoinSplit()\n\n            // reset the free memory pointer because we're touching Solidity code again\n\n            mstore(0x40, 0x60)\n\n\n\n            /**\n\n             * New calldata map\n\n             * 0x04:0x24      = calldata location of proofData byte array\n\n             * 0x24:0x44      = message sender\n\n             * 0x44:0x64      = h_x\n\n             * 0x64:0x84      = h_y\n\n             * 0x84:0xa4      = t2_x0\n\n             * 0xa4:0xc4      = t2_x1\n\n             * 0xc4:0xe4      = t2_y0\n\n             * 0xe4:0x104     = t2_y1\n\n             * 0x104:0x124    = length of proofData byte array\n\n             * 0x124:0x144    = m\n\n             * 0x144:0x164    = challenge\n\n             * 0x164:0x184    = publicOwner\n\n             * 0x184:0x1a4    = offset in byte array to notes\n\n             * 0x1a4:0x1c4    = offset in byte array to inputSignatures\n\n             * 0x1c4:0x1e4    = offset in byte array to inputOwners\n\n             * 0x1e4:0x204    = offset in byte array to outputOwners\n\n             * 0x204:0x224    = offset in byte array to metadata\n\n             */\n\n            function validateJoinSplit() {\n\n                mstore(0x80, calldataload(0x44))\n\n                mstore(0xa0, calldataload(0x64))\n\n                // SWC-Integer Overflow and Underflow: L71\n\n                let notes := add(0x104, calldataload(0x184))\n\n                let m := calldataload(0x124)\n\n                let n := calldataload(notes)\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let challenge := mod(calldataload(0x144), gen_order)\n\n\n\n                // validate m <= n\n\n                if gt(m, n) { mstore(0x00, 404) revert(0x00, 0x20) }\n\n\n\n                // recover k_{public} and calculate k_{public}\n\n                let kn := calldataload(sub(add(notes, mul(calldataload(notes), 0xc0)), 0xa0))\n\n\n\n                // add kn and m to final hash table\n\n                mstore(0x2a0, calldataload(0x24))\n\n                mstore(0x2c0, kn)\n\n                mstore(0x2e0, m)\n\n                mstore(0x300, calldataload(0x164))\n\n                kn := mulmod(sub(gen_order, kn), challenge, gen_order) // we actually want c*k_{public}\n\n                hashCommitments(notes, n)\n\n                let b := add(0x320, mul(n, 0x80))\n\n\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1,\n\n                //  which adds some minor alterations\n\n\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1,\n\n                //  which adds some minor alterations\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n                    // Get the calldata index of this note\n\n                    let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n\n\n                    // Define variables k, a and c.\n\n                    // If i <= m then\n\n                    //   k = kBar_i\n\n                    //   a = aBar_i\n\n                    //   c = challenge\n\n                    // If i > m then we add a modification for the pairing optimization\n\n                    //   k = kBar_i * x_i\n\n                    //   a = aBar_i * x_i\n\n                    //   c = challenge * x_i\n\n                    // Set j = i - (m + 1).\n\n                    // x_0 = 1\n\n                    // x_1 = keccak256(input string)\n\n                    // all other x_{j} = keccak256(x_{j-1})\n\n                    // The reason for doing this is that the point  \\sigma_i^{-cx_j} can be re-used in the pairing check\n\n                    // Instead of validating e(\\gamma_i, t_2) == e(\\sigma_i, g_2) for all i = [m+1,\\ldots,n]\n\n                    // We validate e(\\Pi_{i=m+1}^{n}\\gamma_i^{-cx_j}, t_2) == e(\\Pi_{i=m+1}^{n}\\sigma_i^{cx_j}, g_2).\n\n                    // x_j is a pseudorandom variable whose entropy source is the input string, allowing for\n\n                    // a sum of commitment points to be evaluated in one pairing comparison\n\n                    let k := calldataload(noteIndex)\n\n                    let a := calldataload(add(noteIndex, 0x20))\n\n                    let c := challenge\n\n\n\n                    // We don't transmit kBar_{n-1} in the proof to save space, instead we derive it from the\n\n                    // homomorphic sum condition: \\sum_{i=0}^{m-1}\\bar{k}_i = \\sum_{i=m}^{n-1}\\bar{k}_i + k_{public}c, \n\n                    // We can recover \\bar{k}_{n-1}.\n\n                    // If m=n then \\bar{k}_{n-1} = \\sum_{i=0}^{n-1}\\bar{k}_i + k_{public}\n\n                    // else \\bar{k}_{n-1} = \\sum_{i=0}^{m-1}\\bar{k}_i - \\sum_{i=m}^{n-1}\\bar{k}_i - k_{public}\n\n\n\n                    switch eq(add(i, 0x01), n)\n\n                    case 1 {\n\n                        k := kn\n\n\n\n                        // if all notes are input notes, invert k\n\n                        switch eq(m, n)\n\n                        case 1 {\n\n                            k := sub(gen_order, k)\n\n                        }\n\n                    }\n\n\n\n                    // Check this commitment is well formed...\n\n                    validateCommitment(noteIndex, k, a)\n\n\n\n                    // If i > m then this is an output note.\n\n                    // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\n\n                    switch gt(add(i, 0x01), m)\n\n                    case 1 {\n\n\n\n                        // before we update k, update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n\n                        kn := addmod(kn, sub(gen_order, k), gen_order)\n\n                        let x := mload(0x00)\n\n                        k := mulmod(k, x, gen_order)\n\n                        a := mulmod(a, x, gen_order)\n\n                        c := mulmod(challenge, x, gen_order)\n\n\n\n                        // calculate x_{j+1}\n\n                        mstore(0x00, keccak256(0x00, 0x20))\n\n                    }\n\n                    case 0 {\n\n\n\n                        // nothing to do here except update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n\n                        kn := addmod(kn, k, gen_order)\n\n                    }\n\n                \n\n                    // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\n\n                    // Memory map:\n\n                    // 0x20: \\gamma_iX\n\n                    // 0x40: \\gamma_iY\n\n                    // 0x60: k_i\n\n                    // 0x80: hX\n\n                    // 0xa0: hY\n\n                    // 0xc0: a_i\n\n                    // 0xe0: \\sigma_iX\n\n                    // 0x100: \\sigma_iY\n\n                    // 0x120: -c\n\n                    calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n\n                    calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n\n                    mstore(0x120, sub(gen_order, c)) \n\n                    mstore(0x60, k)\n\n                    mstore(0xc0, a)\n\n\n\n                    // Call bn128 scalar multiplication precompiles\n\n                    // Represent point + multiplication scalar in 3 consecutive blocks of memory\n\n                    // Store \\sigma_i^{-c} at 0x1a0:0x200\n\n                    // Store \\gamma_i^{k} at 0x120:0x160\n\n                    // Store h^{a} at 0x160:0x1a0\n\n                    let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40)\n\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\n\n                    result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\n\n\n\n                    // Call bn128 group addition precompiles\n\n                    // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n\n                    // Store result of addition at 0x160:0x1a0\n\n                    result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n\n\n                    // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n\n                    // Store resulting point B at memory index b\n\n                    result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n\n\n                    // We have \\sigma^{-c} at 0x1a0:0x200\n\n                    // And \\sigma_{acc} at 0x1e0:0x200\n\n                    // If i = m + 1 (i.e. first output note)\n\n                    // then we set \\gamma_{acc} and \\sigma_{acc} to \\gamma_i, -\\sigma_i\n\n                    if eq(i, m) {\n\n                        mstore(0x260, mload(0x20))\n\n                        mstore(0x280, mload(0x40))\n\n                        mstore(0x1e0, mload(0xe0))\n\n                        mstore(\n\n                            0x200,\n\n                            sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100))\n\n                        )\n\n                    }\n\n\n\n                    // If i > m + 1 (i.e. subsequent output notes)\n\n                    // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\n\n                    // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\n\n                    if gt(i, m) {\n\n                        mstore(0x60, c)\n\n\n\n                        result := and(\n\n                            result,\n\n                            and(\n\n                                and(\n\n                                    staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40),\n\n                                    staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40)\n\n                                ),\n\n                                staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40)\n\n                            )\n\n                        )\n\n                        /* result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\n\n\n\n                        // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\n\n                        result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\n\n\n\n                        // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\n\n                        result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40)) */\n\n                    }\n\n\n\n                    // throw transaction if any calls to precompiled contracts failed\n\n                    if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n\n                    b := add(b, 0x40) // increase B pointer by 2 words\n\n                }\n\n\n\n                // If the AZTEC protocol is implemented correctly then any input notes were previously outputs of\n\n                // a JoinSplit transaction. We can inductively assume that all input notes\n\n                // are well-formed AZTEC commitments and do not need to validate the implicit range proof\n\n                // This is not the case for any output commitments, so if (m < n) call validatePairing()\n\n                if lt(m, n) {\n\n                    validatePairing(0x84)\n\n                }\n\n\n\n                // We now have the note commitments and the calculated blinding factors in a block of memory\n\n                // starting at 0x2a0, of size (b - 0x2a0).\n\n                // Hash this block to reconstruct the initial challenge and validate that they match\n\n                let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n\n                if iszero(eq(expected, challenge)) {\n\n\n\n                    // No! Bad! No soup for you!\n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // Great! All done. This is a valid proof, so fall through out of the assembly block\n\n                // so that we can call `ABIEncoder.encodeAndExit`\n\n            }\n\n\n\n            /**        \n\n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\n\n             * @notice we don't hard-code t2 so that contracts that call this library can use\n\n             * different trusted setups.\n\n             **/\n\n            function validatePairing(t2) {\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let t2_x_1 := calldataload(t2)\n\n                let t2_x_2 := calldataload(add(t2, 0x20))\n\n                let t2_y_1 := calldataload(add(t2, 0x40))\n\n                let t2_y_2 := calldataload(add(t2, 0x60))\n\n\n\n                // check provided setup pubkey is not zero or g2\n\n                if or(or(or(or(or(or(or(\n\n                    iszero(t2_x_1),\n\n                    iszero(t2_x_2)),\n\n                    iszero(t2_y_1)),\n\n                    iszero(t2_y_2)),\n\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\n\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\n\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\n\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n\n                {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // store coords in memory\n\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\n\n                // to what precompile expects\n\n                // We can overwrite the memory we used previously as this function is called at the\n\n                // end of the validation routine.\n\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\n\n                mstore(0x40, mload(0x200)) // sigma accumulator y\n\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\n\n                mstore(0x100, mload(0x280)) // gamma accumulator y\n\n                mstore(0x140, t2_x_1)\n\n                mstore(0x120, t2_x_2)\n\n                mstore(0x180, t2_y_1)\n\n                mstore(0x160, t2_y_2)\n\n\n\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\n\n\n\n                if or(iszero(success), iszero(mload(0x20))) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**\n\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n\n             * and that signatures 'k' and 'a' are modulo the order of the curve.\n\n             * Transaction will throw if this is not the case.\n\n             * @param note the calldata loation of the note\n\n             **/\n\n            function validateCommitment(note, k, a) {\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let gammaX := calldataload(add(note, 0x40))\n\n                let gammaY := calldataload(add(note, 0x60))\n\n                let sigmaX := calldataload(add(note, 0x80))\n\n                let sigmaY := calldataload(add(note, 0xa0))\n\n                if iszero(\n\n                    and(\n\n                        and(\n\n                        and(\n\n                            eq(mod(a, gen_order), a), // a is modulo generator order?\n\n                            gt(a, 1)                  // can't be 0 or 1 either!\n\n                        ),\n\n                        and(\n\n                            eq(mod(k, gen_order), k), // k is modulo generator order?\n\n                            gt(k, 1)                  // and not 0 or 1\n\n                        )\n\n                        ),\n\n                        and(\n\n                        eq( // y^2 ?= x^3 + 3\n\n                            addmod(\n\n                                mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order),\n\n                                3,\n\n                                field_order\n\n                            ),\n\n                            mulmod(sigmaY, sigmaY, field_order)\n\n                        ),\n\n                        eq( // y^2 ?= x^3 + 3\n\n                            addmod(\n\n                                mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order),\n\n                                3,\n\n                                field_order\n\n                            ),\n\n                            mulmod(gammaY, gammaY, field_order)\n\n                        )\n\n                        )\n\n                    )\n\n                ) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**\n\n             * @dev Calculate the keccak256 hash of the commitments for both input notes and output notes.\n\n             * This is used both as an input to validate the challenge `c` and also to\n\n             * generate pseudorandom relationships\n\n             * between commitments for different outputNotes, so that we can combine them\n\n             * into a single multi-exponentiation for the purposes of validating the bilinear pairing relationships.\n\n             * @param notes calldata location notes\n\n             * @param n number of notes\n\n             **/\n\n            function hashCommitments(notes, n) {\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n                let index := add(add(notes, mul(i, 0xc0)), 0x60)\n\n                calldatacopy(add(0x320, mul(i, 0x80)), index, 0x80)\n\n                }\n\n                mstore(0x00, keccak256(0x320, mul(n, 0x80)))\n\n            }\n\n        }\n\n    \n\n        // if we've reached here, we've validated the join split transaction and haven't thrown an error.\n\n        // Encode the output according to the ACE standard and exit.\n\n        JoinSplitABIEncoder.encodeAndExit(domainHash);\n",
                    "message": "JoinSplit.fallback uses assembly (JoinSplit.sol#458-818)\n\t- JoinSplit.sol#460-813\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "JoinSplitInterface.EIP712_DOMAIN_HASH should be constant (JoinSplit.sol#411)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in JoinSplit.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplit.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplit.sol#286): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplit.sol#407): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplit.sol#428): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (JoinSplit.sol#313) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata, \n",
                    "message": "Parameter '' of JoinSplitInterface.validateJoinSplit (JoinSplit.sol#416) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address, \n",
                    "message": "Parameter '_scope_0' of JoinSplitInterface.validateJoinSplit (JoinSplit.sol#417) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6] calldata\n",
                    "message": "Parameter '_scope_1' of JoinSplitInterface.validateJoinSplit (JoinSplit.sol#418) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'JoinSplitInterface.EIP712_DOMAIN_HASH' (JoinSplit.sol#411) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validateJoinSplit(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeAndExit(bytes32 domainHash) internal view {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 343,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/ACE/validators/dividendComputation/DividendComputationABIEncoderTest.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 223,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x184))\n\n            let n := calldataload(notes)\n\n            let m := 1\n\n            let inputOwners := add(0x124, calldataload(0x1a4)) // one word after outputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1c4)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1e4)) // two words after metadata = 1st\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n\n\n            // `inputNotes` starts at 0x280\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, 0x00)             // publicOwner\n\n            // store kPublic. If kPublic is negative, store correct signed representation,\n\n            // relative to 2^256, not to the order of the bn128 group\n\n            let kPublic := 0\n\n            mstore(0x260, kPublic)\n\n\n\n            // 0x280 = challenge\n\n            mstore(0x280, calldataload(0x124))\n\n\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store note owner in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(inputOwners))\n\n            \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n\n\n                // store note metadata length in `s + 0x80` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // transition between input and output notes\n\n            // store total length of inputNotes at first index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            // store length of proofOutput at 0x160. 0xa0 comes from:\n\n            // (offset to input notes, offset to output notes, publicOwner, publicValue, challenge)\n\n            mstore(0x1e0, add(0xa0, notesLength))\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
                    "message": "DividendComputationABIEncoder.encodeAndExit (DividendComputationABIEncoderTest.sol#37-223) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 223,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x184))\n\n            let n := calldataload(notes)\n\n            let m := 1\n\n            let inputOwners := add(0x124, calldataload(0x1a4)) // one word after outputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1c4)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1e4)) // two words after metadata = 1st\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n\n\n            // `inputNotes` starts at 0x280\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, 0x00)             // publicOwner\n\n            // store kPublic. If kPublic is negative, store correct signed representation,\n\n            // relative to 2^256, not to the order of the bn128 group\n\n            let kPublic := 0\n\n            mstore(0x260, kPublic)\n\n\n\n            // 0x280 = challenge\n\n            mstore(0x280, calldataload(0x124))\n\n\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store note owner in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(inputOwners))\n\n            \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n\n\n                // store note metadata length in `s + 0x80` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // transition between input and output notes\n\n            // store total length of inputNotes at first index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            // store length of proofOutput at 0x160. 0xa0 comes from:\n\n            // (offset to input notes, offset to output notes, publicOwner, publicValue, challenge)\n\n            mstore(0x1e0, add(0xa0, notesLength))\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
                    "message": "DividendComputationABIEncoder.encodeAndExit uses assembly (DividendComputationABIEncoderTest.sol#37-223)\n\t- DividendComputationABIEncoderTest.sol#38-222\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in DividendComputationABIEncoderTest.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (DividendComputationABIEncoderTest.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (DividendComputationABIEncoderTest.sol#228): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata, \n",
                    "message": "Parameter '' of DividendComputationABIEncoderTest.validateDividendComputation (DividendComputationABIEncoderTest.sol#243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address, \n",
                    "message": "Parameter '_scope_0' of DividendComputationABIEncoderTest.validateDividendComputation (DividendComputationABIEncoderTest.sol#244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6] calldata\n",
                    "message": "Parameter '_scope_1' of DividendComputationABIEncoderTest.validateDividendComputation (DividendComputationABIEncoderTest.sol#245) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validateDividendComputation(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/ACE/validators/dividendComputation/DividendComputation.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 223,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x184))\n\n            let n := calldataload(notes)\n\n            let m := 1\n\n            let inputOwners := add(0x124, calldataload(0x1a4)) // one word after outputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1c4)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1e4)) // two words after metadata = 1st\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n\n\n            // `inputNotes` starts at 0x280\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, 0x00)             // publicOwner\n\n            // store kPublic. If kPublic is negative, store correct signed representation,\n\n            // relative to 2^256, not to the order of the bn128 group\n\n            let kPublic := 0\n\n            mstore(0x260, kPublic)\n\n\n\n            // 0x280 = challenge\n\n            mstore(0x280, calldataload(0x124))\n\n\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store note owner in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(inputOwners))\n\n            \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n\n\n                // store note metadata length in `s + 0x80` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // transition between input and output notes\n\n            // store total length of inputNotes at first index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            // store length of proofOutput at 0x160. 0xa0 comes from:\n\n            // (offset to input notes, offset to output notes, publicOwner, publicValue, challenge)\n\n            mstore(0x1e0, add(0xa0, notesLength))\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
                    "message": "DividendComputationABIEncoder.encodeAndExit (DividendComputation.sol#37-223) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 223,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x184))\n\n            let n := calldataload(notes)\n\n            let m := 1\n\n            let inputOwners := add(0x124, calldataload(0x1a4)) // one word after outputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1c4)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1e4)) // two words after metadata = 1st\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n\n\n            // `inputNotes` starts at 0x280\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, 0x00)             // publicOwner\n\n            // store kPublic. If kPublic is negative, store correct signed representation,\n\n            // relative to 2^256, not to the order of the bn128 group\n\n            let kPublic := 0\n\n            mstore(0x260, kPublic)\n\n\n\n            // 0x280 = challenge\n\n            mstore(0x280, calldataload(0x124))\n\n\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store note owner in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(inputOwners))\n\n            \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n\n\n                // store note metadata length in `s + 0x80` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // transition between input and output notes\n\n            // store total length of inputNotes at first index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            // store length of proofOutput at 0x160. 0xa0 comes from:\n\n            // (offset to input notes, offset to output notes, publicOwner, publicValue, challenge)\n\n            mstore(0x1e0, add(0xa0, notesLength))\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
                    "message": "DividendComputationABIEncoder.encodeAndExit uses assembly (DividendComputation.sol#37-223)\n\t- DividendComputation.sol#38-222\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": 633,
                    "vulnerability_code": "    function() external {\n\n        assembly {\n\n\n\n            // We don't check for function signatures, there's only one function \n\n            // that ever gets called: validateDividendComputation()\n\n            // We still assume calldata is offset by 4 bytes so that we can \n\n            // represent this contract through a compatible ABI\n\n            validateDividendComputation()\n\n\n\n            // if we get to here, the proof is valid. We now 'fall through' the assembly block\n\n            // and into DividendComputationABIEncoder.encodeAndExit()\n\n            // reset the free memory pointer because we're touching Solidity code again\n\n            mstore(0x40, 0x60)\n\n\n\n            /**\n\n             * New calldata map\n\n             * 0x04:0x24      = calldata location of proofData byte array  // proof data byte array\n\n             * 0x24:0x44      = message sender // address\n\n             * 0x44:0x64      = h_x     // crs\n\n             * 0x64:0x84      = h_y     // crs\n\n             * 0x84:0xa4      = t2_x0   // crs\n\n             * 0xa4:0xc4      = t2_x1   // crs\n\n             * 0xc4:0xe4      = t2_y0   // crs\n\n             * 0xe4:0x104     = t2_y1   // crs\n\n             * 0x104:0x124    = length of proofData byte array\n\n             * 0x124:0x144    = challenge\n\n             * 0x144:0x164    = za\n\n             * 0x164:0x184    = zb\n\n             * 0x184:0x1a4    = offset in byte array to notes\n\n             * 0x1a4:0x1c4    = offset in byte array to inputOwners\n\n             * 0x1c4:0x1e4    = offset in byte array to outputOwners\n\n             * 0x1e4:0x204    = offset in byte array to metadata\n\n             */ \n\n\n\n            function validateDividendComputation() {\n\n                \n\n                /*\n\n                ///////////////////////////////////////////  SETUP  //////////////////////////////////////////////\n\n                */\n\n                mstore(0x80, calldataload(0x44))\n\n                mstore(0xa0, calldataload(0x64))\n\n                let notes := add(0x104, calldataload(0x184))\n\n                let n := calldataload(notes)\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001                \n\n                let challenge := mod(calldataload(0x124), gen_order)\n\n\n\n                let za := mod(calldataload(0x144), gen_order)\n\n                let zb := mod(calldataload(0x164), gen_order)\n\n\n\n\n\n                // Check that za < kMax\n\n                if gt(za, 1048576) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // Check that zb < kMax\n\n                if gt(zb, 1048576) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                /*\n\n                m is the deliminator between input and output notes. \n\n                We only have one input note, and then the next two are output notes.\n\n\n\n                m = 0 and n = 3\n\n\n\n                Variables not defined and instead hard-coded, to save on stack depth\n\n                */\n\n\n\n                // add caller, za and zb to final hash table\n\n                mstore(0x2a0, calldataload(0x24))\n\n                mstore(0x2c0, za)\n\n                mstore(0x2e0, zb)\n\n\n\n                hashCommitments(notes, n) \n\n                let b := add(0x300, mul(n, 0x80)) \n\n\n\n                /*\n\n                ///////////////////////////  CALCULATE BLINDING FACTORS  /////////////////////////////////////\n\n                */\n\n\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1.\n\n                // This adds some minor alterations\n\n                for { let i := 0 } lt(i, 3) { i := add(i, 0x01) } {\n\n\n\n                    // Get the calldata index of this note - call data location of start of note\n\n                    let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n\n\n                    // Define variables k, a and c.\n\n                    // If i <= m then - input notes\n\n                    //   k = kBar_i\n\n                    //   a = aBar_i\n\n                    //   c = challenge\n\n                    // If i > m then we add a modification for the pairing optimization\n\n                    //   k = kBar_i * x_i\n\n                    //   a = aBar_i * x_i\n\n                    //   c = challenge * x_i\n\n                    // Set j = i - (m + 1). - index to count the output commitment\n\n                    // x_0 = 1\n\n                    // x_1 = keccak256(input string)\n\n                    // all other x_{j} = keccak256(x_{j-1})\n\n                    // The reason for doing this is that the point  \\sigma_i^{-cx_j} can be re-used in the pairing check\n\n                    // Instead of validating e(\\gamma_i, t_2) == e(\\sigma_i, g_2) for all i = [m+1,\\ldots,n]\n\n                    // We instead validate:\n\n                    // e(\\Pi_{i=m+1}^{n}\\gamma_i^{-cx_j}, t_2) == e(\\Pi_{i=m+1}^{n}\\sigma_i^{cx_j}, g_2).\n\n                    // x_j is a pseudorandom variable whose entropy source is the input string, allowing for\n\n                    // a sum of commitment points to be evaluated in one pairing comparison\n\n\n\n                    let k\n\n                    let a := calldataload(add(noteIndex, 0x20))\n\n                    let c := challenge\n\n\n\n                    switch gt(i, 1)\n\n                    case 1 { // output note\n\n                        /*\n\n                        Enforce the condition k_3 = (k_1)(z_b) - (k_2)(z_a)\n\n                        */\n\n                        k := addmod(\n\n                                    mulmod(\n\n                                        calldataload(sub(noteIndex, add(0xc0, 0xc0))),\n\n                                        zb,\n\n                                        gen_order), // k_1 * z_b\n\n                                    mulmod(\n\n                                        sub(gen_order, calldataload(sub(noteIndex, 0xc0))),\n\n                                        za,\n\n                                        gen_order), //-(k_2 * z_a)\n\n                                    gen_order)       \n\n                    }\n\n\n\n                    case 0 { // input note\n\n                        /*\n\n                        Input commitments just have the k factors as according to the note data\n\n                        */  \n\n                        k := calldataload(noteIndex)\n\n                    }\n\n\n\n\n\n                    // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\n\n                    let x := mod(mload(0x00), gen_order) // x is the kecca hash of the input commitments\n\n                    k := mulmod(k, x, gen_order) // kx\n\n                    a := mulmod(a, x, gen_order) // ax\n\n                    c := mulmod(challenge, x, gen_order) // cx\n\n                    // calculate x_{j+1}\n\n                    mstore(0x00, keccak256(0x00, 0x20)) // rehashing the kecca hash, for use in the next x\n\n\n\n\n\n                    // Check this commitment is well formed\n\n                    validateCommitment(noteIndex, k, a)\n\n\n\n                    // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i - already has all x stuff\n\n                    // Memory map:\n\n                    // 0x20: \\gamma_iX\n\n                    // 0x40: \\gamma_iY\n\n                    // 0x60: k_i\n\n                    // 0x80: hX\n\n                    // 0xa0: hY\n\n                    // 0xc0: a_i\n\n                    // 0xe0: \\sigma_iX\n\n                    // 0x100: \\sigma_iY\n\n                    // 0x120: -c\n\n\n\n                    // loading key variables into memory to be operated on later\n\n                    calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)  \n\n                    calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n\n                    mstore(0x120, sub(gen_order, c))\n\n                    mstore(0x60, k) \n\n                    mstore(0xc0, a)\n\n\n\n                    // Call bn128 scalar multiplication precompiles\n\n                    // Represent point + multiplication scalar in 3 consecutive blocks of memory\n\n                    // Store \\sigma_i^{-c} at 0x1a0:0x200\n\n                    // Store \\gamma_i^{k} at 0x120:0x160\n\n                    // Store h^{a} at 0x160:0x1a0\n\n                    \n\n                    // result is a boolean. It keeps track of whether the call to the pre-compile was \n\n                    // successful. True if it was, False if it wasn't\n\n                    let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40) // sigma_i^{-c}\n\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40)) // gamma_i^{k}\n\n                    result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40)) // h^{a}\n\n\n\n                    // Call bn128 group addition precompiles\n\n                    // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n\n                    // Store result of addition at 0x160:0x1a0\n\n                    result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n\n\n                    // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n\n                    // Store resulting point B at memory index b\n\n                    // index b points to the end of the block of memory containing commitments\n\n                    // we're appending blinding factors to the end of the commitment block\n\n                    result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n\n\n                    // We have \\sigma^{-c} at 0x1a0:0x200\n\n                    // And \\sigma_{acc} at 0x1e0:0x200\n\n                    // If i = m + 1 (i.e. first output note)\n\n                    // then we set \\gamma_{acc} and \\sigma_{acc} to \\gamma_i, -\\sigma_i\n\n                    // the accumulator is the variable that is used to condense the various pairing\n\n                    // comparisons into a single one\n\n                    if eq(i, 0) { // m = 0\n\n                        mstore(0x260, mload(0x20))\n\n                        mstore(0x280, mload(0x40))\n\n                        mstore(0x1e0, mload(0xe0))\n\n                        mstore(\n\n                            0x200,\n\n                            sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100))\n\n                            )\n\n                    }\n\n\n\n                    // If i > m + 1 (i.e. subsequent output notes)\n\n                    // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\n\n                    // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\n\n                    if gt(i, 0) { // m = 0\n\n                        mstore(0x60, c)\n\n                        result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\n\n\n\n                       // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\n\n                        result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\n\n\n\n                       // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\n\n                        result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40))\n\n                    }\n\n\n\n                    // throw transaction if any calls to precompiled contracts failed\n\n                    if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n\n                    b := add(b, 0x40) // increase B pointer by 2 words\n\n                }\n\n                \n\n\n\n                    validatePairing(0x84)\n\n\n\n                // We now have the message sender, z_a, z_b, note commitments and the \n\n                // calculated blinding factors in a block of memory starting at 0x2a0, of size (b - 0x2a0).\n\n                // Hash this block to reconstruct the initial challenge and validate that they match\n\n                let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n\n\n\n\n\n                if iszero(eq(expected, challenge)) {\n\n                    \n\n                    // Proof failed\n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**        \n\n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\n\n             * @notice we don't hard-code t2 so that contracts that call this library can use different trusted setups.\n\n             **/\n\n            function validatePairing(t2) {\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let t2_x_1 := calldataload(t2)\n\n                let t2_x_2 := calldataload(add(t2, 0x20))\n\n                let t2_y_1 := calldataload(add(t2, 0x40))\n\n                let t2_y_2 := calldataload(add(t2, 0x60))\n\n\n\n                // check provided setup pubkey is not zero or g2\n\n                if or(or(or(or(or(or(or(\n\n                    iszero(t2_x_1),\n\n                    iszero(t2_x_2)),\n\n                    iszero(t2_y_1)),\n\n                    iszero(t2_y_2)),\n\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\n\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\n\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\n\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n\n                {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // store coords in memory\n\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\n\n                // to what precompile expects. We can overwrite the memory we used previously as this function\n\n                // is called at the end of the validation routine.\n\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\n\n                mstore(0x40, mload(0x200)) // sigma accumulator y\n\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\n\n                mstore(0x100, mload(0x280)) // gamma accumulator y\n\n                mstore(0x140, t2_x_1)\n\n                mstore(0x120, t2_x_2)\n\n                mstore(0x180, t2_y_1)\n\n                mstore(0x160, t2_y_2)\n\n\n\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\n\n\n\n                if or(iszero(success), iszero(mload(0x20))) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**\n\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n\n             * and that signatures 'k' and 'a' are modulo the order of the curve. \n\n             * Transaction will throw if this is not the case.\n\n             * @param note the calldata loation of the note\n\n             **/\n\n            function validateCommitment(note, k, a) {\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let gammaX := calldataload(add(note, 0x40))\n\n                let gammaY := calldataload(add(note, 0x60))\n\n                let sigmaX := calldataload(add(note, 0x80))\n\n                let sigmaY := calldataload(add(note, 0xa0))\n\n                if iszero(\n\n                    and(\n\n                        and(\n\n                            and(\n\n                                eq(mod(a, gen_order), a), // a is modulo generator order?\n\n                                gt(a, 1)                  // can't be 0 or 1 either!\n\n                            ),\n\n                            and(\n\n                                eq(mod(k, gen_order), k), // k is modulo generator order?\n\n                                gt(k, 1)                  // and not 0 or 1\n\n                            )\n\n                        ),\n\n                        and(\n\n                            eq( // y^2 ?= x^3 + 3\n\n                                addmod(\n\n                                    mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), \n\n                                    3, \n\n                                    field_order),\n\n                                mulmod(sigmaY, sigmaY, field_order)\n\n                            ),\n\n                            eq( // y^2 ?= x^3 + 3\n\n                                addmod(\n\n                                    mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order),\n\n                                    3,\n\n                                    field_order),\n\n                                mulmod(gammaY, gammaY, field_order)\n\n                            )\n\n                        )\n\n                    )\n\n                ) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**\n\n             * @dev Calculate the keccak256 hash of the commitments for both input notes and output notes.\n\n             * This is used both as an input to validate the challenge `c` and also \n\n             * to generate pseudorandom relationships between commitments for different outputNotes, so \n\n             * that we can combine them into a single multi-exponentiation for the purposes of \n\n             * validating the bilinear pairing relationships.\n\n             * @param notes calldata location of notes\n\n             * @param n number of notes\n\n             * \n\n             * @notice\n\n             */\n\n\n\n            function hashCommitments(notes, n) {\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } { \n\n                    let index := add(add(notes, mul(i, 0xc0)), 0x60) \n\n                    calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n\n                }\n\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n\n            }\n\n        }\n\n\n\n        DividendComputationABIEncoder.encodeAndExit();\n",
                    "message": "DividendComputation.fallback uses assembly (DividendComputation.sol#266-633)\n\t- DividendComputation.sol#267-630\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in DividendComputation.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (DividendComputation.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (DividendComputation.sol#228): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (DividendComputation.sol#244): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata,\n",
                    "message": "Parameter '' of DividendComputationInterface.validateDividendComputation (DividendComputation.sol#232) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of DividendComputationInterface.validateDividendComputation (DividendComputation.sol#233) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6] calldata\n",
                    "message": "Parameter '_scope_1' of DividendComputationInterface.validateDividendComputation (DividendComputation.sol#234) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validateDividendComputation(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/ACE/validators/dividendComputation/DividendComputationABIEncoder.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 223,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x184))\n\n            let n := calldataload(notes)\n\n            let m := 1\n\n            let inputOwners := add(0x124, calldataload(0x1a4)) // one word after outputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1c4)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1e4)) // two words after metadata = 1st\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n\n\n            // `inputNotes` starts at 0x280\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, 0x00)             // publicOwner\n\n            // store kPublic. If kPublic is negative, store correct signed representation,\n\n            // relative to 2^256, not to the order of the bn128 group\n\n            let kPublic := 0\n\n            mstore(0x260, kPublic)\n\n\n\n            // 0x280 = challenge\n\n            mstore(0x280, calldataload(0x124))\n\n\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store note owner in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(inputOwners))\n\n            \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n\n\n                // store note metadata length in `s + 0x80` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // transition between input and output notes\n\n            // store total length of inputNotes at first index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            // store length of proofOutput at 0x160. 0xa0 comes from:\n\n            // (offset to input notes, offset to output notes, publicOwner, publicValue, challenge)\n\n            mstore(0x1e0, add(0xa0, notesLength))\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
                    "message": "DividendComputationABIEncoder.encodeAndExit (DividendComputationABIEncoder.sol#37-223) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 223,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x184))\n\n            let n := calldataload(notes)\n\n            let m := 1\n\n            let inputOwners := add(0x124, calldataload(0x1a4)) // one word after outputOwners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x1c4)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1e4)) // two words after metadata = 1st\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (1)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutput`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n\n\n            // `inputNotes` starts at 0x280\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x01)                            // number of proofs\n\n            mstore(0x1c0, 0x60)                            // offset to 1st proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x200, 0xc0)                            // location of inputNotes\n\n            // location of outputNotes is at s + 0xc0\n\n            mstore(0x240, 0x00)             // publicOwner\n\n            // store kPublic. If kPublic is negative, store correct signed representation,\n\n            // relative to 2^256, not to the order of the bn128 group\n\n            let kPublic := 0\n\n            mstore(0x260, kPublic)\n\n\n\n            // 0x280 = challenge\n\n            mstore(0x280, calldataload(0x124))\n\n\n\n            let inputPtr := 0x2a0                                 // point to inputNotes\n\n            mstore(add(inputPtr, 0x20), m)                        // number of input notes\n\n            // set note pointer, offsetting lookup indices for each input note\n\n            let s := add(0x2e0, mul(m, 0x20))\n\n\n\n            for { let i := 0 } lt(i, m) { i := add(i, 0x01) } {\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // copy note data to 0x00 - 0x80\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n\n\n                // store note length in `s`\n\n                mstore(s, 0xc0)\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store note owner in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(inputOwners))\n\n            \n\n                // store note hash in `s + 0x60`\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n\n\n                // store note metadata length in `s + 0x80` (just the coordinates)\n\n                mstore(add(s, 0x80), 0x40)\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x40)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0x60)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        calldataload(add(noteIndex, 0x80)),\n\n                        mul(\n\n                            and(calldataload(add(noteIndex, 0xa0)), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(i, 0x20)), sub(s, inputPtr)) // relative offset to note\n\n        \n\n                // increase s by note length\n\n                s := add(s, 0xe0)\n\n            }\n\n\n\n            // transition between input and output notes\n\n            // store total length of inputNotes at first index of inputNotes \n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20))\n\n            mstore(0x220, add(0xc0, sub(s, inputPtr))) // store relative memory offset to outputNotes\n\n            inputPtr := s\n\n            mstore(add(inputPtr, 0x20), sub(n, m)) // store number of output notes\n\n            s := add(s, add(0x40, mul(sub(n, m), 0x20)))\n\n\n\n            // output notes\n\n            for { let i := m } lt(i, n) { i := add(i, 0x01) } {\n\n                // get note index\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // get pointer to metadata\n\n                let metadataIndex := calldataload(add(metadata, mul(sub(i, m), 0x20)))\n\n                // get size of metadata\n\n                let metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01) // store note type at 0x00\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x80) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO = 1) in `s+0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x20`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, m), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x60`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0x80`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        mul(\n\n                            and(mload(0x40), 0x01),\n\n                            0x8000000000000000000000000000000000000000000000000000000000000000\n\n                        )\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xa0`\n\n                mstore(\n\n                add(s, 0xc0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n                )\n\n                // copy metadata into `s + 0xc0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(add(inputPtr, 0x40), mul(sub(i, m), 0x20)), sub(s, inputPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // cleanup. the length of the outputNotes = s - inputPtr\n\n            mstore(inputPtr, sub(sub(s, inputPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            let notesLength := sub(s, 0x2a0)\n\n            // store length of proofOutput at 0x160. 0xa0 comes from:\n\n            // (offset to input notes, offset to output notes, publicOwner, publicValue, challenge)\n\n            mstore(0x1e0, add(0xa0, notesLength))\n\n            mstore(0x180, add(0x100, notesLength)) // store length of proofOutputs at 0x100\n\n\n\n            mstore(0x160, 0x20)\n\n            return(0x160, add(0x140, notesLength)) // return the final byte array\n\n        }\n",
                    "message": "DividendComputationABIEncoder.encodeAndExit uses assembly (DividendComputationABIEncoder.sol#37-223)\n\t- DividendComputationABIEncoder.sol#38-222\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in DividendComputationABIEncoder.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (DividendComputationABIEncoder.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/ACE/validators/adjustSupply/AdjustSupply.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 343,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 437,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_13"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 306,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let n := calldataload(notes)\n\n            let inputOwners := add(0x124, calldataload(0x164)) // one word after input owners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x184)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1a4)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput A` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutputA`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes A` starts at 0x2a0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // `proofOutput B` - r\n\n            // 0x00 - 0x20 = length of `proofOutput B`\n\n            // 0x20 - 0x40 = relative offset between `r` and `inputNotes`\n\n            // 0x40 - 0x60 = relative offset between `r` and `outputNotes`\n\n            // 0x60 - 0x80 = `publicOwner`\n\n            // 0x80 - 0xa0 = `publicValue`\n\n            // 0xa0 - 0xc0 = `challenge`\n\n\n\n            // 'inputNotes B'\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x02)                            // there are two proofOutput objects for an adjustSupply\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n            // 0x1e0 = offset to 2nd proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n            mstore(0x260, 0x00)                            // publicOwner is 0\n\n            mstore(0x280, 0x00)                            // publicValue is 0\n\n\n\n            mstore(0x2a0, calldataload(0x124))\n\n\n\n            // set note pointer, offsetting lookup indices for each input note\n\n\n\n            /////////////////// PROOF OUTPUT A: START OF INPUT NOTES //////////////////\n\n            // 0x2c0 = number of bytes in `inputNotes` (leave blank for now)\n\n            // 0x2e0 = number of input notes\n\n            mstore(0x2e0, 0x01)\n\n\n\n            // 0x300 = relative offset to 1st input note (0x60)\n\n            mstore(0x300, 0x60)\n\n\n\n            // Start of inputNote[0]\n\n            // get pointer to metadata\n\n            let metadataIndex := calldataload(metadata)\n\n            // get size of metadata\n\n            let metadataLength := calldataload(add(metadataIndex, sub(metadata, 0x40)))\n\n\n\n            // copy note data to 0x20 - 0xa0\n\n            mstore(0x00, 0x01)\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s` = 0x320\n\n            mstore(0x320, add(0xc0, metadataLength))\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x340, 0x01)\n\n            // store the owner of the note in `s + 0x40`\n\n            mstore(0x360, calldataload(outputOwners))\n\n            // store note hash\n\n            mstore(0x380, keccak256(0x00, 0xa0))\n\n            // store note metadata length if `s + 0x80`\n\n            mstore(0x3a0, add(0x40, metadataLength))\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // copy metadata into `s + 0xe0`\n\n            calldatacopy(0x400, add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n            // compute the relative offset to index this note in our returndata\n\n\n\n            // increase s by note length\n\n\n\n            // store relative memory offset to outputNotes\n\n            mstore(0x240, add(0x200, metadataLength))\n\n            // store the length of inputNotes at 0x2c0\n\n            mstore(0x2c0, add(0x120, metadataLength))\n\n            ///////////////// PROOF OUTPUT A: START OF OUTPUT NOTES (1) ///////////////////\n\n\n\n            // transition between input and output notes\n\n            \n\n            // 0x400 + metadataLength = byte length of output notes (0x120)\n\n            // 0x420 + metadataLength = # of output notes (1)\n\n            // 0x440 + metadataLength = offset to outputNotes[0] (0x60)\n\n            mstore(add(0x400, metadataLength), 0x120) // store length of output notes\n\n            mstore(add(0x420, metadataLength), 0x01) // store number of output notes\n\n            mstore(add(0x440, metadataLength), 0x60) // store offset to outputNotes[0]\n\n        \n\n            // construct note hash\n\n            // copy 1st note note to 0x20 - 0xa0\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s`\n\n            mstore(add(0x460, metadataLength), 0xc0)\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(add(0x480, metadataLength), 0x01)\n\n            // store note owner in `s + 0x40`\n\n            mstore(add(0x4a0, metadataLength), calldataload(inputOwners))\n\n            // store note hash in `s + 0x60`\n\n            mstore(add(0x4c0, metadataLength), keccak256(0x00, 0xa0))\n\n            // store note metadata length in `s + 0x80` (just the coordinates)\n\n            mstore(add(0x4e0, metadataLength), 0x40)\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                add(0x500, metadataLength),\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                add(0x520, metadataLength),\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // compute the relative offset to index this note in our returndata\n\n            mstore(add(0x440, metadataLength), 0x60) // relative offset to note\n\n    \n\n            // now we need to transition between first and second proofOutput\n\n            // s is going to point to the end of the outputNotes array\n\n            // so, s is our absolute pointer to the start of the 2nd proofOutputs entry\n\n            // we know that 'proofOutputs' starts at 0x180\n\n            // so (s - 0x180) = relative offset to second proofOutputs entry\n\n            let startOfProofOutput := add(0x540, metadataLength)\n\n\n\n            // proofOutput[0].length = start of proofOutput[1] - start of proofOutput[0] - 0x20\n\n            // proofOutput[0].length = (0x540 + metadataLength) - 0x200 - 0x20 = 0x320 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength)) // length of proofOutput\n\n            mstore(0x1e0, add(0x3c0, metadataLength)) // offset to get to second proofOutput\n\n\n\n            // s points to the start of proofOutputs[0]\n\n            let s := startOfProofOutput\n\n            mstore(add(s, 0x20), 0xc0)   // location of inputNotes\n\n            mstore(add(s, 0x40), 0x100)  // location of outputNotes\n\n            mstore(add(s, 0x60), 0x00)   // publicOwner\n\n            mstore(add(s, 0x80), 0x00)   // publicValue\n\n\n\n            // compute challenge = kecck256(challenge)\n\n            mstore(0x20, calldataload(0x124))\n\n            mstore(add(s, 0xa0), keccak256(0x20, 0x20)) // challenge\n\n            // 0x00 length of proofOutput\n\n            // 0x20 location of inputNotes\n\n            // 0x40 location of outputNotes\n\n            // 0x60 publicOwner\n\n            // 0x80 publicValue\n\n            // 0xa0 = inputNoteData\n\n            mstore(add(s, 0xc0), 0x20) // length of input notes array (1 word)\n\n            mstore(add(s, 0xe0), 0x00) // number of entries (0 words)\n\n\n\n            // set notesPtr = proofOutputs[1].outputNotes\n\n            let notesPtr := add(s, 0x100)\n\n\n\n            // s + 0x20 = number of notes = n - 2\n\n            mstore(add(notesPtr, 0x20), sub(n, 2))\n\n\n\n            // set s to point to proofOutputs[1].outputNotes[0]\n\n            s := add(add(s, 0x140), mul(0x20, sub(n, 2)))\n\n\n\n            // Output notes:\n\n            // first output note needs to go into the first proofOutput object\n\n            // second output note onwards, needs to go into the second proofOutput object\n\n            for { let i := 0x02 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n            /////////////////// START OF PROOF OUTPUT B  ////////////////////\n\n\n\n                // get pointer to metadata\n\n                metadataIndex := calldataload(add(metadata, mul(sub(i, 0x01), 0x20)))\n\n                // get size of metadata\n\n                metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01)\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(\n\n                    0x20,\n\n                    add(add(notes, 0x60), mul(i, 0xc0)),\n\n                    0x80\n\n                ) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO type, 0x01) in `s + 0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, 0x01), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x80`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        shl(255, and(mload(0x40), 0x01))\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xc0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        mload(0x60),\n\n                        shl(255, and(mload(0x80), 0x01))\n\n                    )\n\n                )\n\n                // copy metadata into `s + 0xe0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(notesPtr, mul(i, 0x20)), sub(s, notesPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // inputPtr used to point to start of inputNotes for proofOutputs[0]\n\n            // now we want inputPtr to point to start of inputNotes for proofOutputs[1]\n\n            // 1. length of proofOutput\n\n            // 2. length of outputNotes\n\n            // length of outputNotes = s - inputPtr, stored at inputPtr\n\n            mstore(notesPtr, sub(sub(s, notesPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            // length of proofOutput\n\n            let proofOutputLength := sub(s, startOfProofOutput)\n\n            mstore(startOfProofOutput, sub(proofOutputLength, 0x20))\n\n            mstore(0x180, sub(s, 0x1a0)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, sub(s, 0x160)) // return the final byte array\n\n        }\n",
                    "message": "AdjustSupplyABIEncoder.encodeAndExit (AdjustSupply.sol#25-306) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 380,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message (AdjustSupply.sol#354-380) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": 427,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature (AdjustSupply.sol#386-427) is declared view but contains assembly code\n"
                },
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 815,
                    "vulnerability_code": "    function() external payable {\n\n        assembly {\n\n            // We don't check for function signatures,\n\n            // there's only one function that ever gets called: validateAdjustSupply()\n\n            // We still assume calldata is offset by 4 bytes so that we can represent this contract\n\n            // through a compatible ABI\n\n            validateAdjustSupply()\n\n\n\n            /**\n\n             * New calldata map\n\n             * 0x04:0x24      = calldata location of proofData byte array\n\n             * 0x24:0x44      = message sender\n\n             * 0x44:0x64      = h_x\n\n             * 0x64:0x84      = h_y\n\n             * 0x84:0xa4      = t2_x0\n\n             * 0xa4:0xc4      = t2_x1\n\n             * 0xc4:0xe4      = t2_y0\n\n             * 0xe4:0x104     = t2_y1\n\n             * 0x104:0x124    = length of proofData byte array\n\n             * 0x124:0x144    = challenge\n\n             * 0x144:0x164    = offset in byte array to notes\n\n             * 0x164:0x184    = offset in byte array to inputOwners\n\n             * 0x184:0x1a4    = offset in byte array to outputOwners\n\n             * 0x1a4:0x1c4    = offset in byte array to metadata\n\n             */\n\n            function validateAdjustSupply() {\n\n                mstore(0x80, calldataload(0x44))\n\n                mstore(0xa0, calldataload(0x64))\n\n                let notes := add(0x104, calldataload(0x144)) // get the length of notes\n\n                let m := 1\n\n                let n := calldataload(notes)\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let challenge := mod(calldataload(0x124), gen_order)\n\n\n\n\n\n                // validate m < n\n\n                if gt(m, n) { \n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                if eq(m, n) { \n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n                \n\n                let kn := 0\n\n\n\n                // add sender final hash table\n\n                mstore(0x2a0, calldataload(0x24))\n\n                mstore(0x2c0, 0) // add kPublic = 0 to hash table\n\n                mstore(0x2e0, m) // add m to final hash table\n\n\n\n                hashCommitments(notes, n)  // notes = length of proof data array, n = number of notes\n\n                let b := add(0x300, mul(n, 0x80))\n\n\n\n\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1,\n\n                //  which adds some minor alterations\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n                // Get the calldata index of this note\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n\n\n                // Define variables k, a and c.\n\n                // If i <= m then\n\n                //   k = kBar_i\n\n                //   a = aBar_i\n\n                //   c = challenge\n\n                // If i > m then we add a modification for the pairing optimization\n\n                //   k = kBar_i * x_i\n\n                //   a = aBar_i * x_i\n\n                //   c = challenge * x_i\n\n                // Set j = i - (m + 1).\n\n                // x_0 = 1\n\n                // x_1 = keccak256(input string)\n\n                // all other x_{j} = keccak256(x_{j-1})\n\n                // The reason for doing this is that the point  \\sigma_i^{-cx_j} can be re-used in the pairing check\n\n                // Instead of validating e(\\gamma_i, t_2) == e(\\sigma_i, g_2) for all i = [m+1,\\ldots,n]\n\n                // We validate e(\\Pi_{i=m+1}^{n}\\gamma_i^{-cx_j}, t_2) == e(\\Pi_{i=m+1}^{n}\\sigma_i^{cx_j}, g_2).\n\n                // x_j is a pseudorandom variable whose entropy source is the input string, allowing for\n\n                // a sum of commitment points to be evaluated in one pairing comparison\n\n                let k\n\n                let a := calldataload(add(noteIndex, 0x20))\n\n                let c := challenge\n\n                \n\n                switch eq(add(i, 0x01), n)\n\n                    case 1 {\n\n                        k := kn\n\n                    }\n\n                    case 0 { k := calldataload(noteIndex) }\n\n\n\n\n\n                // Check this commitment is well formed...\n\n                validateCommitment(noteIndex, k, a)\n\n\n\n\n\n                // If i > m then this is an output note.\n\n                // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\n\n                switch gt(add(i, 0x01), m)\n\n                case 1 {\n\n                    // before we update k, update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n\n                    kn := addmod(kn, sub(gen_order, k), gen_order)\n\n                    let x := mod(mload(0x00), gen_order)\n\n                    k := mulmod(k, x, gen_order)\n\n                    a := mulmod(a, x, gen_order)\n\n                    c := mulmod(challenge, x, gen_order)\n\n\n\n                    // calculate x_{j+1}\n\n                    mstore(0x00, keccak256(0x00, 0x20))\n\n                }\n\n\n\n                case 0 {\n\n\n\n                    // nothing to do here except update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n\n                    kn := addmod(kn, k, gen_order)\n\n                }\n\n\n\n                // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\n\n                // Memory map:\n\n                // 0x20: \\gamma_iX\n\n                // 0x40: \\gamma_iY\n\n                // 0x60: k_i\n\n                // 0x80: hX\n\n                // 0xa0: hY\n\n                // 0xc0: a_i\n\n                // 0xe0: \\sigma_iX\n\n                // 0x100: \\sigma_iY\n\n                // 0x120: -c\n\n                calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n\n                mstore(0x120, sub(gen_order, c)) \n\n                mstore(0x60, k)\n\n                mstore(0xc0, a)\n\n\n\n                // Call bn128 scalar multiplication precompiles\n\n                // Represent point + multiplication scalar in 3 consecutive blocks of memory\n\n                // Store \\sigma_i^{-c} at 0x1a0:0x200\n\n                // Store \\gamma_i^{k} at 0x120:0x160\n\n                // Store h^{a} at 0x160:0x1a0\n\n                let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40)\n\n                result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\n\n                result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\n\n\n\n                // Call bn128 group addition precompiles\n\n                // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n\n                // Store result of addition at 0x160:0x1a0\n\n                result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n\n\n                // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n\n                // Store resulting point B at memory index b\n\n                result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n\n\n                // We have \\sigma^{-c} at 0x1a0:0x200\n\n                // And \\sigma_{acc} at 0x1e0:0x200\n\n                // If i = m + 1 (i.e. first output note)\n\n                // then we set \\gamma_{acc} and \\sigma_{acc} to \\gamma_i, -\\sigma_i\n\n                if eq(i, m) {\n\n                    mstore(0x260, mload(0x20))\n\n                    mstore(0x280, mload(0x40))\n\n                    mstore(0x1e0, mload(0xe0))\n\n                    mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n\n                }\n\n\n\n                // If i > m + 1 (i.e. subsequent output notes)\n\n                // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\n\n                // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\n\n                if gt(i, m) {\n\n                    mstore(0x60, c)\n\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\n\n\n\n                    // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\n\n                    result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\n\n\n\n                    // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\n\n                    result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40))\n\n                }\n\n\n\n\n\n                // throw transaction if any calls to precompiled contracts failed\n\n                if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n\n                    b := add(b, 0x40) // increase B pointer by 2 words\n\n                }\n\n\n\n                // If the AZTEC protocol is implemented correctly then any input notes were previously outputs of\n\n                // a AdjustSupply transaction. We can inductively assume that all input notes\n\n                // are well-formed AZTEC commitments and do not need to validate the implicit range proof\n\n                // This is not the case for any output commitments, so if (m < n) call validatePairing()\n\n                if lt(m, n) {\n\n                    validatePairing(0x84)\n\n                }\n\n\n\n\n\n                // We now have the note commitments and the calculated blinding factors in a block of memory\n\n                // starting at 0x2a0, of size (b - 0x2a0).\n\n                // Hash this block to reconstruct the initial challenge and validate that they match\n\n\n\n                let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n\n\n\n                if iszero(eq(expected, challenge)) {\n\n\n\n                    // No! Bad! No soup for you!\n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // Great! All done. This is a valid proof, so fall through out of the assembly block\n\n                // so that we can call `ABIEncoder.encodeAndExit`\n\n\n\n            }\n\n\n\n\n\n            /**        \n\n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\n\n             * @notice we don't hard-code t2 so that contracts that call this library can use\n\n             * different trusted setups.\n\n             **/\n\n            function validatePairing(t2) {\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let t2_x_1 := calldataload(t2)\n\n                let t2_x_2 := calldataload(add(t2, 0x20))\n\n                let t2_y_1 := calldataload(add(t2, 0x40))\n\n                let t2_y_2 := calldataload(add(t2, 0x60))\n\n\n\n                // check provided setup pubkey is not zero or g2\n\n                if or(or(or(or(or(or(or(\n\n                    iszero(t2_x_1),\n\n                    iszero(t2_x_2)),\n\n                    iszero(t2_y_1)),\n\n                    iszero(t2_y_2)),\n\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\n\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\n\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\n\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n\n                {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // store coords in memory\n\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\n\n                // to what precompile expects\n\n                // We can overwrite the memory we used previously as this function is called at the\n\n                // end of the validation routine.\n\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\n\n                mstore(0x40, mload(0x200)) // sigma accumulator y\n\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\n\n                mstore(0x100, mload(0x280)) // gamma accumulator y\n\n                mstore(0x140, t2_x_1)\n\n                mstore(0x120, t2_x_2)\n\n                mstore(0x180, t2_y_1)\n\n                mstore(0x160, t2_y_2)\n\n\n\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\n\n\n\n                if or(iszero(success), iszero(mload(0x20))) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n            }\n\n\n\n            /**\n\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n\n             * and that signatures 'k' and 'a' are modulo the order of the curve.\n\n             * Transaction will throw if this is not the case.\n\n             * @param note the calldata loation of the note\n\n             **/\n\n            function validateCommitment(note, k, a) {\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let gammaX := calldataload(add(note, 0x40))\n\n                let gammaY := calldataload(add(note, 0x60))\n\n                let sigmaX := calldataload(add(note, 0x80))\n\n                let sigmaY := calldataload(add(note, 0xa0))\n\n                if iszero(\n\n                    and(\n\n                        and(\n\n                        and(\n\n                            eq(mod(a, gen_order), a), // a is modulo generator order?\n\n                            gt(a, 1)                  // can't be 0 or 1 either!\n\n                        ),\n\n                        and(\n\n                            eq(mod(k, gen_order), k), // k is modulo generator order?\n\n                            gt(k, 1)                  // and not 0 or 1\n\n                        )\n\n                        ),\n\n                        and(\n\n                        eq( // y^2 ?= x^3 + 3\n\n                            addmod(\n\n                                mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order),\n\n                                3,\n\n                                field_order\n\n                            ),\n\n                            mulmod(sigmaY, sigmaY, field_order)\n\n                        ),\n\n                        eq( // y^2 ?= x^3 + 3\n\n                            addmod(\n\n                                mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order),\n\n                                3,\n\n                                field_order\n\n                            ),\n\n                            mulmod(gammaY, gammaY, field_order)\n\n                        )\n\n                        )\n\n                    )\n\n                ) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**\n\n             * @dev Calculate the keccak256 hash of the commitments for both input notes and output notes.\n\n             * This is used both as an input to validate the challenge `c` and also to\n\n             * generate pseudorandom relationships\n\n             * between commitments for different outputNotes, so that we can combine them\n\n             * into a single multi-exponentiation for the purposes of validating the bilinear pairing relationships.\n\n             * @param notes calldata location notes\n\n             * @param n number of notes\n\n             **/\n\n            function hashCommitments(notes, n) {\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n                let index := add(add(notes, mul(i, 0xc0)), 0x60)\n\n                calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n\n                }\n\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n\n            }\n\n        }\n\n\n\n        // if we've reached here, we've validated the join split transaction and haven't thrown an error.\n\n        // Encode the output according to the ACE standard and exit.\n\n        AdjustSupplyABIEncoder.encodeAndExit();\n",
                    "message": "Contract locking ether found in AdjustSupply.sol:\n\tContract AdjustSupply has payable functions:\n\t - fallback (AdjustSupply.sol#477-815)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 306,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let n := calldataload(notes)\n\n            let inputOwners := add(0x124, calldataload(0x164)) // one word after input owners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x184)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1a4)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput A` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutputA`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes A` starts at 0x2a0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // `proofOutput B` - r\n\n            // 0x00 - 0x20 = length of `proofOutput B`\n\n            // 0x20 - 0x40 = relative offset between `r` and `inputNotes`\n\n            // 0x40 - 0x60 = relative offset between `r` and `outputNotes`\n\n            // 0x60 - 0x80 = `publicOwner`\n\n            // 0x80 - 0xa0 = `publicValue`\n\n            // 0xa0 - 0xc0 = `challenge`\n\n\n\n            // 'inputNotes B'\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x02)                            // there are two proofOutput objects for an adjustSupply\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n            // 0x1e0 = offset to 2nd proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n            mstore(0x260, 0x00)                            // publicOwner is 0\n\n            mstore(0x280, 0x00)                            // publicValue is 0\n\n\n\n            mstore(0x2a0, calldataload(0x124))\n\n\n\n            // set note pointer, offsetting lookup indices for each input note\n\n\n\n            /////////////////// PROOF OUTPUT A: START OF INPUT NOTES //////////////////\n\n            // 0x2c0 = number of bytes in `inputNotes` (leave blank for now)\n\n            // 0x2e0 = number of input notes\n\n            mstore(0x2e0, 0x01)\n\n\n\n            // 0x300 = relative offset to 1st input note (0x60)\n\n            mstore(0x300, 0x60)\n\n\n\n            // Start of inputNote[0]\n\n            // get pointer to metadata\n\n            let metadataIndex := calldataload(metadata)\n\n            // get size of metadata\n\n            let metadataLength := calldataload(add(metadataIndex, sub(metadata, 0x40)))\n\n\n\n            // copy note data to 0x20 - 0xa0\n\n            mstore(0x00, 0x01)\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s` = 0x320\n\n            mstore(0x320, add(0xc0, metadataLength))\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x340, 0x01)\n\n            // store the owner of the note in `s + 0x40`\n\n            mstore(0x360, calldataload(outputOwners))\n\n            // store note hash\n\n            mstore(0x380, keccak256(0x00, 0xa0))\n\n            // store note metadata length if `s + 0x80`\n\n            mstore(0x3a0, add(0x40, metadataLength))\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // copy metadata into `s + 0xe0`\n\n            calldatacopy(0x400, add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n            // compute the relative offset to index this note in our returndata\n\n\n\n            // increase s by note length\n\n\n\n            // store relative memory offset to outputNotes\n\n            mstore(0x240, add(0x200, metadataLength))\n\n            // store the length of inputNotes at 0x2c0\n\n            mstore(0x2c0, add(0x120, metadataLength))\n\n            ///////////////// PROOF OUTPUT A: START OF OUTPUT NOTES (1) ///////////////////\n\n\n\n            // transition between input and output notes\n\n            \n\n            // 0x400 + metadataLength = byte length of output notes (0x120)\n\n            // 0x420 + metadataLength = # of output notes (1)\n\n            // 0x440 + metadataLength = offset to outputNotes[0] (0x60)\n\n            mstore(add(0x400, metadataLength), 0x120) // store length of output notes\n\n            mstore(add(0x420, metadataLength), 0x01) // store number of output notes\n\n            mstore(add(0x440, metadataLength), 0x60) // store offset to outputNotes[0]\n\n        \n\n            // construct note hash\n\n            // copy 1st note note to 0x20 - 0xa0\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s`\n\n            mstore(add(0x460, metadataLength), 0xc0)\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(add(0x480, metadataLength), 0x01)\n\n            // store note owner in `s + 0x40`\n\n            mstore(add(0x4a0, metadataLength), calldataload(inputOwners))\n\n            // store note hash in `s + 0x60`\n\n            mstore(add(0x4c0, metadataLength), keccak256(0x00, 0xa0))\n\n            // store note metadata length in `s + 0x80` (just the coordinates)\n\n            mstore(add(0x4e0, metadataLength), 0x40)\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                add(0x500, metadataLength),\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                add(0x520, metadataLength),\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // compute the relative offset to index this note in our returndata\n\n            mstore(add(0x440, metadataLength), 0x60) // relative offset to note\n\n    \n\n            // now we need to transition between first and second proofOutput\n\n            // s is going to point to the end of the outputNotes array\n\n            // so, s is our absolute pointer to the start of the 2nd proofOutputs entry\n\n            // we know that 'proofOutputs' starts at 0x180\n\n            // so (s - 0x180) = relative offset to second proofOutputs entry\n\n            let startOfProofOutput := add(0x540, metadataLength)\n\n\n\n            // proofOutput[0].length = start of proofOutput[1] - start of proofOutput[0] - 0x20\n\n            // proofOutput[0].length = (0x540 + metadataLength) - 0x200 - 0x20 = 0x320 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength)) // length of proofOutput\n\n            mstore(0x1e0, add(0x3c0, metadataLength)) // offset to get to second proofOutput\n\n\n\n            // s points to the start of proofOutputs[0]\n\n            let s := startOfProofOutput\n\n            mstore(add(s, 0x20), 0xc0)   // location of inputNotes\n\n            mstore(add(s, 0x40), 0x100)  // location of outputNotes\n\n            mstore(add(s, 0x60), 0x00)   // publicOwner\n\n            mstore(add(s, 0x80), 0x00)   // publicValue\n\n\n\n            // compute challenge = kecck256(challenge)\n\n            mstore(0x20, calldataload(0x124))\n\n            mstore(add(s, 0xa0), keccak256(0x20, 0x20)) // challenge\n\n            // 0x00 length of proofOutput\n\n            // 0x20 location of inputNotes\n\n            // 0x40 location of outputNotes\n\n            // 0x60 publicOwner\n\n            // 0x80 publicValue\n\n            // 0xa0 = inputNoteData\n\n            mstore(add(s, 0xc0), 0x20) // length of input notes array (1 word)\n\n            mstore(add(s, 0xe0), 0x00) // number of entries (0 words)\n\n\n\n            // set notesPtr = proofOutputs[1].outputNotes\n\n            let notesPtr := add(s, 0x100)\n\n\n\n            // s + 0x20 = number of notes = n - 2\n\n            mstore(add(notesPtr, 0x20), sub(n, 2))\n\n\n\n            // set s to point to proofOutputs[1].outputNotes[0]\n\n            s := add(add(s, 0x140), mul(0x20, sub(n, 2)))\n\n\n\n            // Output notes:\n\n            // first output note needs to go into the first proofOutput object\n\n            // second output note onwards, needs to go into the second proofOutput object\n\n            for { let i := 0x02 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n            /////////////////// START OF PROOF OUTPUT B  ////////////////////\n\n\n\n                // get pointer to metadata\n\n                metadataIndex := calldataload(add(metadata, mul(sub(i, 0x01), 0x20)))\n\n                // get size of metadata\n\n                metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01)\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(\n\n                    0x20,\n\n                    add(add(notes, 0x60), mul(i, 0xc0)),\n\n                    0x80\n\n                ) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO type, 0x01) in `s + 0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, 0x01), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x80`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        shl(255, and(mload(0x40), 0x01))\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xc0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        mload(0x60),\n\n                        shl(255, and(mload(0x80), 0x01))\n\n                    )\n\n                )\n\n                // copy metadata into `s + 0xe0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(notesPtr, mul(i, 0x20)), sub(s, notesPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // inputPtr used to point to start of inputNotes for proofOutputs[0]\n\n            // now we want inputPtr to point to start of inputNotes for proofOutputs[1]\n\n            // 1. length of proofOutput\n\n            // 2. length of outputNotes\n\n            // length of outputNotes = s - inputPtr, stored at inputPtr\n\n            mstore(notesPtr, sub(sub(s, notesPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            // length of proofOutput\n\n            let proofOutputLength := sub(s, startOfProofOutput)\n\n            mstore(startOfProofOutput, sub(proofOutputLength, 0x20))\n\n            mstore(0x180, sub(s, 0x1a0)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, sub(s, 0x160)) // return the final byte array\n\n        }\n",
                    "message": "AdjustSupplyABIEncoder.encodeAndExit uses assembly (AdjustSupply.sol#25-306)\n\t- AdjustSupply.sol#26-305\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 380,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message uses assembly (AdjustSupply.sol#354-380)\n\t- AdjustSupply.sol#368-379\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": 427,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature uses assembly (AdjustSupply.sol#386-427)\n\t- AdjustSupply.sol#391-421\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 815,
                    "vulnerability_code": "    function() external payable {\n\n        assembly {\n\n            // We don't check for function signatures,\n\n            // there's only one function that ever gets called: validateAdjustSupply()\n\n            // We still assume calldata is offset by 4 bytes so that we can represent this contract\n\n            // through a compatible ABI\n\n            validateAdjustSupply()\n\n\n\n            /**\n\n             * New calldata map\n\n             * 0x04:0x24      = calldata location of proofData byte array\n\n             * 0x24:0x44      = message sender\n\n             * 0x44:0x64      = h_x\n\n             * 0x64:0x84      = h_y\n\n             * 0x84:0xa4      = t2_x0\n\n             * 0xa4:0xc4      = t2_x1\n\n             * 0xc4:0xe4      = t2_y0\n\n             * 0xe4:0x104     = t2_y1\n\n             * 0x104:0x124    = length of proofData byte array\n\n             * 0x124:0x144    = challenge\n\n             * 0x144:0x164    = offset in byte array to notes\n\n             * 0x164:0x184    = offset in byte array to inputOwners\n\n             * 0x184:0x1a4    = offset in byte array to outputOwners\n\n             * 0x1a4:0x1c4    = offset in byte array to metadata\n\n             */\n\n            function validateAdjustSupply() {\n\n                mstore(0x80, calldataload(0x44))\n\n                mstore(0xa0, calldataload(0x64))\n\n                let notes := add(0x104, calldataload(0x144)) // get the length of notes\n\n                let m := 1\n\n                let n := calldataload(notes)\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let challenge := mod(calldataload(0x124), gen_order)\n\n\n\n\n\n                // validate m < n\n\n                if gt(m, n) { \n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                if eq(m, n) { \n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n                \n\n                let kn := 0\n\n\n\n                // add sender final hash table\n\n                mstore(0x2a0, calldataload(0x24))\n\n                mstore(0x2c0, 0) // add kPublic = 0 to hash table\n\n                mstore(0x2e0, m) // add m to final hash table\n\n\n\n                hashCommitments(notes, n)  // notes = length of proof data array, n = number of notes\n\n                let b := add(0x300, mul(n, 0x80))\n\n\n\n\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1,\n\n                //  which adds some minor alterations\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n                // Get the calldata index of this note\n\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n\n\n                // Define variables k, a and c.\n\n                // If i <= m then\n\n                //   k = kBar_i\n\n                //   a = aBar_i\n\n                //   c = challenge\n\n                // If i > m then we add a modification for the pairing optimization\n\n                //   k = kBar_i * x_i\n\n                //   a = aBar_i * x_i\n\n                //   c = challenge * x_i\n\n                // Set j = i - (m + 1).\n\n                // x_0 = 1\n\n                // x_1 = keccak256(input string)\n\n                // all other x_{j} = keccak256(x_{j-1})\n\n                // The reason for doing this is that the point  \\sigma_i^{-cx_j} can be re-used in the pairing check\n\n                // Instead of validating e(\\gamma_i, t_2) == e(\\sigma_i, g_2) for all i = [m+1,\\ldots,n]\n\n                // We validate e(\\Pi_{i=m+1}^{n}\\gamma_i^{-cx_j}, t_2) == e(\\Pi_{i=m+1}^{n}\\sigma_i^{cx_j}, g_2).\n\n                // x_j is a pseudorandom variable whose entropy source is the input string, allowing for\n\n                // a sum of commitment points to be evaluated in one pairing comparison\n\n                let k\n\n                let a := calldataload(add(noteIndex, 0x20))\n\n                let c := challenge\n\n                \n\n                switch eq(add(i, 0x01), n)\n\n                    case 1 {\n\n                        k := kn\n\n                    }\n\n                    case 0 { k := calldataload(noteIndex) }\n\n\n\n\n\n                // Check this commitment is well formed...\n\n                validateCommitment(noteIndex, k, a)\n\n\n\n\n\n                // If i > m then this is an output note.\n\n                // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\n\n                switch gt(add(i, 0x01), m)\n\n                case 1 {\n\n                    // before we update k, update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n\n                    kn := addmod(kn, sub(gen_order, k), gen_order)\n\n                    let x := mod(mload(0x00), gen_order)\n\n                    k := mulmod(k, x, gen_order)\n\n                    a := mulmod(a, x, gen_order)\n\n                    c := mulmod(challenge, x, gen_order)\n\n\n\n                    // calculate x_{j+1}\n\n                    mstore(0x00, keccak256(0x00, 0x20))\n\n                }\n\n\n\n                case 0 {\n\n\n\n                    // nothing to do here except update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n\n                    kn := addmod(kn, k, gen_order)\n\n                }\n\n\n\n                // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\n\n                // Memory map:\n\n                // 0x20: \\gamma_iX\n\n                // 0x40: \\gamma_iY\n\n                // 0x60: k_i\n\n                // 0x80: hX\n\n                // 0xa0: hY\n\n                // 0xc0: a_i\n\n                // 0xe0: \\sigma_iX\n\n                // 0x100: \\sigma_iY\n\n                // 0x120: -c\n\n                calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n\n                mstore(0x120, sub(gen_order, c)) \n\n                mstore(0x60, k)\n\n                mstore(0xc0, a)\n\n\n\n                // Call bn128 scalar multiplication precompiles\n\n                // Represent point + multiplication scalar in 3 consecutive blocks of memory\n\n                // Store \\sigma_i^{-c} at 0x1a0:0x200\n\n                // Store \\gamma_i^{k} at 0x120:0x160\n\n                // Store h^{a} at 0x160:0x1a0\n\n                let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40)\n\n                result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\n\n                result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\n\n\n\n                // Call bn128 group addition precompiles\n\n                // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n\n                // Store result of addition at 0x160:0x1a0\n\n                result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n\n\n                // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n\n                // Store resulting point B at memory index b\n\n                result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n\n\n                // We have \\sigma^{-c} at 0x1a0:0x200\n\n                // And \\sigma_{acc} at 0x1e0:0x200\n\n                // If i = m + 1 (i.e. first output note)\n\n                // then we set \\gamma_{acc} and \\sigma_{acc} to \\gamma_i, -\\sigma_i\n\n                if eq(i, m) {\n\n                    mstore(0x260, mload(0x20))\n\n                    mstore(0x280, mload(0x40))\n\n                    mstore(0x1e0, mload(0xe0))\n\n                    mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n\n                }\n\n\n\n                // If i > m + 1 (i.e. subsequent output notes)\n\n                // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\n\n                // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\n\n                if gt(i, m) {\n\n                    mstore(0x60, c)\n\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\n\n\n\n                    // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\n\n                    result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\n\n\n\n                    // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\n\n                    result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40))\n\n                }\n\n\n\n\n\n                // throw transaction if any calls to precompiled contracts failed\n\n                if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n\n                    b := add(b, 0x40) // increase B pointer by 2 words\n\n                }\n\n\n\n                // If the AZTEC protocol is implemented correctly then any input notes were previously outputs of\n\n                // a AdjustSupply transaction. We can inductively assume that all input notes\n\n                // are well-formed AZTEC commitments and do not need to validate the implicit range proof\n\n                // This is not the case for any output commitments, so if (m < n) call validatePairing()\n\n                if lt(m, n) {\n\n                    validatePairing(0x84)\n\n                }\n\n\n\n\n\n                // We now have the note commitments and the calculated blinding factors in a block of memory\n\n                // starting at 0x2a0, of size (b - 0x2a0).\n\n                // Hash this block to reconstruct the initial challenge and validate that they match\n\n\n\n                let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n\n\n\n                if iszero(eq(expected, challenge)) {\n\n\n\n                    // No! Bad! No soup for you!\n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // Great! All done. This is a valid proof, so fall through out of the assembly block\n\n                // so that we can call `ABIEncoder.encodeAndExit`\n\n\n\n            }\n\n\n\n\n\n            /**        \n\n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\n\n             * @notice we don't hard-code t2 so that contracts that call this library can use\n\n             * different trusted setups.\n\n             **/\n\n            function validatePairing(t2) {\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let t2_x_1 := calldataload(t2)\n\n                let t2_x_2 := calldataload(add(t2, 0x20))\n\n                let t2_y_1 := calldataload(add(t2, 0x40))\n\n                let t2_y_2 := calldataload(add(t2, 0x60))\n\n\n\n                // check provided setup pubkey is not zero or g2\n\n                if or(or(or(or(or(or(or(\n\n                    iszero(t2_x_1),\n\n                    iszero(t2_x_2)),\n\n                    iszero(t2_y_1)),\n\n                    iszero(t2_y_2)),\n\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\n\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\n\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\n\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n\n                {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n                // store coords in memory\n\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\n\n                // to what precompile expects\n\n                // We can overwrite the memory we used previously as this function is called at the\n\n                // end of the validation routine.\n\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\n\n                mstore(0x40, mload(0x200)) // sigma accumulator y\n\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\n\n                mstore(0x100, mload(0x280)) // gamma accumulator y\n\n                mstore(0x140, t2_x_1)\n\n                mstore(0x120, t2_x_2)\n\n                mstore(0x180, t2_y_1)\n\n                mstore(0x160, t2_y_2)\n\n\n\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\n\n\n\n                if or(iszero(success), iszero(mload(0x20))) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n\n\n            }\n\n\n\n            /**\n\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n\n             * and that signatures 'k' and 'a' are modulo the order of the curve.\n\n             * Transaction will throw if this is not the case.\n\n             * @param note the calldata loation of the note\n\n             **/\n\n            function validateCommitment(note, k, a) {\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let gammaX := calldataload(add(note, 0x40))\n\n                let gammaY := calldataload(add(note, 0x60))\n\n                let sigmaX := calldataload(add(note, 0x80))\n\n                let sigmaY := calldataload(add(note, 0xa0))\n\n                if iszero(\n\n                    and(\n\n                        and(\n\n                        and(\n\n                            eq(mod(a, gen_order), a), // a is modulo generator order?\n\n                            gt(a, 1)                  // can't be 0 or 1 either!\n\n                        ),\n\n                        and(\n\n                            eq(mod(k, gen_order), k), // k is modulo generator order?\n\n                            gt(k, 1)                  // and not 0 or 1\n\n                        )\n\n                        ),\n\n                        and(\n\n                        eq( // y^2 ?= x^3 + 3\n\n                            addmod(\n\n                                mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order),\n\n                                3,\n\n                                field_order\n\n                            ),\n\n                            mulmod(sigmaY, sigmaY, field_order)\n\n                        ),\n\n                        eq( // y^2 ?= x^3 + 3\n\n                            addmod(\n\n                                mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order),\n\n                                3,\n\n                                field_order\n\n                            ),\n\n                            mulmod(gammaY, gammaY, field_order)\n\n                        )\n\n                        )\n\n                    )\n\n                ) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**\n\n             * @dev Calculate the keccak256 hash of the commitments for both input notes and output notes.\n\n             * This is used both as an input to validate the challenge `c` and also to\n\n             * generate pseudorandom relationships\n\n             * between commitments for different outputNotes, so that we can combine them\n\n             * into a single multi-exponentiation for the purposes of validating the bilinear pairing relationships.\n\n             * @param notes calldata location notes\n\n             * @param n number of notes\n\n             **/\n\n            function hashCommitments(notes, n) {\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n                let index := add(add(notes, mul(i, 0xc0)), 0x60)\n\n                calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n\n                }\n\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n\n            }\n\n        }\n\n\n\n        // if we've reached here, we've validated the join split transaction and haven't thrown an error.\n\n        // Encode the output according to the ACE standard and exit.\n\n        AdjustSupplyABIEncoder.encodeAndExit();\n",
                    "message": "AdjustSupply.fallback uses assembly (AdjustSupply.sol#477-815)\n\t- AdjustSupply.sol#478-810\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in AdjustSupply.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (AdjustSupply.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (AdjustSupply.sol#311): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (AdjustSupply.sol#432): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (AdjustSupply.sol#452): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (AdjustSupply.sol#338) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata, // proof data\n",
                    "message": "Parameter '' of AdjustSupplyInterface.validateAdjustSupply (AdjustSupply.sol#440) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address, // sender address\n",
                    "message": "Parameter '_scope_0' of AdjustSupplyInterface.validateAdjustSupply (AdjustSupply.sol#441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6] calldata // common reference string\n",
                    "message": "Parameter '_scope_1' of AdjustSupplyInterface.validateAdjustSupply (AdjustSupply.sol#442) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validateAdjustSupply(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract AdjustSupply is LibEIP712 {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/ACE/validators/adjustSupply/AdjustSupplyABIEncoder.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 306,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let n := calldataload(notes)\n\n            let inputOwners := add(0x124, calldataload(0x164)) // one word after input owners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x184)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1a4)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput A` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutputA`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes A` starts at 0x2a0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // `proofOutput B` - r\n\n            // 0x00 - 0x20 = length of `proofOutput B`\n\n            // 0x20 - 0x40 = relative offset between `r` and `inputNotes`\n\n            // 0x40 - 0x60 = relative offset between `r` and `outputNotes`\n\n            // 0x60 - 0x80 = `publicOwner`\n\n            // 0x80 - 0xa0 = `publicValue`\n\n            // 0xa0 - 0xc0 = `challenge`\n\n\n\n            // 'inputNotes B'\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x02)                            // there are two proofOutput objects for an adjustSupply\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n            // 0x1e0 = offset to 2nd proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n            mstore(0x260, 0x00)                            // publicOwner is 0\n\n            mstore(0x280, 0x00)                            // publicValue is 0\n\n\n\n            mstore(0x2a0, calldataload(0x124))\n\n\n\n            // set note pointer, offsetting lookup indices for each input note\n\n\n\n            /////////////////// PROOF OUTPUT A: START OF INPUT NOTES //////////////////\n\n            // 0x2c0 = number of bytes in `inputNotes` (leave blank for now)\n\n            // 0x2e0 = number of input notes\n\n            mstore(0x2e0, 0x01)\n\n\n\n            // 0x300 = relative offset to 1st input note (0x60)\n\n            mstore(0x300, 0x60)\n\n\n\n            // Start of inputNote[0]\n\n            // get pointer to metadata\n\n            let metadataIndex := calldataload(metadata)\n\n            // get size of metadata\n\n            let metadataLength := calldataload(add(metadataIndex, sub(metadata, 0x40)))\n\n\n\n            // copy note data to 0x20 - 0xa0\n\n            mstore(0x00, 0x01)\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s` = 0x320\n\n            mstore(0x320, add(0xc0, metadataLength))\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x340, 0x01)\n\n            // store the owner of the note in `s + 0x40`\n\n            mstore(0x360, calldataload(outputOwners))\n\n            // store note hash\n\n            mstore(0x380, keccak256(0x00, 0xa0))\n\n            // store note metadata length if `s + 0x80`\n\n            mstore(0x3a0, add(0x40, metadataLength))\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // copy metadata into `s + 0xe0`\n\n            calldatacopy(0x400, add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n            // compute the relative offset to index this note in our returndata\n\n\n\n            // increase s by note length\n\n\n\n            // store relative memory offset to outputNotes\n\n            mstore(0x240, add(0x200, metadataLength))\n\n            // store the length of inputNotes at 0x2c0\n\n            mstore(0x2c0, add(0x120, metadataLength))\n\n            ///////////////// PROOF OUTPUT A: START OF OUTPUT NOTES (1) ///////////////////\n\n\n\n            // transition between input and output notes\n\n            \n\n            // 0x400 + metadataLength = byte length of output notes (0x120)\n\n            // 0x420 + metadataLength = # of output notes (1)\n\n            // 0x440 + metadataLength = offset to outputNotes[0] (0x60)\n\n            mstore(add(0x400, metadataLength), 0x120) // store length of output notes\n\n            mstore(add(0x420, metadataLength), 0x01) // store number of output notes\n\n            mstore(add(0x440, metadataLength), 0x60) // store offset to outputNotes[0]\n\n        \n\n            // construct note hash\n\n            // copy 1st note note to 0x20 - 0xa0\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s`\n\n            mstore(add(0x460, metadataLength), 0xc0)\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(add(0x480, metadataLength), 0x01)\n\n            // store note owner in `s + 0x40`\n\n            mstore(add(0x4a0, metadataLength), calldataload(inputOwners))\n\n            // store note hash in `s + 0x60`\n\n            mstore(add(0x4c0, metadataLength), keccak256(0x00, 0xa0))\n\n            // store note metadata length in `s + 0x80` (just the coordinates)\n\n            mstore(add(0x4e0, metadataLength), 0x40)\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                add(0x500, metadataLength),\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                add(0x520, metadataLength),\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // compute the relative offset to index this note in our returndata\n\n            mstore(add(0x440, metadataLength), 0x60) // relative offset to note\n\n    \n\n            // now we need to transition between first and second proofOutput\n\n            // s is going to point to the end of the outputNotes array\n\n            // so, s is our absolute pointer to the start of the 2nd proofOutputs entry\n\n            // we know that 'proofOutputs' starts at 0x180\n\n            // so (s - 0x180) = relative offset to second proofOutputs entry\n\n            let startOfProofOutput := add(0x540, metadataLength)\n\n\n\n            // proofOutput[0].length = start of proofOutput[1] - start of proofOutput[0] - 0x20\n\n            // proofOutput[0].length = (0x540 + metadataLength) - 0x200 - 0x20 = 0x320 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength)) // length of proofOutput\n\n            mstore(0x1e0, add(0x3c0, metadataLength)) // offset to get to second proofOutput\n\n\n\n            // s points to the start of proofOutputs[0]\n\n            let s := startOfProofOutput\n\n            mstore(add(s, 0x20), 0xc0)   // location of inputNotes\n\n            mstore(add(s, 0x40), 0x100)  // location of outputNotes\n\n            mstore(add(s, 0x60), 0x00)   // publicOwner\n\n            mstore(add(s, 0x80), 0x00)   // publicValue\n\n\n\n            // compute challenge = kecck256(challenge)\n\n            mstore(0x20, calldataload(0x124))\n\n            mstore(add(s, 0xa0), keccak256(0x20, 0x20)) // challenge\n\n            // 0x00 length of proofOutput\n\n            // 0x20 location of inputNotes\n\n            // 0x40 location of outputNotes\n\n            // 0x60 publicOwner\n\n            // 0x80 publicValue\n\n            // 0xa0 = inputNoteData\n\n            mstore(add(s, 0xc0), 0x20) // length of input notes array (1 word)\n\n            mstore(add(s, 0xe0), 0x00) // number of entries (0 words)\n\n\n\n            // set notesPtr = proofOutputs[1].outputNotes\n\n            let notesPtr := add(s, 0x100)\n\n\n\n            // s + 0x20 = number of notes = n - 2\n\n            mstore(add(notesPtr, 0x20), sub(n, 2))\n\n\n\n            // set s to point to proofOutputs[1].outputNotes[0]\n\n            s := add(add(s, 0x140), mul(0x20, sub(n, 2)))\n\n\n\n            // Output notes:\n\n            // first output note needs to go into the first proofOutput object\n\n            // second output note onwards, needs to go into the second proofOutput object\n\n            for { let i := 0x02 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n            /////////////////// START OF PROOF OUTPUT B  ////////////////////\n\n\n\n                // get pointer to metadata\n\n                metadataIndex := calldataload(add(metadata, mul(sub(i, 0x01), 0x20)))\n\n                // get size of metadata\n\n                metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01)\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(\n\n                    0x20,\n\n                    add(add(notes, 0x60), mul(i, 0xc0)),\n\n                    0x80\n\n                ) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO type, 0x01) in `s + 0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, 0x01), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x80`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        shl(255, and(mload(0x40), 0x01))\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xc0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        mload(0x60),\n\n                        shl(255, and(mload(0x80), 0x01))\n\n                    )\n\n                )\n\n                // copy metadata into `s + 0xe0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(notesPtr, mul(i, 0x20)), sub(s, notesPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // inputPtr used to point to start of inputNotes for proofOutputs[0]\n\n            // now we want inputPtr to point to start of inputNotes for proofOutputs[1]\n\n            // 1. length of proofOutput\n\n            // 2. length of outputNotes\n\n            // length of outputNotes = s - inputPtr, stored at inputPtr\n\n            mstore(notesPtr, sub(sub(s, notesPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            // length of proofOutput\n\n            let proofOutputLength := sub(s, startOfProofOutput)\n\n            mstore(startOfProofOutput, sub(proofOutputLength, 0x20))\n\n            mstore(0x180, sub(s, 0x1a0)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, sub(s, 0x160)) // return the final byte array\n\n        }\n",
                    "message": "AdjustSupplyABIEncoder.encodeAndExit (AdjustSupplyABIEncoder.sol#25-306) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 306,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let n := calldataload(notes)\n\n            let inputOwners := add(0x124, calldataload(0x164)) // one word after input owners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x184)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1a4)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput A` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutputA`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes A` starts at 0x2a0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // `proofOutput B` - r\n\n            // 0x00 - 0x20 = length of `proofOutput B`\n\n            // 0x20 - 0x40 = relative offset between `r` and `inputNotes`\n\n            // 0x40 - 0x60 = relative offset between `r` and `outputNotes`\n\n            // 0x60 - 0x80 = `publicOwner`\n\n            // 0x80 - 0xa0 = `publicValue`\n\n            // 0xa0 - 0xc0 = `challenge`\n\n\n\n            // 'inputNotes B'\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x02)                            // there are two proofOutput objects for an adjustSupply\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n            // 0x1e0 = offset to 2nd proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n            mstore(0x260, 0x00)                            // publicOwner is 0\n\n            mstore(0x280, 0x00)                            // publicValue is 0\n\n\n\n            mstore(0x2a0, calldataload(0x124))\n\n\n\n            // set note pointer, offsetting lookup indices for each input note\n\n\n\n            /////////////////// PROOF OUTPUT A: START OF INPUT NOTES //////////////////\n\n            // 0x2c0 = number of bytes in `inputNotes` (leave blank for now)\n\n            // 0x2e0 = number of input notes\n\n            mstore(0x2e0, 0x01)\n\n\n\n            // 0x300 = relative offset to 1st input note (0x60)\n\n            mstore(0x300, 0x60)\n\n\n\n            // Start of inputNote[0]\n\n            // get pointer to metadata\n\n            let metadataIndex := calldataload(metadata)\n\n            // get size of metadata\n\n            let metadataLength := calldataload(add(metadataIndex, sub(metadata, 0x40)))\n\n\n\n            // copy note data to 0x20 - 0xa0\n\n            mstore(0x00, 0x01)\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s` = 0x320\n\n            mstore(0x320, add(0xc0, metadataLength))\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x340, 0x01)\n\n            // store the owner of the note in `s + 0x40`\n\n            mstore(0x360, calldataload(outputOwners))\n\n            // store note hash\n\n            mstore(0x380, keccak256(0x00, 0xa0))\n\n            // store note metadata length if `s + 0x80`\n\n            mstore(0x3a0, add(0x40, metadataLength))\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // copy metadata into `s + 0xe0`\n\n            calldatacopy(0x400, add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n            // compute the relative offset to index this note in our returndata\n\n\n\n            // increase s by note length\n\n\n\n            // store relative memory offset to outputNotes\n\n            mstore(0x240, add(0x200, metadataLength))\n\n            // store the length of inputNotes at 0x2c0\n\n            mstore(0x2c0, add(0x120, metadataLength))\n\n            ///////////////// PROOF OUTPUT A: START OF OUTPUT NOTES (1) ///////////////////\n\n\n\n            // transition between input and output notes\n\n            \n\n            // 0x400 + metadataLength = byte length of output notes (0x120)\n\n            // 0x420 + metadataLength = # of output notes (1)\n\n            // 0x440 + metadataLength = offset to outputNotes[0] (0x60)\n\n            mstore(add(0x400, metadataLength), 0x120) // store length of output notes\n\n            mstore(add(0x420, metadataLength), 0x01) // store number of output notes\n\n            mstore(add(0x440, metadataLength), 0x60) // store offset to outputNotes[0]\n\n        \n\n            // construct note hash\n\n            // copy 1st note note to 0x20 - 0xa0\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s`\n\n            mstore(add(0x460, metadataLength), 0xc0)\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(add(0x480, metadataLength), 0x01)\n\n            // store note owner in `s + 0x40`\n\n            mstore(add(0x4a0, metadataLength), calldataload(inputOwners))\n\n            // store note hash in `s + 0x60`\n\n            mstore(add(0x4c0, metadataLength), keccak256(0x00, 0xa0))\n\n            // store note metadata length in `s + 0x80` (just the coordinates)\n\n            mstore(add(0x4e0, metadataLength), 0x40)\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                add(0x500, metadataLength),\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                add(0x520, metadataLength),\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // compute the relative offset to index this note in our returndata\n\n            mstore(add(0x440, metadataLength), 0x60) // relative offset to note\n\n    \n\n            // now we need to transition between first and second proofOutput\n\n            // s is going to point to the end of the outputNotes array\n\n            // so, s is our absolute pointer to the start of the 2nd proofOutputs entry\n\n            // we know that 'proofOutputs' starts at 0x180\n\n            // so (s - 0x180) = relative offset to second proofOutputs entry\n\n            let startOfProofOutput := add(0x540, metadataLength)\n\n\n\n            // proofOutput[0].length = start of proofOutput[1] - start of proofOutput[0] - 0x20\n\n            // proofOutput[0].length = (0x540 + metadataLength) - 0x200 - 0x20 = 0x320 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength)) // length of proofOutput\n\n            mstore(0x1e0, add(0x3c0, metadataLength)) // offset to get to second proofOutput\n\n\n\n            // s points to the start of proofOutputs[0]\n\n            let s := startOfProofOutput\n\n            mstore(add(s, 0x20), 0xc0)   // location of inputNotes\n\n            mstore(add(s, 0x40), 0x100)  // location of outputNotes\n\n            mstore(add(s, 0x60), 0x00)   // publicOwner\n\n            mstore(add(s, 0x80), 0x00)   // publicValue\n\n\n\n            // compute challenge = kecck256(challenge)\n\n            mstore(0x20, calldataload(0x124))\n\n            mstore(add(s, 0xa0), keccak256(0x20, 0x20)) // challenge\n\n            // 0x00 length of proofOutput\n\n            // 0x20 location of inputNotes\n\n            // 0x40 location of outputNotes\n\n            // 0x60 publicOwner\n\n            // 0x80 publicValue\n\n            // 0xa0 = inputNoteData\n\n            mstore(add(s, 0xc0), 0x20) // length of input notes array (1 word)\n\n            mstore(add(s, 0xe0), 0x00) // number of entries (0 words)\n\n\n\n            // set notesPtr = proofOutputs[1].outputNotes\n\n            let notesPtr := add(s, 0x100)\n\n\n\n            // s + 0x20 = number of notes = n - 2\n\n            mstore(add(notesPtr, 0x20), sub(n, 2))\n\n\n\n            // set s to point to proofOutputs[1].outputNotes[0]\n\n            s := add(add(s, 0x140), mul(0x20, sub(n, 2)))\n\n\n\n            // Output notes:\n\n            // first output note needs to go into the first proofOutput object\n\n            // second output note onwards, needs to go into the second proofOutput object\n\n            for { let i := 0x02 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n            /////////////////// START OF PROOF OUTPUT B  ////////////////////\n\n\n\n                // get pointer to metadata\n\n                metadataIndex := calldataload(add(metadata, mul(sub(i, 0x01), 0x20)))\n\n                // get size of metadata\n\n                metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01)\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(\n\n                    0x20,\n\n                    add(add(notes, 0x60), mul(i, 0xc0)),\n\n                    0x80\n\n                ) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO type, 0x01) in `s + 0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, 0x01), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x80`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        shl(255, and(mload(0x40), 0x01))\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xc0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        mload(0x60),\n\n                        shl(255, and(mload(0x80), 0x01))\n\n                    )\n\n                )\n\n                // copy metadata into `s + 0xe0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(notesPtr, mul(i, 0x20)), sub(s, notesPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // inputPtr used to point to start of inputNotes for proofOutputs[0]\n\n            // now we want inputPtr to point to start of inputNotes for proofOutputs[1]\n\n            // 1. length of proofOutput\n\n            // 2. length of outputNotes\n\n            // length of outputNotes = s - inputPtr, stored at inputPtr\n\n            mstore(notesPtr, sub(sub(s, notesPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            // length of proofOutput\n\n            let proofOutputLength := sub(s, startOfProofOutput)\n\n            mstore(startOfProofOutput, sub(proofOutputLength, 0x20))\n\n            mstore(0x180, sub(s, 0x1a0)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, sub(s, 0x160)) // return the final byte array\n\n        }\n",
                    "message": "AdjustSupplyABIEncoder.encodeAndExit uses assembly (AdjustSupplyABIEncoder.sol#25-306)\n\t- AdjustSupplyABIEncoder.sol#26-305\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in AdjustSupplyABIEncoder.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (AdjustSupplyABIEncoder.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/ACE/validators/adjustSupply/AdjustSupplyABIEncoderTest.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 306,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let n := calldataload(notes)\n\n            let inputOwners := add(0x124, calldataload(0x164)) // one word after input owners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x184)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1a4)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput A` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutputA`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes A` starts at 0x2a0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // `proofOutput B` - r\n\n            // 0x00 - 0x20 = length of `proofOutput B`\n\n            // 0x20 - 0x40 = relative offset between `r` and `inputNotes`\n\n            // 0x40 - 0x60 = relative offset between `r` and `outputNotes`\n\n            // 0x60 - 0x80 = `publicOwner`\n\n            // 0x80 - 0xa0 = `publicValue`\n\n            // 0xa0 - 0xc0 = `challenge`\n\n\n\n            // 'inputNotes B'\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x02)                            // there are two proofOutput objects for an adjustSupply\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n            // 0x1e0 = offset to 2nd proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n            mstore(0x260, 0x00)                            // publicOwner is 0\n\n            mstore(0x280, 0x00)                            // publicValue is 0\n\n\n\n            mstore(0x2a0, calldataload(0x124))\n\n\n\n            // set note pointer, offsetting lookup indices for each input note\n\n\n\n            /////////////////// PROOF OUTPUT A: START OF INPUT NOTES //////////////////\n\n            // 0x2c0 = number of bytes in `inputNotes` (leave blank for now)\n\n            // 0x2e0 = number of input notes\n\n            mstore(0x2e0, 0x01)\n\n\n\n            // 0x300 = relative offset to 1st input note (0x60)\n\n            mstore(0x300, 0x60)\n\n\n\n            // Start of inputNote[0]\n\n            // get pointer to metadata\n\n            let metadataIndex := calldataload(metadata)\n\n            // get size of metadata\n\n            let metadataLength := calldataload(add(metadataIndex, sub(metadata, 0x40)))\n\n\n\n            // copy note data to 0x20 - 0xa0\n\n            mstore(0x00, 0x01)\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s` = 0x320\n\n            mstore(0x320, add(0xc0, metadataLength))\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x340, 0x01)\n\n            // store the owner of the note in `s + 0x40`\n\n            mstore(0x360, calldataload(outputOwners))\n\n            // store note hash\n\n            mstore(0x380, keccak256(0x00, 0xa0))\n\n            // store note metadata length if `s + 0x80`\n\n            mstore(0x3a0, add(0x40, metadataLength))\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // copy metadata into `s + 0xe0`\n\n            calldatacopy(0x400, add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n            // compute the relative offset to index this note in our returndata\n\n\n\n            // increase s by note length\n\n\n\n            // store relative memory offset to outputNotes\n\n            mstore(0x240, add(0x200, metadataLength))\n\n            // store the length of inputNotes at 0x2c0\n\n            mstore(0x2c0, add(0x120, metadataLength))\n\n            ///////////////// PROOF OUTPUT A: START OF OUTPUT NOTES (1) ///////////////////\n\n\n\n            // transition between input and output notes\n\n            \n\n            // 0x400 + metadataLength = byte length of output notes (0x120)\n\n            // 0x420 + metadataLength = # of output notes (1)\n\n            // 0x440 + metadataLength = offset to outputNotes[0] (0x60)\n\n            mstore(add(0x400, metadataLength), 0x120) // store length of output notes\n\n            mstore(add(0x420, metadataLength), 0x01) // store number of output notes\n\n            mstore(add(0x440, metadataLength), 0x60) // store offset to outputNotes[0]\n\n        \n\n            // construct note hash\n\n            // copy 1st note note to 0x20 - 0xa0\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s`\n\n            mstore(add(0x460, metadataLength), 0xc0)\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(add(0x480, metadataLength), 0x01)\n\n            // store note owner in `s + 0x40`\n\n            mstore(add(0x4a0, metadataLength), calldataload(inputOwners))\n\n            // store note hash in `s + 0x60`\n\n            mstore(add(0x4c0, metadataLength), keccak256(0x00, 0xa0))\n\n            // store note metadata length in `s + 0x80` (just the coordinates)\n\n            mstore(add(0x4e0, metadataLength), 0x40)\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                add(0x500, metadataLength),\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                add(0x520, metadataLength),\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // compute the relative offset to index this note in our returndata\n\n            mstore(add(0x440, metadataLength), 0x60) // relative offset to note\n\n    \n\n            // now we need to transition between first and second proofOutput\n\n            // s is going to point to the end of the outputNotes array\n\n            // so, s is our absolute pointer to the start of the 2nd proofOutputs entry\n\n            // we know that 'proofOutputs' starts at 0x180\n\n            // so (s - 0x180) = relative offset to second proofOutputs entry\n\n            let startOfProofOutput := add(0x540, metadataLength)\n\n\n\n            // proofOutput[0].length = start of proofOutput[1] - start of proofOutput[0] - 0x20\n\n            // proofOutput[0].length = (0x540 + metadataLength) - 0x200 - 0x20 = 0x320 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength)) // length of proofOutput\n\n            mstore(0x1e0, add(0x3c0, metadataLength)) // offset to get to second proofOutput\n\n\n\n            // s points to the start of proofOutputs[0]\n\n            let s := startOfProofOutput\n\n            mstore(add(s, 0x20), 0xc0)   // location of inputNotes\n\n            mstore(add(s, 0x40), 0x100)  // location of outputNotes\n\n            mstore(add(s, 0x60), 0x00)   // publicOwner\n\n            mstore(add(s, 0x80), 0x00)   // publicValue\n\n\n\n            // compute challenge = kecck256(challenge)\n\n            mstore(0x20, calldataload(0x124))\n\n            mstore(add(s, 0xa0), keccak256(0x20, 0x20)) // challenge\n\n            // 0x00 length of proofOutput\n\n            // 0x20 location of inputNotes\n\n            // 0x40 location of outputNotes\n\n            // 0x60 publicOwner\n\n            // 0x80 publicValue\n\n            // 0xa0 = inputNoteData\n\n            mstore(add(s, 0xc0), 0x20) // length of input notes array (1 word)\n\n            mstore(add(s, 0xe0), 0x00) // number of entries (0 words)\n\n\n\n            // set notesPtr = proofOutputs[1].outputNotes\n\n            let notesPtr := add(s, 0x100)\n\n\n\n            // s + 0x20 = number of notes = n - 2\n\n            mstore(add(notesPtr, 0x20), sub(n, 2))\n\n\n\n            // set s to point to proofOutputs[1].outputNotes[0]\n\n            s := add(add(s, 0x140), mul(0x20, sub(n, 2)))\n\n\n\n            // Output notes:\n\n            // first output note needs to go into the first proofOutput object\n\n            // second output note onwards, needs to go into the second proofOutput object\n\n            for { let i := 0x02 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n            /////////////////// START OF PROOF OUTPUT B  ////////////////////\n\n\n\n                // get pointer to metadata\n\n                metadataIndex := calldataload(add(metadata, mul(sub(i, 0x01), 0x20)))\n\n                // get size of metadata\n\n                metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01)\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(\n\n                    0x20,\n\n                    add(add(notes, 0x60), mul(i, 0xc0)),\n\n                    0x80\n\n                ) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO type, 0x01) in `s + 0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, 0x01), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x80`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        shl(255, and(mload(0x40), 0x01))\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xc0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        mload(0x60),\n\n                        shl(255, and(mload(0x80), 0x01))\n\n                    )\n\n                )\n\n                // copy metadata into `s + 0xe0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(notesPtr, mul(i, 0x20)), sub(s, notesPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // inputPtr used to point to start of inputNotes for proofOutputs[0]\n\n            // now we want inputPtr to point to start of inputNotes for proofOutputs[1]\n\n            // 1. length of proofOutput\n\n            // 2. length of outputNotes\n\n            // length of outputNotes = s - inputPtr, stored at inputPtr\n\n            mstore(notesPtr, sub(sub(s, notesPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            // length of proofOutput\n\n            let proofOutputLength := sub(s, startOfProofOutput)\n\n            mstore(startOfProofOutput, sub(proofOutputLength, 0x20))\n\n            mstore(0x180, sub(s, 0x1a0)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, sub(s, 0x160)) // return the final byte array\n\n        }\n",
                    "message": "AdjustSupplyABIEncoder.encodeAndExit (AdjustSupplyABIEncoderTest.sol#25-306) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 306,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let n := calldataload(notes)\n\n            let inputOwners := add(0x124, calldataload(0x164)) // one word after input owners = 1st\n\n            let outputOwners := add(0x124, calldataload(0x184)) // one word after outputOwners = 1st\n\n            let metadata := add(0x144, calldataload(0x1a4)) // two words after metadata = 1st\n\n\n\n            // memory map of `proofOutputs`\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutput`\n\n\n\n            // `proofOutput A` - t, starts at 0x1e0\n\n            // 0x1e0 - 0x200 = length of `proofOutputA`\n\n            // 0x200 - 0x220 = relative offset between `t` and `inputNotes`\n\n            // 0x220 - 0x240 = relative offset between `t` and `outputNotes`\n\n            // 0x240 - 0x260 = `publicOwner`\n\n            // 0x260 - 0x280 = `publicValue`\n\n            // 0x280 - 0x2a0 = `challenge`\n\n\n\n            // `inputNotes A` starts at 0x2a0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // `proofOutput B` - r\n\n            // 0x00 - 0x20 = length of `proofOutput B`\n\n            // 0x20 - 0x40 = relative offset between `r` and `inputNotes`\n\n            // 0x40 - 0x60 = relative offset between `r` and `outputNotes`\n\n            // 0x60 - 0x80 = `publicOwner`\n\n            // 0x80 - 0xa0 = `publicValue`\n\n            // 0xa0 - 0xc0 = `challenge`\n\n\n\n            // 'inputNotes B'\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes `i`\n\n            // the next `i` consecutive blocks of 0x20-sized memory contain relative offset between\n\n            // start of notes array and the location of the `note`\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `noteType`\n\n            // 0x40 - 0x60 = `owner`\n\n            // 0x60 - 0x80 = `noteHash`\n\n            // 0x80 - 0xa0 = size of note `data`\n\n            // 0xa0 - 0xc0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xc0 - 0xe0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xe0 - ???? = remaining note metadata\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at s\n\n            mstore(0x1a0, 0x02)                            // there are two proofOutput objects for an adjustSupply\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n            // 0x1e0 = offset to 2nd proof\n\n            // length of proofOutput is at s + 0x60\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n            mstore(0x260, 0x00)                            // publicOwner is 0\n\n            mstore(0x280, 0x00)                            // publicValue is 0\n\n\n\n            mstore(0x2a0, calldataload(0x124))\n\n\n\n            // set note pointer, offsetting lookup indices for each input note\n\n\n\n            /////////////////// PROOF OUTPUT A: START OF INPUT NOTES //////////////////\n\n            // 0x2c0 = number of bytes in `inputNotes` (leave blank for now)\n\n            // 0x2e0 = number of input notes\n\n            mstore(0x2e0, 0x01)\n\n\n\n            // 0x300 = relative offset to 1st input note (0x60)\n\n            mstore(0x300, 0x60)\n\n\n\n            // Start of inputNote[0]\n\n            // get pointer to metadata\n\n            let metadataIndex := calldataload(metadata)\n\n            // get size of metadata\n\n            let metadataLength := calldataload(add(metadataIndex, sub(metadata, 0x40)))\n\n\n\n            // copy note data to 0x20 - 0xa0\n\n            mstore(0x00, 0x01)\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s` = 0x320\n\n            mstore(0x320, add(0xc0, metadataLength))\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(0x340, 0x01)\n\n            // store the owner of the note in `s + 0x40`\n\n            mstore(0x360, calldataload(outputOwners))\n\n            // store note hash\n\n            mstore(0x380, keccak256(0x00, 0xa0))\n\n            // store note metadata length if `s + 0x80`\n\n            mstore(0x3a0, add(0x40, metadataLength))\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // copy metadata into `s + 0xe0`\n\n            calldatacopy(0x400, add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n            // compute the relative offset to index this note in our returndata\n\n\n\n            // increase s by note length\n\n\n\n            // store relative memory offset to outputNotes\n\n            mstore(0x240, add(0x200, metadataLength))\n\n            // store the length of inputNotes at 0x2c0\n\n            mstore(0x2c0, add(0x120, metadataLength))\n\n            ///////////////// PROOF OUTPUT A: START OF OUTPUT NOTES (1) ///////////////////\n\n\n\n            // transition between input and output notes\n\n            \n\n            // 0x400 + metadataLength = byte length of output notes (0x120)\n\n            // 0x420 + metadataLength = # of output notes (1)\n\n            // 0x440 + metadataLength = offset to outputNotes[0] (0x60)\n\n            mstore(add(0x400, metadataLength), 0x120) // store length of output notes\n\n            mstore(add(0x420, metadataLength), 0x01) // store number of output notes\n\n            mstore(add(0x440, metadataLength), 0x60) // store offset to outputNotes[0]\n\n        \n\n            // construct note hash\n\n            // copy 1st note note to 0x20 - 0xa0\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // get gamma, sigma\n\n\n\n            // store note length in `s`\n\n            mstore(add(0x460, metadataLength), 0xc0)\n\n            // store note type (UXTO type, 0x01) in `s + 0x20`\n\n            mstore(add(0x480, metadataLength), 0x01)\n\n            // store note owner in `s + 0x40`\n\n            mstore(add(0x4a0, metadataLength), calldataload(inputOwners))\n\n            // store note hash in `s + 0x60`\n\n            mstore(add(0x4c0, metadataLength), keccak256(0x00, 0xa0))\n\n            // store note metadata length in `s + 0x80` (just the coordinates)\n\n            mstore(add(0x4e0, metadataLength), 0x40)\n\n            // store compressed note coordinate gamma in `s + 0xa0`\n\n            mstore(\n\n                add(0x500, metadataLength),\n\n                or(\n\n                    mload(0x20),\n\n                    shl(255, and(mload(0x40), 0x01))\n\n                )\n\n            )\n\n            // store compressed note coordinate sigma in `s + 0xc0`\n\n            mstore(\n\n                add(0x520, metadataLength),\n\n                or(\n\n                    mload(0x60),\n\n                    shl(255, and(mload(0x80), 0x01))\n\n                )\n\n            )\n\n            // compute the relative offset to index this note in our returndata\n\n            mstore(add(0x440, metadataLength), 0x60) // relative offset to note\n\n    \n\n            // now we need to transition between first and second proofOutput\n\n            // s is going to point to the end of the outputNotes array\n\n            // so, s is our absolute pointer to the start of the 2nd proofOutputs entry\n\n            // we know that 'proofOutputs' starts at 0x180\n\n            // so (s - 0x180) = relative offset to second proofOutputs entry\n\n            let startOfProofOutput := add(0x540, metadataLength)\n\n\n\n            // proofOutput[0].length = start of proofOutput[1] - start of proofOutput[0] - 0x20\n\n            // proofOutput[0].length = (0x540 + metadataLength) - 0x200 - 0x20 = 0x320 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength)) // length of proofOutput\n\n            mstore(0x1e0, add(0x3c0, metadataLength)) // offset to get to second proofOutput\n\n\n\n            // s points to the start of proofOutputs[0]\n\n            let s := startOfProofOutput\n\n            mstore(add(s, 0x20), 0xc0)   // location of inputNotes\n\n            mstore(add(s, 0x40), 0x100)  // location of outputNotes\n\n            mstore(add(s, 0x60), 0x00)   // publicOwner\n\n            mstore(add(s, 0x80), 0x00)   // publicValue\n\n\n\n            // compute challenge = kecck256(challenge)\n\n            mstore(0x20, calldataload(0x124))\n\n            mstore(add(s, 0xa0), keccak256(0x20, 0x20)) // challenge\n\n            // 0x00 length of proofOutput\n\n            // 0x20 location of inputNotes\n\n            // 0x40 location of outputNotes\n\n            // 0x60 publicOwner\n\n            // 0x80 publicValue\n\n            // 0xa0 = inputNoteData\n\n            mstore(add(s, 0xc0), 0x20) // length of input notes array (1 word)\n\n            mstore(add(s, 0xe0), 0x00) // number of entries (0 words)\n\n\n\n            // set notesPtr = proofOutputs[1].outputNotes\n\n            let notesPtr := add(s, 0x100)\n\n\n\n            // s + 0x20 = number of notes = n - 2\n\n            mstore(add(notesPtr, 0x20), sub(n, 2))\n\n\n\n            // set s to point to proofOutputs[1].outputNotes[0]\n\n            s := add(add(s, 0x140), mul(0x20, sub(n, 2)))\n\n\n\n            // Output notes:\n\n            // first output note needs to go into the first proofOutput object\n\n            // second output note onwards, needs to go into the second proofOutput object\n\n            for { let i := 0x02 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n            /////////////////// START OF PROOF OUTPUT B  ////////////////////\n\n\n\n                // get pointer to metadata\n\n                metadataIndex := calldataload(add(metadata, mul(sub(i, 0x01), 0x20)))\n\n                // get size of metadata\n\n                metadataLength := calldataload(add(sub(metadata, 0x40), metadataIndex))\n\n\n\n                mstore(0x00, 0x01)\n\n                // copy note data to 0x20 - 0xa0\n\n                calldatacopy(\n\n                    0x20,\n\n                    add(add(notes, 0x60), mul(i, 0xc0)),\n\n                    0x80\n\n                ) // get gamma, sigma\n\n\n\n                // store note length in `s`\n\n                mstore(s, add(0xc0, metadataLength))\n\n                // store note type (UXTO type, 0x01) in `s + 0x20`\n\n                mstore(add(s, 0x20), 0x01)\n\n                // store the owner of the note in `s + 0x40`\n\n                mstore(add(s, 0x40), calldataload(add(outputOwners, mul(sub(i, 0x01), 0x20))))\n\n                // store note hash\n\n                mstore(add(s, 0x60), keccak256(0x00, 0xa0))\n\n                // store note metadata length if `s + 0x80`\n\n                mstore(add(s, 0x80), add(0x40, metadataLength))\n\n                // store compressed note coordinate gamma in `s + 0xa0`\n\n                mstore(\n\n                    add(s, 0xa0),\n\n                    or(\n\n                        mload(0x20),\n\n                        shl(255, and(mload(0x40), 0x01))\n\n                    )\n\n                )\n\n                // store compressed note coordinate sigma in `s + 0xc0`\n\n                mstore(\n\n                    add(s, 0xc0),\n\n                    or(\n\n                        mload(0x60),\n\n                        shl(255, and(mload(0x80), 0x01))\n\n                    )\n\n                )\n\n                // copy metadata into `s + 0xe0`\n\n                calldatacopy(add(s, 0xe0), add(metadataIndex, sub(metadata, 0x20)), metadataLength)\n\n                // compute the relative offset to index this note in our returndata\n\n                mstore(add(notesPtr, mul(i, 0x20)), sub(s, notesPtr)) // relative offset to note\n\n\n\n                // increase s by note length\n\n                s := add(s, add(mload(s), 0x20))\n\n            }\n\n\n\n            // inputPtr used to point to start of inputNotes for proofOutputs[0]\n\n            // now we want inputPtr to point to start of inputNotes for proofOutputs[1]\n\n            // 1. length of proofOutput\n\n            // 2. length of outputNotes\n\n            // length of outputNotes = s - inputPtr, stored at inputPtr\n\n            mstore(notesPtr, sub(sub(s, notesPtr), 0x20)) // store length of outputNotes at start of outputNotes\n\n            // length of proofOutput\n\n            let proofOutputLength := sub(s, startOfProofOutput)\n\n            mstore(startOfProofOutput, sub(proofOutputLength, 0x20))\n\n            mstore(0x180, sub(s, 0x1a0)) // store length of proofOutputs at 0x100\n\n            mstore(0x160, 0x20)\n\n            return(0x160, sub(s, 0x160)) // return the final byte array\n\n        }\n",
                    "message": "AdjustSupplyABIEncoder.encodeAndExit uses assembly (AdjustSupplyABIEncoderTest.sol#25-306)\n\t- AdjustSupplyABIEncoderTest.sol#26-305\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in AdjustSupplyABIEncoderTest.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (AdjustSupplyABIEncoderTest.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (AdjustSupplyABIEncoderTest.sol#311): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata, \n",
                    "message": "Parameter '' of AdjustSupplyABIEncoderTest.validateAdjustSupply (AdjustSupplyABIEncoderTest.sol#316) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address, \n",
                    "message": "Parameter '_scope_0' of AdjustSupplyABIEncoderTest.validateAdjustSupply (AdjustSupplyABIEncoderTest.sol#317) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6] calldata\n",
                    "message": "Parameter '_scope_1' of AdjustSupplyABIEncoderTest.validateAdjustSupply (AdjustSupplyABIEncoderTest.sol#318) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validateAdjustSupply(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/ACE/validators/bilateralSwap/BilateralSwap.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 604,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let noteOwners := add(0x124, calldataload(0x164)) // // one word after inputOwners = 1st\n\n            let metadataPtr := add(0x144, calldataload(0x184)) // two words after metadata = 1st\n\n\n\n            // First up, we need to do some checks to ensure we have been provided with correct data.\n\n            // We should only have 2 entries inside `bytes metadata` (only 2 output notes in total),\n\n            // and only 4 entries inside `noteOwners` (4 notes in bilateral swap proof)\n\n            if iszero(and(\n\n                eq(0x02, calldataload(sub(metadataPtr, 0x20))),\n\n                eq(0x04, calldataload(sub(noteOwners, 0x20)))\n\n            )) {\n\n                revert(0x00, 0x00) // no! bad! come back with good inputs!\n\n            }\n\n\n\n            // memory map of `proofOutputs`\n\n            // 0x00 - 0x160  = scratch data for note hash computation\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            // 0x1e0 - 0x200 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n    \n\n            // `proofOutput` - t, starts at 0x200\n\n            // 0x200 - 0x220 = length of `proofOutput`\n\n            // 0x220 - 0x240 = relative offset between `t` and `inputNotes`\n\n            // 0x240 - 0x260 = relative offset between `t` and `outputNotes`\n\n            // 0x260 - 0x280 = `publicOwner`\n\n            // 0x280 - 0x2a0 = `publicValue`\n\n            // 0x2a0 - 0x2c0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x2c0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes = 1\n\n            // 0x40 - 0x60 = offset to start of input note (0x60)\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `owner`\n\n            // 0x40 - 0x60 = `noteHash`\n\n            // 0x60 - 0x80 = size of note `data`\n\n            // 0x80 - 0xa0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xa0 - 0xc0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xc0 - ???? = remaining note metadata\n\n\n\n            // Note organisation...\n\n            // The bilateral swap proof proves the following:\n\n            //   1. note[0].value == note[2].value\n\n            //   2. note[1].value == note[3].value\n\n            // In other words...\n\n            // note[0] = maker bid note\n\n            // note[1] = maker ask note\n\n            // note[2] = taker ask note\n\n            // note[3] = taker bid note\n\n\n\n            // We therefore have 2 balancing relationships\n\n            // 1. The maker bid note is destroyed and replaced with the taker ask note\n\n            // 2. The taker bid note is destroyed and replaced with the maker ask note\n\n\n\n            // Finally, we can translate this into 2 proofOutputs entries...\n\n            // In the first entry, `inputNotes` = [note[0]] and `outputNotes` = [note[2]]\n\n            // In the second entry, `inputNotes` = [note[3]] and `outputNotes` = [note[1]]\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at 0x180\n\n\n\n            // we use memory from 0x00 - 0x140 as scratch memory\n\n\n\n            // return data starts at 0x160. As return data is `bytes proofOutputs`,\n\n            // the first word is the relative offset to the start of `proofOutputs` (i.e. 0x20)\n\n            mstore(0x160, 0x20)\n\n\n\n            /**\n\n            * Encoding of proofOutputs\n\n            * abi encoding of proofOutputs\n\n            * 0x00 : 0x20 = byte length of `proofOutputs` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = number of `proofOutputs` entries (2)\n\n            * 0x40 : 0x60 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            * 0x60 : 0x80 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n            * 0x80 : 0x80 + L1    = start of proofOutputs[0]\n\n            * 0x80 + L1   : 0x80 + L1 + L2 = start of proofOutputs[1]\n\n            **/\n\n        \n\n            // 0x180 stores the total size of `bytes proofOutputs`. We don't know that yet, so leave blank\n\n\n\n            // 0x1a0 = number of proof outputs (2)\n\n            mstore(0x1a0, 0x02)                            // number of proofs\n\n\n\n            // 0x1c0 = relative offset to 1st entry (0x80, 4 words)\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n\n\n            /**\n\n            * Encoding of proofOutput\n\n            * 0x00 : 0x20 = byte length of `proofOutput` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = relative offset to `bytes inputNotes`\n\n            * 0x40 : 0x60 = relative offset to `bytes outputNotes`\n\n            * 0x60 : 0x80 = publicOwner\n\n            * 0x80 : 0xa0 = publicValue\n\n            * 0xa0 : 0xc0 = challenge\n\n            * 0xc0 : 0xc0 + L1 = `bytes inputNotes` (L1 = 0x140 bytes)\n\n            * 0xc0 + L1 : 0xc0 + L1 + L2 = `bytes inputNotes`\n\n            *\n\n            * Start of proofOutput = 0x200\n\n            **/\n\n\n\n            // length of proofOutput is at 0x200. We don't know that yet, so leave blank\n\n\n\n            // relative offset to inputNotes = 0xc0 (6 words)\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n\n\n            // we know that inputNotes has 1 entry, and input notes don't have metadata.\n\n            // So we actually know the complete size of `bytes inputNotes`\n\n            // (it's 0x140 bytes, we'll get to that in a bit)\n\n            // => relative offset to outputNotes = 0x140 + 0xc0 = 0x200\n\n            mstore(0x240, 0x200)                           // location of outputNotes\n\n\n\n            // bilateral swap proof hardcodes `publicOwner` and `publicValue` to 0 (no public tokens)\n\n            mstore(0x260, 0x00)                             // publicOwner\n\n            mstore(0x280, 0x00)                             // publicValue\n\n            mstore(0x2a0, calldataload(0x124))              // challenge\n\n            /**\n\n            * Encoding of inputNotes\n\n            * 0x00 : 0x20 = byte length of `inputNotes` (0x120)\n\n            * 0x20 : 0x40 = number of input notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st input note (0x60)\n\n            * 0x60 : L    = 1st input note data (L = 0xe0)\n\n            *\n\n            * Start of inputNotes = 0x2a0\n\n            * Because we only have 1 note in this array, and that note has no metadata\n\n            * we know that the size of the note is 0xe0 bytes\n\n            * therefore, the size of inputNotes = 0xe0 + 3 words = 0x140 bytes.\n\n            * We store the byte length as 0x120 bytes because the length parameter\n\n            * of a dynamic bytes array does not include itself in the length calculation\n\n            **/\n\n\n\n            // 0x2c0 = length of inputNotes = 0x120\n\n            mstore(0x2c0, 0x120)\n\n\n\n            // 0x2e0 = number of notes (1)\n\n            mstore(0x2e0, 0x01) // 1 input note\n\n\n\n            // 0x300 = relative offset to input note (0x60)\n\n            mstore(0x300, 0x60) // relative offset to note data\n\n\n\n            /**\n\n            * Encoding of input note\n\n            * 0x00 : 0x20 = byte length of note (0xc0)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            *\n\n            * Start of note = 0x320\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // we use memory from 0x00 - 0xa0 as scratch memory to compute note hash\n\n            // Note hash = keccak256(abi.encode(noteType, gammaX, gammaY, sigmaX, sigmaY))\n\n            mstore(0x00, 0x01) // store noteType at 0x01\n\n\n\n            // We want to copy note coordinate data into memory from 0x20 - 0xa0\n\n            // 'notes' points to the start of the notes array\n\n            // i.e. notes + 0x20 will point to the start of the data of the first entry\n\n            // first two entries are \\bar{k} and \\bar{a}, which we wish to skip over\n\n            // input note is notes[0] => we need to point to notes + 0x60\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // copy gamma, sigma into 0x20 - 0xa0\n\n\n\n            // 0x320 = length of note (0xc0)\n\n            mstore(0x320, 0xc0)\n\n\n\n            // 0x340 = note type (UXTO type, 0x01)\n\n            mstore(0x340, 0x01) // note type\n\n\n\n            // 0x360 = note owners. We want the 1st entry in `noteOwners` (calldataload(noteOwners))\n\n            mstore(0x360, calldataload(noteOwners)) // note owner\n\n\n\n            // 0x380 = note hash, which is the hash of memory from 0x00 - 0xa0\n\n            mstore(0x380, keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // 0x3a0 = noteData length (0x40, no metadata)\n\n            mstore(0x3a0, 0x40)\n\n\n\n            // We now need to store compressed note coordinates.\n\n            // We store them in compressed form, as this stuff will be emitted as an event and is not required\n\n            // for additional smart contract logic. Compressing reduces the event data size and saves a fair bit of gas\n\n\n\n            // To compress, we determine if the y-coordinate is odd.\n\n            // If it is, we set the 256th bit of the x-coordinate to 'true'.\n\n            // bn128 field elements are only 254 bits long, so we know that we won't override x-coordinate data\n\n            // (we already have the note coords in memory, so we load from memory instead of calldata)\n\n\n\n            // 0x3c0 = gamma\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20), // load x coordinate\n\n                    mul(         // multiply by (y & 1 ? 2^255 : 0)\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // 0x3e0 = sigma\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                    and(mload(0x80), 0x01),\n\n                    0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /**\n\n            * Encoding of output notes\n\n            *\n\n            * abi format is identical to input notes, but now we don't know the total size\n\n            * (because of variable length metadata)\n\n            * 0x00 : 0x20 = byte length of `outputNotes` (0x40 + L)\n\n            * 0x20 : 0x40 = number of output notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st output note (0x60)\n\n            * 0x60 : 0x60 + L    = 1st output note data\n\n            *\n\n            * Start of outputNotes = 0x400\n\n            **/\n\n\n\n            // 0x400 = byte length of output notes. We don't know what this is so leave blank for now\n\n\n\n            // 0x420 = number of output notes (0x01)\n\n            mstore(0x420, 0x01)\n\n\n\n            // 0x440 = relative offset to output note data (0x60)\n\n            mstore(0x440, 0x60)\n\n\n\n            /**\n\n            * Encoding of output note\n\n            * 0x00 : 0x20 = byte length of note (0xc0 + L)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40 + L)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            * 0xe0 : 0xe0 + L = note metadata\n\n            *\n\n            * Start of note = 0x460\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // next, copy note coordinates into memory to compute hash.\n\n            // We already stored the noteType at position 0x00, no need to do that again\n\n            // We need to copy data from notes[2].\n\n            // 1. notes + 0x20 = start of 1st entry data\n\n            // 2. size of a note entry = 0xc0 bytes\n\n            // 3. we want to point to 3rd word in our note entry, to skip over \\bar{k}, \\bar{a}\n\n            //    (i.e. add 0x40 to caldlata pointer)\n\n            // => offset = notes + 0x20 + 0x40 + (0xc0 * 2) = notes + 0x1e0\n\n            // => calldata pointer = notes + 0x1e0\n\n            calldatacopy(0x20, add(notes, 0x1e0), 0x80) // get gamma, sigma\n\n\n\n            // 0x460 = byte length of output note. Leave blank for now\n\n\n\n            // 0x480 = note type (0x01)\n\n            mstore(0x480, 0x01)      // note type\n\n\n\n            // 0x4a0 = note owner. We are accessing `notes[2]`, therefore\n\n            // the note owner = noteOwners[2].\n\n            // i.e. noteOwners + 0x40\n\n            mstore(0x4a0, calldataload(add(noteOwners, 0x40))) // note owner\n\n\n\n            // 0x4c0 = note hash\n\n            mstore(0x4c0, keccak256(0x00, 0xa0))\n\n\n\n            // 0x4e0 = noteData length. To get this, we need to identify our metadata length\n\n            // `metadataPtr` points to the relative offset, in the `metadata` array, to the first metadata entry\n\n            // ABI encoding of the input data should encode 2 metadata entries.\n\n            // => relative offset to this note's metadata = `calldataload(metadataPtr)`\n\n            let metadataIndex := calldataload(metadataPtr)\n\n\n\n            // To convert this into a calldata offset, we must add the number of bytes of calldata\n\n            // that preceeds the start of the `metadata` array.\n\n\n\n            // `bytes metadata` abi encoding:\n\n            // 0x00 : 0x20 = size of bytes array\n\n            // 0x20 : 0x40 = number of metadata entries (i)\n\n            // 0x40 : 0x40 + (0x20 * j) = relative offsets to each metadata entry\n\n            // 0x40 + (0x20 * j) : ??? = metadata entries\n\n\n\n            // The `metadata` pointer points to the 3rd word (at 0x40), the 1st relative offset\n\n            // Therefore, to compute the calldata offset to the metadata entry,\n\n            // we need to add `metadataPtr - 0x40` to `calldataload(metadataPtr)`.\n\n            // i.e. metadataCalldataPtr = calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // Because each metadata entry is itself a dynamic bytes array, the first word will\n\n            // be the length of the metadata entry. This is what we want, so we directly call\n\n            // `calldataload` on our offset\n\n            let metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // 0x4e0 = noteData length = 0x40 + metadata length\n\n            mstore(0x4e0, add(0x40, metadataLength))\n\n\n\n            // 0x500 = compressed note coordinate gamma\n\n            mstore(\n\n                0x500,\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // 0x520 = compressed note coordinate sigma\n\n            mstore(\n\n                0x520,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // To complete `noteData`, we need to copy note metadata into memory (0x540)\n\n            // We know that metadataIndex + metadataPtr - 0x40 points to the start of the metadata entry in calldata.\n\n            // But the first word is the length of the metadata entry, which we don't want.\n\n            // So we need to point to the second word (the byte array data).\n\n            // i.e. we want to start copying at (metadataIndex + metadataPtr - 0x20)\n\n            // and we want to copy `metadataLength` number of bytes.\n\n            calldatacopy(0x540, add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // We now need to work backwards and fill in the parts of `bytes proofOutput` that we left blank,\n\n            // as we now can identify the size of the array\n\n\n\n            // 0x460 points to the size of the output note. The actual size is 0xe0 + metadataLength.\n\n            // So we record 0xc0 + metadataLength\n\n            // (because the 'size' of a byte array does not take into account the word needed to record the size)\n\n            mstore(0x460, add(0xc0, metadataLength))  // update size of note\n\n\n\n            // 0x400 = the size of `bytes outputNotes`.\n\n            // Raw size = 0x140 + metadataLength, so record 0x120 + metadataLength\n\n            mstore(0x400, add(0x120, metadataLength)) // update size of outputNotes\n\n\n\n            // 0x200 = the size of `bytes proofOutput`\n\n            // Raw size = 0x340 + metadataLength, so record 0x340 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength))\n\n\n\n            // Great! We've now finished writing the 1st proof output.\n\n            // We now need to write the ABI encoding of the 2nd proof output entry.\n\n\n\n            // 0x1e0 points to the relative offset in `bytes proofOutputs` to the second proof entry.\n\n            // This will be equal to the size of the 1st proof, plus the 0x80 preceeding bytes\n\n            // that are used to record `bytes proofOutputs`\n\n            // i.e. relative offset = 0x340 + 0x80 + metadataLength = 0x3c0 + metadataLength\n\n            mstore(0x1e0, add(0x3c0, metadataLength))\n\n\n\n            /** \n\n            * proofOutput[1]\n\n            **/\n\n\n\n            // When writing data into proofOutputs[1], we cannot use an absolute offset as \n\n            // metadataLength is not known at compile time.\n\n            // `proofPtr` points to the start of `proofOutputs[1]`\n\n            let proofPtr := add(0x540, metadataLength)\n\n\n\n            // (proofPtr) = size of proofOutput (leave blank for now)\n\n\n\n            // (proofPtr + 0x20) = offset to inputNotes (0xc0)\n\n            mstore(add(proofPtr, 0x20), 0xc0)\n\n\n\n            // (proofPtr + 0x40) = offset to outputNotes (0x200)\n\n            mstore(add(proofPtr, 0x40), 0x200)\n\n\n\n            // (proofPtr + 0x60) = publicOwner (0)\n\n            mstore(add(proofPtr, 0x60), 0x00) // publicOwner\n\n\n\n            // (proofPtr + 0x80) = publicValue (0)\n\n            mstore(add(proofPtr, 0x80), 0x00) // publicValue\n\n\n\n            // (proofPtr + 0xa0) = challenge\n\n            // we hash the challenge to get the second proof output's challenge - to preserve uniqueness\n\n            mstore(0xe0, calldataload(0x124))\n\n            mstore(add(proofPtr, 0xa0), keccak256(0xe0, 0x20)) // challenge\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes\n\n            *\n\n            * starts at (proofPtr + 0xc0)\n\n            **/\n\n\n\n            // (proofPtr + 0xc0) = byte size of inputNotes (0x120)\n\n            mstore(add(proofPtr, 0xc0), 0x120)\n\n\n\n            // (proofPtr + 0xe0) = number of input notes (0x01)\n\n            mstore(add(proofPtr, 0xe0), 0x01)\n\n\n\n            // (proofPtr + 0x100) = relative offset to input note data (0x60)\n\n            mstore(add(proofPtr, 0x100), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x120)\n\n            **/\n\n\n\n            // input note = notes[3]\n\n            // => offset = notes + 0x60 + (0xc0 * 3) = notes + 0x2a0\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x2a0), 0x80)\n\n\n\n            // (proofPtr + 0x120) = byte length of input note (0xc0)\n\n            mstore(add(proofPtr, 0x120), 0xc0) // length of input note\n\n\n\n            // (proofPtr + 0x140) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x140), 0x01) // note type\n\n\n\n            // (proofPtr + 0x160) = note owner = noteOwners[3]\n\n            mstore(add(proofPtr, 0x160), calldataload(add(noteOwners, 0x60))) // note owner\n\n\n\n            // (proofPtr + 0x180) = note hash\n\n            mstore(add(proofPtr, 0x180), keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // (proofPtr + 0x1a0) = noteData length (0x40 bytes)\n\n            mstore(add(proofPtr, 0x1a0), 0x40)\n\n\n\n            // (proofPtr + 0x1c0) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x1c0),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x1e0) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x1e0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes\n\n            *\n\n            * starts at (proofPtr + 0x200)\n\n            **/\n\n\n\n            // (proofPtr + 0x200) = byte length of output notes, leave blank for now\n\n\n\n            // (proofPtr + 0x220) = number of output notes (0x01)\n\n            mstore(add(proofPtr, 0x220), 0x01)\n\n\n\n            // (proofPtr + 0x240) = offset to output notes (0x60)\n\n            mstore(add(proofPtr, 0x240), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x260)\n\n            **/\n\n            // output note = notes[1]\n\n            // => offset = notes + 0x60 + 0xc0 = notes + 0x120\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80)\n\n\n\n            // (proofPtr + 0x260) = length of note, leave blank for now\n\n\n\n            // (proofPtr + 0x280) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x280), 0x01) // note type\n\n\n\n            // (proofPtr + 0x2a0) = note owner (noteOwners[1])\n\n            mstore(add(proofPtr, 0x2a0), calldataload(add(noteOwners, 0x20)))\n\n\n\n            // (proofPtr + 0x2c0) = note hash\n\n            mstore(add(proofPtr, 0x2c0), keccak256(0x00, 0xa0))\n\n\n\n            // We now need to compute the metadata length. We want to access the 2nd metadata entry,\n\n            // at (metadataPtr + 0x20)\n\n            metadataIndex := calldataload(add(metadataPtr, 0x20))\n\n            metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // (proofPtr + 0x2e0) = noteData length (0x40 + metadataLength)\n\n            mstore(add(proofPtr, 0x2e0), add(0x40, metadataLength))\n\n\n\n            // (proofPtr + 0x300) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x300),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x320) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x320),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x340) = start of note metadata\n\n            calldatacopy(add(proofPtr, 0x340), add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // Next, work backwards and fill in the remaining gaps\n\n            // (proofPtr + 0x260) = proofOutputs[1].outputNotes[0].length (0xc0 + metadataLength)\n\n            mstore(add(proofPtr, 0x260), add(0xc0, metadataLength))\n\n\n\n            // (proofPtr + 0x200) = proofOutputs[1].outputNotes.length (0x120 + metadataLength)\n\n            mstore(add(proofPtr, 0x200), add(0x120, metadataLength))\n\n\n\n            // (proofPtr) = proofOutputs[1].length = (0x320 + metadataLength)\n\n            mstore(proofPtr, add(0x320, metadataLength))\n\n\n\n            // (0x180) = proofOutputs.length\n\n            // We previously stored proofOutputs[0].length at 0x200\n\n            // Total length = combination of\n\n            // 1. proofOutputs[0].length + 0x20 (extra word because of length variable)\n\n            // 2. proofOutputs[1].length + 0x20 (^^)\n\n            // 3. data to record relative offsets (0x20 * number of outputs) = (0x40)\n\n            // 4. data to record number of entries (0x20)\n\n            \n\n            // We stored proofOutputs[0].length at 0x200\n\n            // and we know that proofOutputs[1].length = 0x320 + metadataLength\n\n            // => length = mload(0x200) + metadataLength + 0x320 + 0x40 + 0x40 + 0x20\n\n            // => length = mload(0x200) + metadataLength + 0x3c0\n\n            mstore(0x180, add(add(0x3c0, metadataLength), mload(0x200)))\n\n\n\n            // Great, we've done it! Now all that is left is to return from this transaction.\n\n            // Our return data starts at 0x160.\n\n            // Total size of `bytes proofOutpust` = proofOutputs.length + 0x20\n\n            // We need 1 extra word (at 0x160) for the relative offset to get to `bytes proofOutputs`\n\n            // => returndata size = proofOutputs.length + 0x40\n\n            // = mload(0x180) + 0x40\n\n            return(0x160, add(mload(0x180), 0x40)) // *kazoo noises*\n\n        }\n",
                    "message": "BilateralSwapABIEncoder.encodeAndExit (BilateralSwap.sol#38-604) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 604,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let noteOwners := add(0x124, calldataload(0x164)) // // one word after inputOwners = 1st\n\n            let metadataPtr := add(0x144, calldataload(0x184)) // two words after metadata = 1st\n\n\n\n            // First up, we need to do some checks to ensure we have been provided with correct data.\n\n            // We should only have 2 entries inside `bytes metadata` (only 2 output notes in total),\n\n            // and only 4 entries inside `noteOwners` (4 notes in bilateral swap proof)\n\n            if iszero(and(\n\n                eq(0x02, calldataload(sub(metadataPtr, 0x20))),\n\n                eq(0x04, calldataload(sub(noteOwners, 0x20)))\n\n            )) {\n\n                revert(0x00, 0x00) // no! bad! come back with good inputs!\n\n            }\n\n\n\n            // memory map of `proofOutputs`\n\n            // 0x00 - 0x160  = scratch data for note hash computation\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            // 0x1e0 - 0x200 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n    \n\n            // `proofOutput` - t, starts at 0x200\n\n            // 0x200 - 0x220 = length of `proofOutput`\n\n            // 0x220 - 0x240 = relative offset between `t` and `inputNotes`\n\n            // 0x240 - 0x260 = relative offset between `t` and `outputNotes`\n\n            // 0x260 - 0x280 = `publicOwner`\n\n            // 0x280 - 0x2a0 = `publicValue`\n\n            // 0x2a0 - 0x2c0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x2c0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes = 1\n\n            // 0x40 - 0x60 = offset to start of input note (0x60)\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `owner`\n\n            // 0x40 - 0x60 = `noteHash`\n\n            // 0x60 - 0x80 = size of note `data`\n\n            // 0x80 - 0xa0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xa0 - 0xc0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xc0 - ???? = remaining note metadata\n\n\n\n            // Note organisation...\n\n            // The bilateral swap proof proves the following:\n\n            //   1. note[0].value == note[2].value\n\n            //   2. note[1].value == note[3].value\n\n            // In other words...\n\n            // note[0] = maker bid note\n\n            // note[1] = maker ask note\n\n            // note[2] = taker ask note\n\n            // note[3] = taker bid note\n\n\n\n            // We therefore have 2 balancing relationships\n\n            // 1. The maker bid note is destroyed and replaced with the taker ask note\n\n            // 2. The taker bid note is destroyed and replaced with the maker ask note\n\n\n\n            // Finally, we can translate this into 2 proofOutputs entries...\n\n            // In the first entry, `inputNotes` = [note[0]] and `outputNotes` = [note[2]]\n\n            // In the second entry, `inputNotes` = [note[3]] and `outputNotes` = [note[1]]\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at 0x180\n\n\n\n            // we use memory from 0x00 - 0x140 as scratch memory\n\n\n\n            // return data starts at 0x160. As return data is `bytes proofOutputs`,\n\n            // the first word is the relative offset to the start of `proofOutputs` (i.e. 0x20)\n\n            mstore(0x160, 0x20)\n\n\n\n            /**\n\n            * Encoding of proofOutputs\n\n            * abi encoding of proofOutputs\n\n            * 0x00 : 0x20 = byte length of `proofOutputs` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = number of `proofOutputs` entries (2)\n\n            * 0x40 : 0x60 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            * 0x60 : 0x80 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n            * 0x80 : 0x80 + L1    = start of proofOutputs[0]\n\n            * 0x80 + L1   : 0x80 + L1 + L2 = start of proofOutputs[1]\n\n            **/\n\n        \n\n            // 0x180 stores the total size of `bytes proofOutputs`. We don't know that yet, so leave blank\n\n\n\n            // 0x1a0 = number of proof outputs (2)\n\n            mstore(0x1a0, 0x02)                            // number of proofs\n\n\n\n            // 0x1c0 = relative offset to 1st entry (0x80, 4 words)\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n\n\n            /**\n\n            * Encoding of proofOutput\n\n            * 0x00 : 0x20 = byte length of `proofOutput` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = relative offset to `bytes inputNotes`\n\n            * 0x40 : 0x60 = relative offset to `bytes outputNotes`\n\n            * 0x60 : 0x80 = publicOwner\n\n            * 0x80 : 0xa0 = publicValue\n\n            * 0xa0 : 0xc0 = challenge\n\n            * 0xc0 : 0xc0 + L1 = `bytes inputNotes` (L1 = 0x140 bytes)\n\n            * 0xc0 + L1 : 0xc0 + L1 + L2 = `bytes inputNotes`\n\n            *\n\n            * Start of proofOutput = 0x200\n\n            **/\n\n\n\n            // length of proofOutput is at 0x200. We don't know that yet, so leave blank\n\n\n\n            // relative offset to inputNotes = 0xc0 (6 words)\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n\n\n            // we know that inputNotes has 1 entry, and input notes don't have metadata.\n\n            // So we actually know the complete size of `bytes inputNotes`\n\n            // (it's 0x140 bytes, we'll get to that in a bit)\n\n            // => relative offset to outputNotes = 0x140 + 0xc0 = 0x200\n\n            mstore(0x240, 0x200)                           // location of outputNotes\n\n\n\n            // bilateral swap proof hardcodes `publicOwner` and `publicValue` to 0 (no public tokens)\n\n            mstore(0x260, 0x00)                             // publicOwner\n\n            mstore(0x280, 0x00)                             // publicValue\n\n            mstore(0x2a0, calldataload(0x124))              // challenge\n\n            /**\n\n            * Encoding of inputNotes\n\n            * 0x00 : 0x20 = byte length of `inputNotes` (0x120)\n\n            * 0x20 : 0x40 = number of input notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st input note (0x60)\n\n            * 0x60 : L    = 1st input note data (L = 0xe0)\n\n            *\n\n            * Start of inputNotes = 0x2a0\n\n            * Because we only have 1 note in this array, and that note has no metadata\n\n            * we know that the size of the note is 0xe0 bytes\n\n            * therefore, the size of inputNotes = 0xe0 + 3 words = 0x140 bytes.\n\n            * We store the byte length as 0x120 bytes because the length parameter\n\n            * of a dynamic bytes array does not include itself in the length calculation\n\n            **/\n\n\n\n            // 0x2c0 = length of inputNotes = 0x120\n\n            mstore(0x2c0, 0x120)\n\n\n\n            // 0x2e0 = number of notes (1)\n\n            mstore(0x2e0, 0x01) // 1 input note\n\n\n\n            // 0x300 = relative offset to input note (0x60)\n\n            mstore(0x300, 0x60) // relative offset to note data\n\n\n\n            /**\n\n            * Encoding of input note\n\n            * 0x00 : 0x20 = byte length of note (0xc0)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            *\n\n            * Start of note = 0x320\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // we use memory from 0x00 - 0xa0 as scratch memory to compute note hash\n\n            // Note hash = keccak256(abi.encode(noteType, gammaX, gammaY, sigmaX, sigmaY))\n\n            mstore(0x00, 0x01) // store noteType at 0x01\n\n\n\n            // We want to copy note coordinate data into memory from 0x20 - 0xa0\n\n            // 'notes' points to the start of the notes array\n\n            // i.e. notes + 0x20 will point to the start of the data of the first entry\n\n            // first two entries are \\bar{k} and \\bar{a}, which we wish to skip over\n\n            // input note is notes[0] => we need to point to notes + 0x60\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // copy gamma, sigma into 0x20 - 0xa0\n\n\n\n            // 0x320 = length of note (0xc0)\n\n            mstore(0x320, 0xc0)\n\n\n\n            // 0x340 = note type (UXTO type, 0x01)\n\n            mstore(0x340, 0x01) // note type\n\n\n\n            // 0x360 = note owners. We want the 1st entry in `noteOwners` (calldataload(noteOwners))\n\n            mstore(0x360, calldataload(noteOwners)) // note owner\n\n\n\n            // 0x380 = note hash, which is the hash of memory from 0x00 - 0xa0\n\n            mstore(0x380, keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // 0x3a0 = noteData length (0x40, no metadata)\n\n            mstore(0x3a0, 0x40)\n\n\n\n            // We now need to store compressed note coordinates.\n\n            // We store them in compressed form, as this stuff will be emitted as an event and is not required\n\n            // for additional smart contract logic. Compressing reduces the event data size and saves a fair bit of gas\n\n\n\n            // To compress, we determine if the y-coordinate is odd.\n\n            // If it is, we set the 256th bit of the x-coordinate to 'true'.\n\n            // bn128 field elements are only 254 bits long, so we know that we won't override x-coordinate data\n\n            // (we already have the note coords in memory, so we load from memory instead of calldata)\n\n\n\n            // 0x3c0 = gamma\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20), // load x coordinate\n\n                    mul(         // multiply by (y & 1 ? 2^255 : 0)\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // 0x3e0 = sigma\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                    and(mload(0x80), 0x01),\n\n                    0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /**\n\n            * Encoding of output notes\n\n            *\n\n            * abi format is identical to input notes, but now we don't know the total size\n\n            * (because of variable length metadata)\n\n            * 0x00 : 0x20 = byte length of `outputNotes` (0x40 + L)\n\n            * 0x20 : 0x40 = number of output notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st output note (0x60)\n\n            * 0x60 : 0x60 + L    = 1st output note data\n\n            *\n\n            * Start of outputNotes = 0x400\n\n            **/\n\n\n\n            // 0x400 = byte length of output notes. We don't know what this is so leave blank for now\n\n\n\n            // 0x420 = number of output notes (0x01)\n\n            mstore(0x420, 0x01)\n\n\n\n            // 0x440 = relative offset to output note data (0x60)\n\n            mstore(0x440, 0x60)\n\n\n\n            /**\n\n            * Encoding of output note\n\n            * 0x00 : 0x20 = byte length of note (0xc0 + L)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40 + L)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            * 0xe0 : 0xe0 + L = note metadata\n\n            *\n\n            * Start of note = 0x460\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // next, copy note coordinates into memory to compute hash.\n\n            // We already stored the noteType at position 0x00, no need to do that again\n\n            // We need to copy data from notes[2].\n\n            // 1. notes + 0x20 = start of 1st entry data\n\n            // 2. size of a note entry = 0xc0 bytes\n\n            // 3. we want to point to 3rd word in our note entry, to skip over \\bar{k}, \\bar{a}\n\n            //    (i.e. add 0x40 to caldlata pointer)\n\n            // => offset = notes + 0x20 + 0x40 + (0xc0 * 2) = notes + 0x1e0\n\n            // => calldata pointer = notes + 0x1e0\n\n            calldatacopy(0x20, add(notes, 0x1e0), 0x80) // get gamma, sigma\n\n\n\n            // 0x460 = byte length of output note. Leave blank for now\n\n\n\n            // 0x480 = note type (0x01)\n\n            mstore(0x480, 0x01)      // note type\n\n\n\n            // 0x4a0 = note owner. We are accessing `notes[2]`, therefore\n\n            // the note owner = noteOwners[2].\n\n            // i.e. noteOwners + 0x40\n\n            mstore(0x4a0, calldataload(add(noteOwners, 0x40))) // note owner\n\n\n\n            // 0x4c0 = note hash\n\n            mstore(0x4c0, keccak256(0x00, 0xa0))\n\n\n\n            // 0x4e0 = noteData length. To get this, we need to identify our metadata length\n\n            // `metadataPtr` points to the relative offset, in the `metadata` array, to the first metadata entry\n\n            // ABI encoding of the input data should encode 2 metadata entries.\n\n            // => relative offset to this note's metadata = `calldataload(metadataPtr)`\n\n            let metadataIndex := calldataload(metadataPtr)\n\n\n\n            // To convert this into a calldata offset, we must add the number of bytes of calldata\n\n            // that preceeds the start of the `metadata` array.\n\n\n\n            // `bytes metadata` abi encoding:\n\n            // 0x00 : 0x20 = size of bytes array\n\n            // 0x20 : 0x40 = number of metadata entries (i)\n\n            // 0x40 : 0x40 + (0x20 * j) = relative offsets to each metadata entry\n\n            // 0x40 + (0x20 * j) : ??? = metadata entries\n\n\n\n            // The `metadata` pointer points to the 3rd word (at 0x40), the 1st relative offset\n\n            // Therefore, to compute the calldata offset to the metadata entry,\n\n            // we need to add `metadataPtr - 0x40` to `calldataload(metadataPtr)`.\n\n            // i.e. metadataCalldataPtr = calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // Because each metadata entry is itself a dynamic bytes array, the first word will\n\n            // be the length of the metadata entry. This is what we want, so we directly call\n\n            // `calldataload` on our offset\n\n            let metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // 0x4e0 = noteData length = 0x40 + metadata length\n\n            mstore(0x4e0, add(0x40, metadataLength))\n\n\n\n            // 0x500 = compressed note coordinate gamma\n\n            mstore(\n\n                0x500,\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // 0x520 = compressed note coordinate sigma\n\n            mstore(\n\n                0x520,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // To complete `noteData`, we need to copy note metadata into memory (0x540)\n\n            // We know that metadataIndex + metadataPtr - 0x40 points to the start of the metadata entry in calldata.\n\n            // But the first word is the length of the metadata entry, which we don't want.\n\n            // So we need to point to the second word (the byte array data).\n\n            // i.e. we want to start copying at (metadataIndex + metadataPtr - 0x20)\n\n            // and we want to copy `metadataLength` number of bytes.\n\n            calldatacopy(0x540, add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // We now need to work backwards and fill in the parts of `bytes proofOutput` that we left blank,\n\n            // as we now can identify the size of the array\n\n\n\n            // 0x460 points to the size of the output note. The actual size is 0xe0 + metadataLength.\n\n            // So we record 0xc0 + metadataLength\n\n            // (because the 'size' of a byte array does not take into account the word needed to record the size)\n\n            mstore(0x460, add(0xc0, metadataLength))  // update size of note\n\n\n\n            // 0x400 = the size of `bytes outputNotes`.\n\n            // Raw size = 0x140 + metadataLength, so record 0x120 + metadataLength\n\n            mstore(0x400, add(0x120, metadataLength)) // update size of outputNotes\n\n\n\n            // 0x200 = the size of `bytes proofOutput`\n\n            // Raw size = 0x340 + metadataLength, so record 0x340 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength))\n\n\n\n            // Great! We've now finished writing the 1st proof output.\n\n            // We now need to write the ABI encoding of the 2nd proof output entry.\n\n\n\n            // 0x1e0 points to the relative offset in `bytes proofOutputs` to the second proof entry.\n\n            // This will be equal to the size of the 1st proof, plus the 0x80 preceeding bytes\n\n            // that are used to record `bytes proofOutputs`\n\n            // i.e. relative offset = 0x340 + 0x80 + metadataLength = 0x3c0 + metadataLength\n\n            mstore(0x1e0, add(0x3c0, metadataLength))\n\n\n\n            /** \n\n            * proofOutput[1]\n\n            **/\n\n\n\n            // When writing data into proofOutputs[1], we cannot use an absolute offset as \n\n            // metadataLength is not known at compile time.\n\n            // `proofPtr` points to the start of `proofOutputs[1]`\n\n            let proofPtr := add(0x540, metadataLength)\n\n\n\n            // (proofPtr) = size of proofOutput (leave blank for now)\n\n\n\n            // (proofPtr + 0x20) = offset to inputNotes (0xc0)\n\n            mstore(add(proofPtr, 0x20), 0xc0)\n\n\n\n            // (proofPtr + 0x40) = offset to outputNotes (0x200)\n\n            mstore(add(proofPtr, 0x40), 0x200)\n\n\n\n            // (proofPtr + 0x60) = publicOwner (0)\n\n            mstore(add(proofPtr, 0x60), 0x00) // publicOwner\n\n\n\n            // (proofPtr + 0x80) = publicValue (0)\n\n            mstore(add(proofPtr, 0x80), 0x00) // publicValue\n\n\n\n            // (proofPtr + 0xa0) = challenge\n\n            // we hash the challenge to get the second proof output's challenge - to preserve uniqueness\n\n            mstore(0xe0, calldataload(0x124))\n\n            mstore(add(proofPtr, 0xa0), keccak256(0xe0, 0x20)) // challenge\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes\n\n            *\n\n            * starts at (proofPtr + 0xc0)\n\n            **/\n\n\n\n            // (proofPtr + 0xc0) = byte size of inputNotes (0x120)\n\n            mstore(add(proofPtr, 0xc0), 0x120)\n\n\n\n            // (proofPtr + 0xe0) = number of input notes (0x01)\n\n            mstore(add(proofPtr, 0xe0), 0x01)\n\n\n\n            // (proofPtr + 0x100) = relative offset to input note data (0x60)\n\n            mstore(add(proofPtr, 0x100), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x120)\n\n            **/\n\n\n\n            // input note = notes[3]\n\n            // => offset = notes + 0x60 + (0xc0 * 3) = notes + 0x2a0\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x2a0), 0x80)\n\n\n\n            // (proofPtr + 0x120) = byte length of input note (0xc0)\n\n            mstore(add(proofPtr, 0x120), 0xc0) // length of input note\n\n\n\n            // (proofPtr + 0x140) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x140), 0x01) // note type\n\n\n\n            // (proofPtr + 0x160) = note owner = noteOwners[3]\n\n            mstore(add(proofPtr, 0x160), calldataload(add(noteOwners, 0x60))) // note owner\n\n\n\n            // (proofPtr + 0x180) = note hash\n\n            mstore(add(proofPtr, 0x180), keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // (proofPtr + 0x1a0) = noteData length (0x40 bytes)\n\n            mstore(add(proofPtr, 0x1a0), 0x40)\n\n\n\n            // (proofPtr + 0x1c0) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x1c0),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x1e0) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x1e0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes\n\n            *\n\n            * starts at (proofPtr + 0x200)\n\n            **/\n\n\n\n            // (proofPtr + 0x200) = byte length of output notes, leave blank for now\n\n\n\n            // (proofPtr + 0x220) = number of output notes (0x01)\n\n            mstore(add(proofPtr, 0x220), 0x01)\n\n\n\n            // (proofPtr + 0x240) = offset to output notes (0x60)\n\n            mstore(add(proofPtr, 0x240), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x260)\n\n            **/\n\n            // output note = notes[1]\n\n            // => offset = notes + 0x60 + 0xc0 = notes + 0x120\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80)\n\n\n\n            // (proofPtr + 0x260) = length of note, leave blank for now\n\n\n\n            // (proofPtr + 0x280) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x280), 0x01) // note type\n\n\n\n            // (proofPtr + 0x2a0) = note owner (noteOwners[1])\n\n            mstore(add(proofPtr, 0x2a0), calldataload(add(noteOwners, 0x20)))\n\n\n\n            // (proofPtr + 0x2c0) = note hash\n\n            mstore(add(proofPtr, 0x2c0), keccak256(0x00, 0xa0))\n\n\n\n            // We now need to compute the metadata length. We want to access the 2nd metadata entry,\n\n            // at (metadataPtr + 0x20)\n\n            metadataIndex := calldataload(add(metadataPtr, 0x20))\n\n            metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // (proofPtr + 0x2e0) = noteData length (0x40 + metadataLength)\n\n            mstore(add(proofPtr, 0x2e0), add(0x40, metadataLength))\n\n\n\n            // (proofPtr + 0x300) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x300),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x320) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x320),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x340) = start of note metadata\n\n            calldatacopy(add(proofPtr, 0x340), add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // Next, work backwards and fill in the remaining gaps\n\n            // (proofPtr + 0x260) = proofOutputs[1].outputNotes[0].length (0xc0 + metadataLength)\n\n            mstore(add(proofPtr, 0x260), add(0xc0, metadataLength))\n\n\n\n            // (proofPtr + 0x200) = proofOutputs[1].outputNotes.length (0x120 + metadataLength)\n\n            mstore(add(proofPtr, 0x200), add(0x120, metadataLength))\n\n\n\n            // (proofPtr) = proofOutputs[1].length = (0x320 + metadataLength)\n\n            mstore(proofPtr, add(0x320, metadataLength))\n\n\n\n            // (0x180) = proofOutputs.length\n\n            // We previously stored proofOutputs[0].length at 0x200\n\n            // Total length = combination of\n\n            // 1. proofOutputs[0].length + 0x20 (extra word because of length variable)\n\n            // 2. proofOutputs[1].length + 0x20 (^^)\n\n            // 3. data to record relative offsets (0x20 * number of outputs) = (0x40)\n\n            // 4. data to record number of entries (0x20)\n\n            \n\n            // We stored proofOutputs[0].length at 0x200\n\n            // and we know that proofOutputs[1].length = 0x320 + metadataLength\n\n            // => length = mload(0x200) + metadataLength + 0x320 + 0x40 + 0x40 + 0x20\n\n            // => length = mload(0x200) + metadataLength + 0x3c0\n\n            mstore(0x180, add(add(0x3c0, metadataLength), mload(0x200)))\n\n\n\n            // Great, we've done it! Now all that is left is to return from this transaction.\n\n            // Our return data starts at 0x160.\n\n            // Total size of `bytes proofOutpust` = proofOutputs.length + 0x20\n\n            // We need 1 extra word (at 0x160) for the relative offset to get to `bytes proofOutputs`\n\n            // => returndata size = proofOutputs.length + 0x40\n\n            // = mload(0x180) + 0x40\n\n            return(0x160, add(mload(0x180), 0x40)) // *kazoo noises*\n\n        }\n",
                    "message": "BilateralSwapABIEncoder.encodeAndExit uses assembly (BilateralSwap.sol#38-604)\n\t- BilateralSwap.sol#39-603\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": 874,
                    "vulnerability_code": "    function() external {\n\n        assembly {\n\n\n\n            // We don't check for function signatures, there's only one function that \n\n            // ever gets called: validateBilateralSwap()\n\n            // We still assume calldata is offset by 4 bytes so that we can represent \n\n            // this contract through a comp\\atible ABI\n\n            validateBilateralSwap()\n\n\n\n            // if we get to here, the proof is valid. We now 'fall through' the assembly block\n\n            // and into JoinSplitABI.validateJoinSplit()\n\n            // reset the free memory pointer because we're touching Solidity code again\n\n            mstore(0x40, 0x60)\n\n            /**\n\n             * New calldata map\n\n             * 0x04:0x24      = calldata location of proofData byte array \n\n             * 0x24:0x44      = message sender // sender\n\n             * 0x44:0x64      = h_x     // crs\n\n             * 0x64:0x84      = h_y     // crs\n\n             * 0x84:0xa4      = t2_x0   // crs\n\n             * 0xa4:0xc4      = t2_x1   // crs\n\n             * 0xa4:0xc4      = t2_x1   // crs\n\n             * 0xc4:0xe4      = t2_y0   // crs\n\n             * 0xe4:0x104     = t2_y1   // crs\n\n             * 0x104:0x124    = length of proofData byte array \n\n             * 0x124:0x144    = challenge\n\n             * 0x144:0x164    = offset in byte array to notes\n\n             * 0x164:0x184    = offset in byte array to inputOwners\n\n             * 0x184:0x1a4    = offset in byte array to outputOwners\n\n             * 0x1a4:0x1c4    = offset in byte array to metadata\n\n             *\n\n             *\n\n             * Note data map (uint[6]) is\n\n             * 0x00:0x20       = Z_p element \\bar{k}_i\n\n             * 0x20:0x40       = Z_p element \\bar{a}_i\n\n             * 0x40:0x80       = G1 element \\gamma_i\n\n             * 0x80:0xc0       = G1 element \\sigma_i\n\n             *\n\n             * We use a hard-coded memory map to reduce gas costs - if this is not called as an \n\n             * external contract then terrible things will happen!\n\n             *\n\n             * 0x00:0x20       = scratch data to store result of keccak256 calls\n\n             * 0x20:0x80       = scratch data to store \\gamma_i and a multiplication scalar\n\n             * 0x80:0xc0       = x-coordinate of generator h\n\n             * 0xc0:0xe0       = y-coordinate of generator h\n\n             * 0xe0:0x100      = scratch data to store a scalar we plan to multiply h by\n\n             * 0x100:0x160     = scratch data to store \\sigma_i and a multiplication scalar\n\n             * 0x160:0x1a0     = stratch data to store result of G1 point additions\n\n             * 0x1a0:0x1c0     = scratch data to store result of \\sigma_i^{-cx_{i-m-1}}\n\n             * 0x220:0x260     = scratch data to store \\gamma_i^{cx_{i-m-1}}\n\n             * 0x2e0:0x300     = msg.sender (contract should be called via delegatecall/staticcall)\n\n             * 0x300:???       = block of memory that contains (\\gamma_i, \\sigma_i)_{i=0}^{n-1} \n\n             *                   concatenated with (B_i)_{i=0}^{n-1}\n\n             **/\n\n            function validateBilateralSwap() {\n\n                /*\n\n                ///////////////////////////////////////////  SETUP  //////////////////////////////////////////////\n\n                */\n\n\n\n                mstore(0x80, calldataload(0x44)) // h_x\n\n                mstore(0xa0, calldataload(0x64)) // h_y\n\n                let notes := add(0x104, calldataload(0x144)) // start position of notes\n\n                let n := calldataload(notes) // first element of the notes array is it's length\n\n\n\n                if iszero(eq(n, 0x04)) { // eq(n, 4) will resolve to 0 if n != 4\n\n\n\n                    mstore(0x00, 400) // 400 error code - due to incorrect number of notes supplied\n\n                    revert(0x00, 0x20)\n\n\n\n                }\n\n\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let challenge := mod(calldataload(0x124), gen_order)\n\n\n\n                mstore(0x2e0, calldataload(0x24)) // store the msg.sender, to be hashed later\n\n\n\n                hashCommitments(notes, n)\n\n                let b := add(0x300, mul(n, 0x80)) // set pointer to memory location of commitments where the commitments\n\n\n\n                /*\n\n                ///////////////////////////  CALCULATE BLINDING FACTORS  /////////////////////////////////////\n\n                */\n\n\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n\n\n                    // Get the calldata index of this note and associated parameters\n\n                    let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                    let k\n\n                    let a := calldataload(add(noteIndex, 0x20))\n\n                    let c := challenge\n\n\n\n                    switch gt(i, 1) // i (an indexer) > 1 denotes a taker note\n\n                    case 1 { // if it's a taker note\n\n\n\n                        // indexing the k value of the note that is 2 indices behind the current note\n\n                        k := calldataload(sub(noteIndex, 0x180))\n\n                    } \n\n                        \n\n                    case 0 { // if it's a maker note\n\n                        k := calldataload(noteIndex)\n\n                    }\n\n\n\n\n\n                    // Check this commitment is well formed\n\n                    validateCommitment(noteIndex, k, a)\n\n                    \n\n                    // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\n\n                    // Memory map:\n\n                    // 0x20: \\gamma_iX\n\n                    // 0x40: \\gamma_iY\n\n                    // 0x60: k_i\n\n                    // 0x80: hX\n\n                    // 0xa0: hY\n\n                    // 0xc0: a_i\n\n                    // 0xe0: \\sigma_iX\n\n                    // 0x100: \\sigma_iY\n\n                    // 0x120: -c\n\n\n\n                    // loading into memory\n\n                    calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n\n                    calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n\n                    mstore(0x120, sub(gen_order, c)) \n\n                    mstore(0x60, k)\n\n                    mstore(0xc0, a)\n\n\n\n                    // Call bn128 scalar multiplication precompiles\n\n                    // Represent point + multiplication scalar in 3 consecutive blocks of memory\n\n                    // Store \\sigma_i^{-c} at 0x1a0:0x200\n\n                    // Store \\gamma_i^{k} at 0x120:0x160\n\n                    // Store h^{a} at 0x160:0x1a0\n\n                    let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40)\n\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\n\n                    result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\n\n\n\n                    // Call bn128 group addition precompiles\n\n                    // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n\n                    // Store result of addition at 0x160:0x1a0\n\n                    result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n\n\n                    // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n\n                    // Store resulting point B at memory index b\n\n                    result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n\n\n\n\n                    // throw transaction if any calls to precompiled contracts failed\n\n                    if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n\n                    b := add(b, 0x40) // increase B pointer by 2 words\n\n                }\n\n                // Both bid notes already exist in their revelant AZTEC note registries - so can inductively \n\n                // infer that the ask notes are in the required range\n\n                // Therefore, don't need a range proof\n\n            \n\n                /*\n\n                ////////////////////  RECONSTRUCT INITIAL CHALLENGE AND VERIFY A MATCH  ////////////////////////////////\n\n                */\n\n\n\n                // We now have the note commitments and the calculated blinding factors in a block of memory\n\n                // starting at 0x2e0, of size (b - 0x2e0).\n\n                // Hash this block to reconstruct the initial challenge and validate that they match\n\n                let expected := mod(keccak256(0x2e0, sub(b, 0x2e0)), gen_order)\n\n\n\n                if iszero(eq(expected, challenge)) {\n\n\n\n                    // No! Bad! No soup for you!\n\n                    mstore(0x00, 404)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**\n\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n\n             * and that signatures 'k' and 'a' are modulo the order of the curve. Transaction\n\n             * will throw if this is not the case.\n\n             * @param note the calldata loation of the note\n\n             **/\n\n            function validateCommitment(note, k, a) {\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n                let gammaX := calldataload(add(note, 0x40))\n\n                let gammaY := calldataload(add(note, 0x60))\n\n                let sigmaX := calldataload(add(note, 0x80))\n\n                let sigmaY := calldataload(add(note, 0xa0))\n\n                if iszero(\n\n                    and(\n\n                        and(\n\n                            and(\n\n                                eq(mod(a, gen_order), a), // a is modulo generator order?\n\n                                gt(a, 1)                  // can't be 0 or 1 either!\n\n                            ),\n\n                            and(\n\n                                eq(mod(k, gen_order), k), // k is modulo generator order?\n\n                                gt(k, 1)                  // and not 0 or 1\n\n                            )\n\n                        ),\n\n                        and(\n\n                            eq( // y^2 ?= x^3 + 3\n\n                                addmod(mulmod(\n\n                                    mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), \n\n                                    3, \n\n                                    field_order),\n\n                                mulmod(sigmaY, sigmaY, field_order)\n\n                            ),\n\n                            eq( // y^2 ?= x^3 + 3\n\n                                addmod(mulmod(\n\n                                    mulmod(gammaX, gammaX, field_order), \n\n                                    gammaX, \n\n                                    field_order), \n\n                                    3, field_order),\n\n                                mulmod(gammaY, gammaY, field_order)\n\n                            )\n\n                        )\n\n                    )\n\n                ) {\n\n                    mstore(0x00, 400)\n\n                    revert(0x00, 0x20)\n\n                }\n\n            }\n\n\n\n            /**\n\n             * @dev Calculate the keccak256 hash of the commitments for both \n\n             * input notes and output notes. This is used both as an input to \n\n             * validate the challenge `c` and also to generate pseudorandom relationships\n\n             * between commitments for different outputNotes, so that we can combine \n\n             * them into a single multi-exponentiation for the purposes of validating \n\n             * the bilinear pairing relationships.\n\n             * @param notes calldata location notes\n\n             * @param n number of notes\n\n             **/\n\n            function hashCommitments(notes, n) {\n\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n                let index := add(add(notes, mul(i, 0xc0)), 0x60)\n\n                calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n\n                }\n\n                // storing at position 0x00 in memory, the kecca hash of everything from \n\n                // start of the commitments to the end\n\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n\n            }\n\n        }\n\n        // if we've reached here, we've validated the bilateral swap and haven't thrown an error.\n\n        // Encode the output according to the ACE standard and exit.\n\n        BilateralSwapABIEncoder.encodeAndExit();\n",
                    "message": "BilateralSwap.fallback uses assembly (BilateralSwap.sol#632-874)\n\t- BilateralSwap.sol#633-870\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in BilateralSwap.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (BilateralSwap.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (BilateralSwap.sol#609): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/ACE/validators/bilateralSwap/BilateralSwapABIEncoder.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 604,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let noteOwners := add(0x124, calldataload(0x164)) // // one word after inputOwners = 1st\n\n            let metadataPtr := add(0x144, calldataload(0x184)) // two words after metadata = 1st\n\n\n\n            // First up, we need to do some checks to ensure we have been provided with correct data.\n\n            // We should only have 2 entries inside `bytes metadata` (only 2 output notes in total),\n\n            // and only 4 entries inside `noteOwners` (4 notes in bilateral swap proof)\n\n            if iszero(and(\n\n                eq(0x02, calldataload(sub(metadataPtr, 0x20))),\n\n                eq(0x04, calldataload(sub(noteOwners, 0x20)))\n\n            )) {\n\n                revert(0x00, 0x00) // no! bad! come back with good inputs!\n\n            }\n\n\n\n            // memory map of `proofOutputs`\n\n            // 0x00 - 0x160  = scratch data for note hash computation\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            // 0x1e0 - 0x200 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n    \n\n            // `proofOutput` - t, starts at 0x200\n\n            // 0x200 - 0x220 = length of `proofOutput`\n\n            // 0x220 - 0x240 = relative offset between `t` and `inputNotes`\n\n            // 0x240 - 0x260 = relative offset between `t` and `outputNotes`\n\n            // 0x260 - 0x280 = `publicOwner`\n\n            // 0x280 - 0x2a0 = `publicValue`\n\n            // 0x2a0 - 0x2c0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x2c0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes = 1\n\n            // 0x40 - 0x60 = offset to start of input note (0x60)\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `owner`\n\n            // 0x40 - 0x60 = `noteHash`\n\n            // 0x60 - 0x80 = size of note `data`\n\n            // 0x80 - 0xa0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xa0 - 0xc0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xc0 - ???? = remaining note metadata\n\n\n\n            // Note organisation...\n\n            // The bilateral swap proof proves the following:\n\n            //   1. note[0].value == note[2].value\n\n            //   2. note[1].value == note[3].value\n\n            // In other words...\n\n            // note[0] = maker bid note\n\n            // note[1] = maker ask note\n\n            // note[2] = taker ask note\n\n            // note[3] = taker bid note\n\n\n\n            // We therefore have 2 balancing relationships\n\n            // 1. The maker bid note is destroyed and replaced with the taker ask note\n\n            // 2. The taker bid note is destroyed and replaced with the maker ask note\n\n\n\n            // Finally, we can translate this into 2 proofOutputs entries...\n\n            // In the first entry, `inputNotes` = [note[0]] and `outputNotes` = [note[2]]\n\n            // In the second entry, `inputNotes` = [note[3]] and `outputNotes` = [note[1]]\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at 0x180\n\n\n\n            // we use memory from 0x00 - 0x140 as scratch memory\n\n\n\n            // return data starts at 0x160. As return data is `bytes proofOutputs`,\n\n            // the first word is the relative offset to the start of `proofOutputs` (i.e. 0x20)\n\n            mstore(0x160, 0x20)\n\n\n\n            /**\n\n            * Encoding of proofOutputs\n\n            * abi encoding of proofOutputs\n\n            * 0x00 : 0x20 = byte length of `proofOutputs` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = number of `proofOutputs` entries (2)\n\n            * 0x40 : 0x60 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            * 0x60 : 0x80 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n            * 0x80 : 0x80 + L1    = start of proofOutputs[0]\n\n            * 0x80 + L1   : 0x80 + L1 + L2 = start of proofOutputs[1]\n\n            **/\n\n        \n\n            // 0x180 stores the total size of `bytes proofOutputs`. We don't know that yet, so leave blank\n\n\n\n            // 0x1a0 = number of proof outputs (2)\n\n            mstore(0x1a0, 0x02)                            // number of proofs\n\n\n\n            // 0x1c0 = relative offset to 1st entry (0x80, 4 words)\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n\n\n            /**\n\n            * Encoding of proofOutput\n\n            * 0x00 : 0x20 = byte length of `proofOutput` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = relative offset to `bytes inputNotes`\n\n            * 0x40 : 0x60 = relative offset to `bytes outputNotes`\n\n            * 0x60 : 0x80 = publicOwner\n\n            * 0x80 : 0xa0 = publicValue\n\n            * 0xa0 : 0xc0 = challenge\n\n            * 0xc0 : 0xc0 + L1 = `bytes inputNotes` (L1 = 0x140 bytes)\n\n            * 0xc0 + L1 : 0xc0 + L1 + L2 = `bytes inputNotes`\n\n            *\n\n            * Start of proofOutput = 0x200\n\n            **/\n\n\n\n            // length of proofOutput is at 0x200. We don't know that yet, so leave blank\n\n\n\n            // relative offset to inputNotes = 0xc0 (6 words)\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n\n\n            // we know that inputNotes has 1 entry, and input notes don't have metadata.\n\n            // So we actually know the complete size of `bytes inputNotes`\n\n            // (it's 0x140 bytes, we'll get to that in a bit)\n\n            // => relative offset to outputNotes = 0x140 + 0xc0 = 0x200\n\n            mstore(0x240, 0x200)                           // location of outputNotes\n\n\n\n            // bilateral swap proof hardcodes `publicOwner` and `publicValue` to 0 (no public tokens)\n\n            mstore(0x260, 0x00)                             // publicOwner\n\n            mstore(0x280, 0x00)                             // publicValue\n\n            mstore(0x2a0, calldataload(0x124))              // challenge\n\n            /**\n\n            * Encoding of inputNotes\n\n            * 0x00 : 0x20 = byte length of `inputNotes` (0x120)\n\n            * 0x20 : 0x40 = number of input notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st input note (0x60)\n\n            * 0x60 : L    = 1st input note data (L = 0xe0)\n\n            *\n\n            * Start of inputNotes = 0x2a0\n\n            * Because we only have 1 note in this array, and that note has no metadata\n\n            * we know that the size of the note is 0xe0 bytes\n\n            * therefore, the size of inputNotes = 0xe0 + 3 words = 0x140 bytes.\n\n            * We store the byte length as 0x120 bytes because the length parameter\n\n            * of a dynamic bytes array does not include itself in the length calculation\n\n            **/\n\n\n\n            // 0x2c0 = length of inputNotes = 0x120\n\n            mstore(0x2c0, 0x120)\n\n\n\n            // 0x2e0 = number of notes (1)\n\n            mstore(0x2e0, 0x01) // 1 input note\n\n\n\n            // 0x300 = relative offset to input note (0x60)\n\n            mstore(0x300, 0x60) // relative offset to note data\n\n\n\n            /**\n\n            * Encoding of input note\n\n            * 0x00 : 0x20 = byte length of note (0xc0)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            *\n\n            * Start of note = 0x320\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // we use memory from 0x00 - 0xa0 as scratch memory to compute note hash\n\n            // Note hash = keccak256(abi.encode(noteType, gammaX, gammaY, sigmaX, sigmaY))\n\n            mstore(0x00, 0x01) // store noteType at 0x01\n\n\n\n            // We want to copy note coordinate data into memory from 0x20 - 0xa0\n\n            // 'notes' points to the start of the notes array\n\n            // i.e. notes + 0x20 will point to the start of the data of the first entry\n\n            // first two entries are \\bar{k} and \\bar{a}, which we wish to skip over\n\n            // input note is notes[0] => we need to point to notes + 0x60\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // copy gamma, sigma into 0x20 - 0xa0\n\n\n\n            // 0x320 = length of note (0xc0)\n\n            mstore(0x320, 0xc0)\n\n\n\n            // 0x340 = note type (UXTO type, 0x01)\n\n            mstore(0x340, 0x01) // note type\n\n\n\n            // 0x360 = note owners. We want the 1st entry in `noteOwners` (calldataload(noteOwners))\n\n            mstore(0x360, calldataload(noteOwners)) // note owner\n\n\n\n            // 0x380 = note hash, which is the hash of memory from 0x00 - 0xa0\n\n            mstore(0x380, keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // 0x3a0 = noteData length (0x40, no metadata)\n\n            mstore(0x3a0, 0x40)\n\n\n\n            // We now need to store compressed note coordinates.\n\n            // We store them in compressed form, as this stuff will be emitted as an event and is not required\n\n            // for additional smart contract logic. Compressing reduces the event data size and saves a fair bit of gas\n\n\n\n            // To compress, we determine if the y-coordinate is odd.\n\n            // If it is, we set the 256th bit of the x-coordinate to 'true'.\n\n            // bn128 field elements are only 254 bits long, so we know that we won't override x-coordinate data\n\n            // (we already have the note coords in memory, so we load from memory instead of calldata)\n\n\n\n            // 0x3c0 = gamma\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20), // load x coordinate\n\n                    mul(         // multiply by (y & 1 ? 2^255 : 0)\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // 0x3e0 = sigma\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                    and(mload(0x80), 0x01),\n\n                    0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /**\n\n            * Encoding of output notes\n\n            *\n\n            * abi format is identical to input notes, but now we don't know the total size\n\n            * (because of variable length metadata)\n\n            * 0x00 : 0x20 = byte length of `outputNotes` (0x40 + L)\n\n            * 0x20 : 0x40 = number of output notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st output note (0x60)\n\n            * 0x60 : 0x60 + L    = 1st output note data\n\n            *\n\n            * Start of outputNotes = 0x400\n\n            **/\n\n\n\n            // 0x400 = byte length of output notes. We don't know what this is so leave blank for now\n\n\n\n            // 0x420 = number of output notes (0x01)\n\n            mstore(0x420, 0x01)\n\n\n\n            // 0x440 = relative offset to output note data (0x60)\n\n            mstore(0x440, 0x60)\n\n\n\n            /**\n\n            * Encoding of output note\n\n            * 0x00 : 0x20 = byte length of note (0xc0 + L)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40 + L)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            * 0xe0 : 0xe0 + L = note metadata\n\n            *\n\n            * Start of note = 0x460\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // next, copy note coordinates into memory to compute hash.\n\n            // We already stored the noteType at position 0x00, no need to do that again\n\n            // We need to copy data from notes[2].\n\n            // 1. notes + 0x20 = start of 1st entry data\n\n            // 2. size of a note entry = 0xc0 bytes\n\n            // 3. we want to point to 3rd word in our note entry, to skip over \\bar{k}, \\bar{a}\n\n            //    (i.e. add 0x40 to caldlata pointer)\n\n            // => offset = notes + 0x20 + 0x40 + (0xc0 * 2) = notes + 0x1e0\n\n            // => calldata pointer = notes + 0x1e0\n\n            calldatacopy(0x20, add(notes, 0x1e0), 0x80) // get gamma, sigma\n\n\n\n            // 0x460 = byte length of output note. Leave blank for now\n\n\n\n            // 0x480 = note type (0x01)\n\n            mstore(0x480, 0x01)      // note type\n\n\n\n            // 0x4a0 = note owner. We are accessing `notes[2]`, therefore\n\n            // the note owner = noteOwners[2].\n\n            // i.e. noteOwners + 0x40\n\n            mstore(0x4a0, calldataload(add(noteOwners, 0x40))) // note owner\n\n\n\n            // 0x4c0 = note hash\n\n            mstore(0x4c0, keccak256(0x00, 0xa0))\n\n\n\n            // 0x4e0 = noteData length. To get this, we need to identify our metadata length\n\n            // `metadataPtr` points to the relative offset, in the `metadata` array, to the first metadata entry\n\n            // ABI encoding of the input data should encode 2 metadata entries.\n\n            // => relative offset to this note's metadata = `calldataload(metadataPtr)`\n\n            let metadataIndex := calldataload(metadataPtr)\n\n\n\n            // To convert this into a calldata offset, we must add the number of bytes of calldata\n\n            // that preceeds the start of the `metadata` array.\n\n\n\n            // `bytes metadata` abi encoding:\n\n            // 0x00 : 0x20 = size of bytes array\n\n            // 0x20 : 0x40 = number of metadata entries (i)\n\n            // 0x40 : 0x40 + (0x20 * j) = relative offsets to each metadata entry\n\n            // 0x40 + (0x20 * j) : ??? = metadata entries\n\n\n\n            // The `metadata` pointer points to the 3rd word (at 0x40), the 1st relative offset\n\n            // Therefore, to compute the calldata offset to the metadata entry,\n\n            // we need to add `metadataPtr - 0x40` to `calldataload(metadataPtr)`.\n\n            // i.e. metadataCalldataPtr = calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // Because each metadata entry is itself a dynamic bytes array, the first word will\n\n            // be the length of the metadata entry. This is what we want, so we directly call\n\n            // `calldataload` on our offset\n\n            let metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // 0x4e0 = noteData length = 0x40 + metadata length\n\n            mstore(0x4e0, add(0x40, metadataLength))\n\n\n\n            // 0x500 = compressed note coordinate gamma\n\n            mstore(\n\n                0x500,\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // 0x520 = compressed note coordinate sigma\n\n            mstore(\n\n                0x520,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // To complete `noteData`, we need to copy note metadata into memory (0x540)\n\n            // We know that metadataIndex + metadataPtr - 0x40 points to the start of the metadata entry in calldata.\n\n            // But the first word is the length of the metadata entry, which we don't want.\n\n            // So we need to point to the second word (the byte array data).\n\n            // i.e. we want to start copying at (metadataIndex + metadataPtr - 0x20)\n\n            // and we want to copy `metadataLength` number of bytes.\n\n            calldatacopy(0x540, add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // We now need to work backwards and fill in the parts of `bytes proofOutput` that we left blank,\n\n            // as we now can identify the size of the array\n\n\n\n            // 0x460 points to the size of the output note. The actual size is 0xe0 + metadataLength.\n\n            // So we record 0xc0 + metadataLength\n\n            // (because the 'size' of a byte array does not take into account the word needed to record the size)\n\n            mstore(0x460, add(0xc0, metadataLength))  // update size of note\n\n\n\n            // 0x400 = the size of `bytes outputNotes`.\n\n            // Raw size = 0x140 + metadataLength, so record 0x120 + metadataLength\n\n            mstore(0x400, add(0x120, metadataLength)) // update size of outputNotes\n\n\n\n            // 0x200 = the size of `bytes proofOutput`\n\n            // Raw size = 0x340 + metadataLength, so record 0x340 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength))\n\n\n\n            // Great! We've now finished writing the 1st proof output.\n\n            // We now need to write the ABI encoding of the 2nd proof output entry.\n\n\n\n            // 0x1e0 points to the relative offset in `bytes proofOutputs` to the second proof entry.\n\n            // This will be equal to the size of the 1st proof, plus the 0x80 preceeding bytes\n\n            // that are used to record `bytes proofOutputs`\n\n            // i.e. relative offset = 0x340 + 0x80 + metadataLength = 0x3c0 + metadataLength\n\n            mstore(0x1e0, add(0x3c0, metadataLength))\n\n\n\n            /** \n\n            * proofOutput[1]\n\n            **/\n\n\n\n            // When writing data into proofOutputs[1], we cannot use an absolute offset as \n\n            // metadataLength is not known at compile time.\n\n            // `proofPtr` points to the start of `proofOutputs[1]`\n\n            let proofPtr := add(0x540, metadataLength)\n\n\n\n            // (proofPtr) = size of proofOutput (leave blank for now)\n\n\n\n            // (proofPtr + 0x20) = offset to inputNotes (0xc0)\n\n            mstore(add(proofPtr, 0x20), 0xc0)\n\n\n\n            // (proofPtr + 0x40) = offset to outputNotes (0x200)\n\n            mstore(add(proofPtr, 0x40), 0x200)\n\n\n\n            // (proofPtr + 0x60) = publicOwner (0)\n\n            mstore(add(proofPtr, 0x60), 0x00) // publicOwner\n\n\n\n            // (proofPtr + 0x80) = publicValue (0)\n\n            mstore(add(proofPtr, 0x80), 0x00) // publicValue\n\n\n\n            // (proofPtr + 0xa0) = challenge\n\n            // we hash the challenge to get the second proof output's challenge - to preserve uniqueness\n\n            mstore(0xe0, calldataload(0x124))\n\n            mstore(add(proofPtr, 0xa0), keccak256(0xe0, 0x20)) // challenge\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes\n\n            *\n\n            * starts at (proofPtr + 0xc0)\n\n            **/\n\n\n\n            // (proofPtr + 0xc0) = byte size of inputNotes (0x120)\n\n            mstore(add(proofPtr, 0xc0), 0x120)\n\n\n\n            // (proofPtr + 0xe0) = number of input notes (0x01)\n\n            mstore(add(proofPtr, 0xe0), 0x01)\n\n\n\n            // (proofPtr + 0x100) = relative offset to input note data (0x60)\n\n            mstore(add(proofPtr, 0x100), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x120)\n\n            **/\n\n\n\n            // input note = notes[3]\n\n            // => offset = notes + 0x60 + (0xc0 * 3) = notes + 0x2a0\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x2a0), 0x80)\n\n\n\n            // (proofPtr + 0x120) = byte length of input note (0xc0)\n\n            mstore(add(proofPtr, 0x120), 0xc0) // length of input note\n\n\n\n            // (proofPtr + 0x140) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x140), 0x01) // note type\n\n\n\n            // (proofPtr + 0x160) = note owner = noteOwners[3]\n\n            mstore(add(proofPtr, 0x160), calldataload(add(noteOwners, 0x60))) // note owner\n\n\n\n            // (proofPtr + 0x180) = note hash\n\n            mstore(add(proofPtr, 0x180), keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // (proofPtr + 0x1a0) = noteData length (0x40 bytes)\n\n            mstore(add(proofPtr, 0x1a0), 0x40)\n\n\n\n            // (proofPtr + 0x1c0) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x1c0),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x1e0) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x1e0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes\n\n            *\n\n            * starts at (proofPtr + 0x200)\n\n            **/\n\n\n\n            // (proofPtr + 0x200) = byte length of output notes, leave blank for now\n\n\n\n            // (proofPtr + 0x220) = number of output notes (0x01)\n\n            mstore(add(proofPtr, 0x220), 0x01)\n\n\n\n            // (proofPtr + 0x240) = offset to output notes (0x60)\n\n            mstore(add(proofPtr, 0x240), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x260)\n\n            **/\n\n            // output note = notes[1]\n\n            // => offset = notes + 0x60 + 0xc0 = notes + 0x120\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80)\n\n\n\n            // (proofPtr + 0x260) = length of note, leave blank for now\n\n\n\n            // (proofPtr + 0x280) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x280), 0x01) // note type\n\n\n\n            // (proofPtr + 0x2a0) = note owner (noteOwners[1])\n\n            mstore(add(proofPtr, 0x2a0), calldataload(add(noteOwners, 0x20)))\n\n\n\n            // (proofPtr + 0x2c0) = note hash\n\n            mstore(add(proofPtr, 0x2c0), keccak256(0x00, 0xa0))\n\n\n\n            // We now need to compute the metadata length. We want to access the 2nd metadata entry,\n\n            // at (metadataPtr + 0x20)\n\n            metadataIndex := calldataload(add(metadataPtr, 0x20))\n\n            metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // (proofPtr + 0x2e0) = noteData length (0x40 + metadataLength)\n\n            mstore(add(proofPtr, 0x2e0), add(0x40, metadataLength))\n\n\n\n            // (proofPtr + 0x300) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x300),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x320) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x320),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x340) = start of note metadata\n\n            calldatacopy(add(proofPtr, 0x340), add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // Next, work backwards and fill in the remaining gaps\n\n            // (proofPtr + 0x260) = proofOutputs[1].outputNotes[0].length (0xc0 + metadataLength)\n\n            mstore(add(proofPtr, 0x260), add(0xc0, metadataLength))\n\n\n\n            // (proofPtr + 0x200) = proofOutputs[1].outputNotes.length (0x120 + metadataLength)\n\n            mstore(add(proofPtr, 0x200), add(0x120, metadataLength))\n\n\n\n            // (proofPtr) = proofOutputs[1].length = (0x320 + metadataLength)\n\n            mstore(proofPtr, add(0x320, metadataLength))\n\n\n\n            // (0x180) = proofOutputs.length\n\n            // We previously stored proofOutputs[0].length at 0x200\n\n            // Total length = combination of\n\n            // 1. proofOutputs[0].length + 0x20 (extra word because of length variable)\n\n            // 2. proofOutputs[1].length + 0x20 (^^)\n\n            // 3. data to record relative offsets (0x20 * number of outputs) = (0x40)\n\n            // 4. data to record number of entries (0x20)\n\n            \n\n            // We stored proofOutputs[0].length at 0x200\n\n            // and we know that proofOutputs[1].length = 0x320 + metadataLength\n\n            // => length = mload(0x200) + metadataLength + 0x320 + 0x40 + 0x40 + 0x20\n\n            // => length = mload(0x200) + metadataLength + 0x3c0\n\n            mstore(0x180, add(add(0x3c0, metadataLength), mload(0x200)))\n\n\n\n            // Great, we've done it! Now all that is left is to return from this transaction.\n\n            // Our return data starts at 0x160.\n\n            // Total size of `bytes proofOutpust` = proofOutputs.length + 0x20\n\n            // We need 1 extra word (at 0x160) for the relative offset to get to `bytes proofOutputs`\n\n            // => returndata size = proofOutputs.length + 0x40\n\n            // = mload(0x180) + 0x40\n\n            return(0x160, add(mload(0x180), 0x40)) // *kazoo noises*\n\n        }\n",
                    "message": "BilateralSwapABIEncoder.encodeAndExit (BilateralSwapABIEncoder.sol#38-604) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 604,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let noteOwners := add(0x124, calldataload(0x164)) // // one word after inputOwners = 1st\n\n            let metadataPtr := add(0x144, calldataload(0x184)) // two words after metadata = 1st\n\n\n\n            // First up, we need to do some checks to ensure we have been provided with correct data.\n\n            // We should only have 2 entries inside `bytes metadata` (only 2 output notes in total),\n\n            // and only 4 entries inside `noteOwners` (4 notes in bilateral swap proof)\n\n            if iszero(and(\n\n                eq(0x02, calldataload(sub(metadataPtr, 0x20))),\n\n                eq(0x04, calldataload(sub(noteOwners, 0x20)))\n\n            )) {\n\n                revert(0x00, 0x00) // no! bad! come back with good inputs!\n\n            }\n\n\n\n            // memory map of `proofOutputs`\n\n            // 0x00 - 0x160  = scratch data for note hash computation\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            // 0x1e0 - 0x200 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n    \n\n            // `proofOutput` - t, starts at 0x200\n\n            // 0x200 - 0x220 = length of `proofOutput`\n\n            // 0x220 - 0x240 = relative offset between `t` and `inputNotes`\n\n            // 0x240 - 0x260 = relative offset between `t` and `outputNotes`\n\n            // 0x260 - 0x280 = `publicOwner`\n\n            // 0x280 - 0x2a0 = `publicValue`\n\n            // 0x2a0 - 0x2c0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x2c0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes = 1\n\n            // 0x40 - 0x60 = offset to start of input note (0x60)\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `owner`\n\n            // 0x40 - 0x60 = `noteHash`\n\n            // 0x60 - 0x80 = size of note `data`\n\n            // 0x80 - 0xa0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xa0 - 0xc0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xc0 - ???? = remaining note metadata\n\n\n\n            // Note organisation...\n\n            // The bilateral swap proof proves the following:\n\n            //   1. note[0].value == note[2].value\n\n            //   2. note[1].value == note[3].value\n\n            // In other words...\n\n            // note[0] = maker bid note\n\n            // note[1] = maker ask note\n\n            // note[2] = taker ask note\n\n            // note[3] = taker bid note\n\n\n\n            // We therefore have 2 balancing relationships\n\n            // 1. The maker bid note is destroyed and replaced with the taker ask note\n\n            // 2. The taker bid note is destroyed and replaced with the maker ask note\n\n\n\n            // Finally, we can translate this into 2 proofOutputs entries...\n\n            // In the first entry, `inputNotes` = [note[0]] and `outputNotes` = [note[2]]\n\n            // In the second entry, `inputNotes` = [note[3]] and `outputNotes` = [note[1]]\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at 0x180\n\n\n\n            // we use memory from 0x00 - 0x140 as scratch memory\n\n\n\n            // return data starts at 0x160. As return data is `bytes proofOutputs`,\n\n            // the first word is the relative offset to the start of `proofOutputs` (i.e. 0x20)\n\n            mstore(0x160, 0x20)\n\n\n\n            /**\n\n            * Encoding of proofOutputs\n\n            * abi encoding of proofOutputs\n\n            * 0x00 : 0x20 = byte length of `proofOutputs` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = number of `proofOutputs` entries (2)\n\n            * 0x40 : 0x60 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            * 0x60 : 0x80 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n            * 0x80 : 0x80 + L1    = start of proofOutputs[0]\n\n            * 0x80 + L1   : 0x80 + L1 + L2 = start of proofOutputs[1]\n\n            **/\n\n        \n\n            // 0x180 stores the total size of `bytes proofOutputs`. We don't know that yet, so leave blank\n\n\n\n            // 0x1a0 = number of proof outputs (2)\n\n            mstore(0x1a0, 0x02)                            // number of proofs\n\n\n\n            // 0x1c0 = relative offset to 1st entry (0x80, 4 words)\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n\n\n            /**\n\n            * Encoding of proofOutput\n\n            * 0x00 : 0x20 = byte length of `proofOutput` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = relative offset to `bytes inputNotes`\n\n            * 0x40 : 0x60 = relative offset to `bytes outputNotes`\n\n            * 0x60 : 0x80 = publicOwner\n\n            * 0x80 : 0xa0 = publicValue\n\n            * 0xa0 : 0xc0 = challenge\n\n            * 0xc0 : 0xc0 + L1 = `bytes inputNotes` (L1 = 0x140 bytes)\n\n            * 0xc0 + L1 : 0xc0 + L1 + L2 = `bytes inputNotes`\n\n            *\n\n            * Start of proofOutput = 0x200\n\n            **/\n\n\n\n            // length of proofOutput is at 0x200. We don't know that yet, so leave blank\n\n\n\n            // relative offset to inputNotes = 0xc0 (6 words)\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n\n\n            // we know that inputNotes has 1 entry, and input notes don't have metadata.\n\n            // So we actually know the complete size of `bytes inputNotes`\n\n            // (it's 0x140 bytes, we'll get to that in a bit)\n\n            // => relative offset to outputNotes = 0x140 + 0xc0 = 0x200\n\n            mstore(0x240, 0x200)                           // location of outputNotes\n\n\n\n            // bilateral swap proof hardcodes `publicOwner` and `publicValue` to 0 (no public tokens)\n\n            mstore(0x260, 0x00)                             // publicOwner\n\n            mstore(0x280, 0x00)                             // publicValue\n\n            mstore(0x2a0, calldataload(0x124))              // challenge\n\n            /**\n\n            * Encoding of inputNotes\n\n            * 0x00 : 0x20 = byte length of `inputNotes` (0x120)\n\n            * 0x20 : 0x40 = number of input notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st input note (0x60)\n\n            * 0x60 : L    = 1st input note data (L = 0xe0)\n\n            *\n\n            * Start of inputNotes = 0x2a0\n\n            * Because we only have 1 note in this array, and that note has no metadata\n\n            * we know that the size of the note is 0xe0 bytes\n\n            * therefore, the size of inputNotes = 0xe0 + 3 words = 0x140 bytes.\n\n            * We store the byte length as 0x120 bytes because the length parameter\n\n            * of a dynamic bytes array does not include itself in the length calculation\n\n            **/\n\n\n\n            // 0x2c0 = length of inputNotes = 0x120\n\n            mstore(0x2c0, 0x120)\n\n\n\n            // 0x2e0 = number of notes (1)\n\n            mstore(0x2e0, 0x01) // 1 input note\n\n\n\n            // 0x300 = relative offset to input note (0x60)\n\n            mstore(0x300, 0x60) // relative offset to note data\n\n\n\n            /**\n\n            * Encoding of input note\n\n            * 0x00 : 0x20 = byte length of note (0xc0)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            *\n\n            * Start of note = 0x320\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // we use memory from 0x00 - 0xa0 as scratch memory to compute note hash\n\n            // Note hash = keccak256(abi.encode(noteType, gammaX, gammaY, sigmaX, sigmaY))\n\n            mstore(0x00, 0x01) // store noteType at 0x01\n\n\n\n            // We want to copy note coordinate data into memory from 0x20 - 0xa0\n\n            // 'notes' points to the start of the notes array\n\n            // i.e. notes + 0x20 will point to the start of the data of the first entry\n\n            // first two entries are \\bar{k} and \\bar{a}, which we wish to skip over\n\n            // input note is notes[0] => we need to point to notes + 0x60\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // copy gamma, sigma into 0x20 - 0xa0\n\n\n\n            // 0x320 = length of note (0xc0)\n\n            mstore(0x320, 0xc0)\n\n\n\n            // 0x340 = note type (UXTO type, 0x01)\n\n            mstore(0x340, 0x01) // note type\n\n\n\n            // 0x360 = note owners. We want the 1st entry in `noteOwners` (calldataload(noteOwners))\n\n            mstore(0x360, calldataload(noteOwners)) // note owner\n\n\n\n            // 0x380 = note hash, which is the hash of memory from 0x00 - 0xa0\n\n            mstore(0x380, keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // 0x3a0 = noteData length (0x40, no metadata)\n\n            mstore(0x3a0, 0x40)\n\n\n\n            // We now need to store compressed note coordinates.\n\n            // We store them in compressed form, as this stuff will be emitted as an event and is not required\n\n            // for additional smart contract logic. Compressing reduces the event data size and saves a fair bit of gas\n\n\n\n            // To compress, we determine if the y-coordinate is odd.\n\n            // If it is, we set the 256th bit of the x-coordinate to 'true'.\n\n            // bn128 field elements are only 254 bits long, so we know that we won't override x-coordinate data\n\n            // (we already have the note coords in memory, so we load from memory instead of calldata)\n\n\n\n            // 0x3c0 = gamma\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20), // load x coordinate\n\n                    mul(         // multiply by (y & 1 ? 2^255 : 0)\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // 0x3e0 = sigma\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                    and(mload(0x80), 0x01),\n\n                    0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /**\n\n            * Encoding of output notes\n\n            *\n\n            * abi format is identical to input notes, but now we don't know the total size\n\n            * (because of variable length metadata)\n\n            * 0x00 : 0x20 = byte length of `outputNotes` (0x40 + L)\n\n            * 0x20 : 0x40 = number of output notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st output note (0x60)\n\n            * 0x60 : 0x60 + L    = 1st output note data\n\n            *\n\n            * Start of outputNotes = 0x400\n\n            **/\n\n\n\n            // 0x400 = byte length of output notes. We don't know what this is so leave blank for now\n\n\n\n            // 0x420 = number of output notes (0x01)\n\n            mstore(0x420, 0x01)\n\n\n\n            // 0x440 = relative offset to output note data (0x60)\n\n            mstore(0x440, 0x60)\n\n\n\n            /**\n\n            * Encoding of output note\n\n            * 0x00 : 0x20 = byte length of note (0xc0 + L)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40 + L)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            * 0xe0 : 0xe0 + L = note metadata\n\n            *\n\n            * Start of note = 0x460\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // next, copy note coordinates into memory to compute hash.\n\n            // We already stored the noteType at position 0x00, no need to do that again\n\n            // We need to copy data from notes[2].\n\n            // 1. notes + 0x20 = start of 1st entry data\n\n            // 2. size of a note entry = 0xc0 bytes\n\n            // 3. we want to point to 3rd word in our note entry, to skip over \\bar{k}, \\bar{a}\n\n            //    (i.e. add 0x40 to caldlata pointer)\n\n            // => offset = notes + 0x20 + 0x40 + (0xc0 * 2) = notes + 0x1e0\n\n            // => calldata pointer = notes + 0x1e0\n\n            calldatacopy(0x20, add(notes, 0x1e0), 0x80) // get gamma, sigma\n\n\n\n            // 0x460 = byte length of output note. Leave blank for now\n\n\n\n            // 0x480 = note type (0x01)\n\n            mstore(0x480, 0x01)      // note type\n\n\n\n            // 0x4a0 = note owner. We are accessing `notes[2]`, therefore\n\n            // the note owner = noteOwners[2].\n\n            // i.e. noteOwners + 0x40\n\n            mstore(0x4a0, calldataload(add(noteOwners, 0x40))) // note owner\n\n\n\n            // 0x4c0 = note hash\n\n            mstore(0x4c0, keccak256(0x00, 0xa0))\n\n\n\n            // 0x4e0 = noteData length. To get this, we need to identify our metadata length\n\n            // `metadataPtr` points to the relative offset, in the `metadata` array, to the first metadata entry\n\n            // ABI encoding of the input data should encode 2 metadata entries.\n\n            // => relative offset to this note's metadata = `calldataload(metadataPtr)`\n\n            let metadataIndex := calldataload(metadataPtr)\n\n\n\n            // To convert this into a calldata offset, we must add the number of bytes of calldata\n\n            // that preceeds the start of the `metadata` array.\n\n\n\n            // `bytes metadata` abi encoding:\n\n            // 0x00 : 0x20 = size of bytes array\n\n            // 0x20 : 0x40 = number of metadata entries (i)\n\n            // 0x40 : 0x40 + (0x20 * j) = relative offsets to each metadata entry\n\n            // 0x40 + (0x20 * j) : ??? = metadata entries\n\n\n\n            // The `metadata` pointer points to the 3rd word (at 0x40), the 1st relative offset\n\n            // Therefore, to compute the calldata offset to the metadata entry,\n\n            // we need to add `metadataPtr - 0x40` to `calldataload(metadataPtr)`.\n\n            // i.e. metadataCalldataPtr = calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // Because each metadata entry is itself a dynamic bytes array, the first word will\n\n            // be the length of the metadata entry. This is what we want, so we directly call\n\n            // `calldataload` on our offset\n\n            let metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // 0x4e0 = noteData length = 0x40 + metadata length\n\n            mstore(0x4e0, add(0x40, metadataLength))\n\n\n\n            // 0x500 = compressed note coordinate gamma\n\n            mstore(\n\n                0x500,\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // 0x520 = compressed note coordinate sigma\n\n            mstore(\n\n                0x520,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // To complete `noteData`, we need to copy note metadata into memory (0x540)\n\n            // We know that metadataIndex + metadataPtr - 0x40 points to the start of the metadata entry in calldata.\n\n            // But the first word is the length of the metadata entry, which we don't want.\n\n            // So we need to point to the second word (the byte array data).\n\n            // i.e. we want to start copying at (metadataIndex + metadataPtr - 0x20)\n\n            // and we want to copy `metadataLength` number of bytes.\n\n            calldatacopy(0x540, add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // We now need to work backwards and fill in the parts of `bytes proofOutput` that we left blank,\n\n            // as we now can identify the size of the array\n\n\n\n            // 0x460 points to the size of the output note. The actual size is 0xe0 + metadataLength.\n\n            // So we record 0xc0 + metadataLength\n\n            // (because the 'size' of a byte array does not take into account the word needed to record the size)\n\n            mstore(0x460, add(0xc0, metadataLength))  // update size of note\n\n\n\n            // 0x400 = the size of `bytes outputNotes`.\n\n            // Raw size = 0x140 + metadataLength, so record 0x120 + metadataLength\n\n            mstore(0x400, add(0x120, metadataLength)) // update size of outputNotes\n\n\n\n            // 0x200 = the size of `bytes proofOutput`\n\n            // Raw size = 0x340 + metadataLength, so record 0x340 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength))\n\n\n\n            // Great! We've now finished writing the 1st proof output.\n\n            // We now need to write the ABI encoding of the 2nd proof output entry.\n\n\n\n            // 0x1e0 points to the relative offset in `bytes proofOutputs` to the second proof entry.\n\n            // This will be equal to the size of the 1st proof, plus the 0x80 preceeding bytes\n\n            // that are used to record `bytes proofOutputs`\n\n            // i.e. relative offset = 0x340 + 0x80 + metadataLength = 0x3c0 + metadataLength\n\n            mstore(0x1e0, add(0x3c0, metadataLength))\n\n\n\n            /** \n\n            * proofOutput[1]\n\n            **/\n\n\n\n            // When writing data into proofOutputs[1], we cannot use an absolute offset as \n\n            // metadataLength is not known at compile time.\n\n            // `proofPtr` points to the start of `proofOutputs[1]`\n\n            let proofPtr := add(0x540, metadataLength)\n\n\n\n            // (proofPtr) = size of proofOutput (leave blank for now)\n\n\n\n            // (proofPtr + 0x20) = offset to inputNotes (0xc0)\n\n            mstore(add(proofPtr, 0x20), 0xc0)\n\n\n\n            // (proofPtr + 0x40) = offset to outputNotes (0x200)\n\n            mstore(add(proofPtr, 0x40), 0x200)\n\n\n\n            // (proofPtr + 0x60) = publicOwner (0)\n\n            mstore(add(proofPtr, 0x60), 0x00) // publicOwner\n\n\n\n            // (proofPtr + 0x80) = publicValue (0)\n\n            mstore(add(proofPtr, 0x80), 0x00) // publicValue\n\n\n\n            // (proofPtr + 0xa0) = challenge\n\n            // we hash the challenge to get the second proof output's challenge - to preserve uniqueness\n\n            mstore(0xe0, calldataload(0x124))\n\n            mstore(add(proofPtr, 0xa0), keccak256(0xe0, 0x20)) // challenge\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes\n\n            *\n\n            * starts at (proofPtr + 0xc0)\n\n            **/\n\n\n\n            // (proofPtr + 0xc0) = byte size of inputNotes (0x120)\n\n            mstore(add(proofPtr, 0xc0), 0x120)\n\n\n\n            // (proofPtr + 0xe0) = number of input notes (0x01)\n\n            mstore(add(proofPtr, 0xe0), 0x01)\n\n\n\n            // (proofPtr + 0x100) = relative offset to input note data (0x60)\n\n            mstore(add(proofPtr, 0x100), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x120)\n\n            **/\n\n\n\n            // input note = notes[3]\n\n            // => offset = notes + 0x60 + (0xc0 * 3) = notes + 0x2a0\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x2a0), 0x80)\n\n\n\n            // (proofPtr + 0x120) = byte length of input note (0xc0)\n\n            mstore(add(proofPtr, 0x120), 0xc0) // length of input note\n\n\n\n            // (proofPtr + 0x140) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x140), 0x01) // note type\n\n\n\n            // (proofPtr + 0x160) = note owner = noteOwners[3]\n\n            mstore(add(proofPtr, 0x160), calldataload(add(noteOwners, 0x60))) // note owner\n\n\n\n            // (proofPtr + 0x180) = note hash\n\n            mstore(add(proofPtr, 0x180), keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // (proofPtr + 0x1a0) = noteData length (0x40 bytes)\n\n            mstore(add(proofPtr, 0x1a0), 0x40)\n\n\n\n            // (proofPtr + 0x1c0) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x1c0),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x1e0) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x1e0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes\n\n            *\n\n            * starts at (proofPtr + 0x200)\n\n            **/\n\n\n\n            // (proofPtr + 0x200) = byte length of output notes, leave blank for now\n\n\n\n            // (proofPtr + 0x220) = number of output notes (0x01)\n\n            mstore(add(proofPtr, 0x220), 0x01)\n\n\n\n            // (proofPtr + 0x240) = offset to output notes (0x60)\n\n            mstore(add(proofPtr, 0x240), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x260)\n\n            **/\n\n            // output note = notes[1]\n\n            // => offset = notes + 0x60 + 0xc0 = notes + 0x120\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80)\n\n\n\n            // (proofPtr + 0x260) = length of note, leave blank for now\n\n\n\n            // (proofPtr + 0x280) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x280), 0x01) // note type\n\n\n\n            // (proofPtr + 0x2a0) = note owner (noteOwners[1])\n\n            mstore(add(proofPtr, 0x2a0), calldataload(add(noteOwners, 0x20)))\n\n\n\n            // (proofPtr + 0x2c0) = note hash\n\n            mstore(add(proofPtr, 0x2c0), keccak256(0x00, 0xa0))\n\n\n\n            // We now need to compute the metadata length. We want to access the 2nd metadata entry,\n\n            // at (metadataPtr + 0x20)\n\n            metadataIndex := calldataload(add(metadataPtr, 0x20))\n\n            metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // (proofPtr + 0x2e0) = noteData length (0x40 + metadataLength)\n\n            mstore(add(proofPtr, 0x2e0), add(0x40, metadataLength))\n\n\n\n            // (proofPtr + 0x300) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x300),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x320) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x320),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x340) = start of note metadata\n\n            calldatacopy(add(proofPtr, 0x340), add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // Next, work backwards and fill in the remaining gaps\n\n            // (proofPtr + 0x260) = proofOutputs[1].outputNotes[0].length (0xc0 + metadataLength)\n\n            mstore(add(proofPtr, 0x260), add(0xc0, metadataLength))\n\n\n\n            // (proofPtr + 0x200) = proofOutputs[1].outputNotes.length (0x120 + metadataLength)\n\n            mstore(add(proofPtr, 0x200), add(0x120, metadataLength))\n\n\n\n            // (proofPtr) = proofOutputs[1].length = (0x320 + metadataLength)\n\n            mstore(proofPtr, add(0x320, metadataLength))\n\n\n\n            // (0x180) = proofOutputs.length\n\n            // We previously stored proofOutputs[0].length at 0x200\n\n            // Total length = combination of\n\n            // 1. proofOutputs[0].length + 0x20 (extra word because of length variable)\n\n            // 2. proofOutputs[1].length + 0x20 (^^)\n\n            // 3. data to record relative offsets (0x20 * number of outputs) = (0x40)\n\n            // 4. data to record number of entries (0x20)\n\n            \n\n            // We stored proofOutputs[0].length at 0x200\n\n            // and we know that proofOutputs[1].length = 0x320 + metadataLength\n\n            // => length = mload(0x200) + metadataLength + 0x320 + 0x40 + 0x40 + 0x20\n\n            // => length = mload(0x200) + metadataLength + 0x3c0\n\n            mstore(0x180, add(add(0x3c0, metadataLength), mload(0x200)))\n\n\n\n            // Great, we've done it! Now all that is left is to return from this transaction.\n\n            // Our return data starts at 0x160.\n\n            // Total size of `bytes proofOutpust` = proofOutputs.length + 0x20\n\n            // We need 1 extra word (at 0x160) for the relative offset to get to `bytes proofOutputs`\n\n            // => returndata size = proofOutputs.length + 0x40\n\n            // = mload(0x180) + 0x40\n\n            return(0x160, add(mload(0x180), 0x40)) // *kazoo noises*\n\n        }\n",
                    "message": "BilateralSwapABIEncoder.encodeAndExit uses assembly (BilateralSwapABIEncoder.sol#38-604)\n\t- BilateralSwapABIEncoder.sol#39-603\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in BilateralSwapABIEncoder.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (BilateralSwapABIEncoder.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/ACE/validators/bilateralSwap/BilateralSwapABIEncoderTest.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 604,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let noteOwners := add(0x124, calldataload(0x164)) // // one word after inputOwners = 1st\n\n            let metadataPtr := add(0x144, calldataload(0x184)) // two words after metadata = 1st\n\n\n\n            // First up, we need to do some checks to ensure we have been provided with correct data.\n\n            // We should only have 2 entries inside `bytes metadata` (only 2 output notes in total),\n\n            // and only 4 entries inside `noteOwners` (4 notes in bilateral swap proof)\n\n            if iszero(and(\n\n                eq(0x02, calldataload(sub(metadataPtr, 0x20))),\n\n                eq(0x04, calldataload(sub(noteOwners, 0x20)))\n\n            )) {\n\n                revert(0x00, 0x00) // no! bad! come back with good inputs!\n\n            }\n\n\n\n            // memory map of `proofOutputs`\n\n            // 0x00 - 0x160  = scratch data for note hash computation\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            // 0x1e0 - 0x200 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n    \n\n            // `proofOutput` - t, starts at 0x200\n\n            // 0x200 - 0x220 = length of `proofOutput`\n\n            // 0x220 - 0x240 = relative offset between `t` and `inputNotes`\n\n            // 0x240 - 0x260 = relative offset between `t` and `outputNotes`\n\n            // 0x260 - 0x280 = `publicOwner`\n\n            // 0x280 - 0x2a0 = `publicValue`\n\n            // 0x2a0 - 0x2c0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x2c0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes = 1\n\n            // 0x40 - 0x60 = offset to start of input note (0x60)\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `owner`\n\n            // 0x40 - 0x60 = `noteHash`\n\n            // 0x60 - 0x80 = size of note `data`\n\n            // 0x80 - 0xa0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xa0 - 0xc0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xc0 - ???? = remaining note metadata\n\n\n\n            // Note organisation...\n\n            // The bilateral swap proof proves the following:\n\n            //   1. note[0].value == note[2].value\n\n            //   2. note[1].value == note[3].value\n\n            // In other words...\n\n            // note[0] = maker bid note\n\n            // note[1] = maker ask note\n\n            // note[2] = taker ask note\n\n            // note[3] = taker bid note\n\n\n\n            // We therefore have 2 balancing relationships\n\n            // 1. The maker bid note is destroyed and replaced with the taker ask note\n\n            // 2. The taker bid note is destroyed and replaced with the maker ask note\n\n\n\n            // Finally, we can translate this into 2 proofOutputs entries...\n\n            // In the first entry, `inputNotes` = [note[0]] and `outputNotes` = [note[2]]\n\n            // In the second entry, `inputNotes` = [note[3]] and `outputNotes` = [note[1]]\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at 0x180\n\n\n\n            // we use memory from 0x00 - 0x140 as scratch memory\n\n\n\n            // return data starts at 0x160. As return data is `bytes proofOutputs`,\n\n            // the first word is the relative offset to the start of `proofOutputs` (i.e. 0x20)\n\n            mstore(0x160, 0x20)\n\n\n\n            /**\n\n            * Encoding of proofOutputs\n\n            * abi encoding of proofOutputs\n\n            * 0x00 : 0x20 = byte length of `proofOutputs` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = number of `proofOutputs` entries (2)\n\n            * 0x40 : 0x60 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            * 0x60 : 0x80 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n            * 0x80 : 0x80 + L1    = start of proofOutputs[0]\n\n            * 0x80 + L1   : 0x80 + L1 + L2 = start of proofOutputs[1]\n\n            **/\n\n        \n\n            // 0x180 stores the total size of `bytes proofOutputs`. We don't know that yet, so leave blank\n\n\n\n            // 0x1a0 = number of proof outputs (2)\n\n            mstore(0x1a0, 0x02)                            // number of proofs\n\n\n\n            // 0x1c0 = relative offset to 1st entry (0x80, 4 words)\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n\n\n            /**\n\n            * Encoding of proofOutput\n\n            * 0x00 : 0x20 = byte length of `proofOutput` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = relative offset to `bytes inputNotes`\n\n            * 0x40 : 0x60 = relative offset to `bytes outputNotes`\n\n            * 0x60 : 0x80 = publicOwner\n\n            * 0x80 : 0xa0 = publicValue\n\n            * 0xa0 : 0xc0 = challenge\n\n            * 0xc0 : 0xc0 + L1 = `bytes inputNotes` (L1 = 0x140 bytes)\n\n            * 0xc0 + L1 : 0xc0 + L1 + L2 = `bytes inputNotes`\n\n            *\n\n            * Start of proofOutput = 0x200\n\n            **/\n\n\n\n            // length of proofOutput is at 0x200. We don't know that yet, so leave blank\n\n\n\n            // relative offset to inputNotes = 0xc0 (6 words)\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n\n\n            // we know that inputNotes has 1 entry, and input notes don't have metadata.\n\n            // So we actually know the complete size of `bytes inputNotes`\n\n            // (it's 0x140 bytes, we'll get to that in a bit)\n\n            // => relative offset to outputNotes = 0x140 + 0xc0 = 0x200\n\n            mstore(0x240, 0x200)                           // location of outputNotes\n\n\n\n            // bilateral swap proof hardcodes `publicOwner` and `publicValue` to 0 (no public tokens)\n\n            mstore(0x260, 0x00)                             // publicOwner\n\n            mstore(0x280, 0x00)                             // publicValue\n\n            mstore(0x2a0, calldataload(0x124))              // challenge\n\n            /**\n\n            * Encoding of inputNotes\n\n            * 0x00 : 0x20 = byte length of `inputNotes` (0x120)\n\n            * 0x20 : 0x40 = number of input notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st input note (0x60)\n\n            * 0x60 : L    = 1st input note data (L = 0xe0)\n\n            *\n\n            * Start of inputNotes = 0x2a0\n\n            * Because we only have 1 note in this array, and that note has no metadata\n\n            * we know that the size of the note is 0xe0 bytes\n\n            * therefore, the size of inputNotes = 0xe0 + 3 words = 0x140 bytes.\n\n            * We store the byte length as 0x120 bytes because the length parameter\n\n            * of a dynamic bytes array does not include itself in the length calculation\n\n            **/\n\n\n\n            // 0x2c0 = length of inputNotes = 0x120\n\n            mstore(0x2c0, 0x120)\n\n\n\n            // 0x2e0 = number of notes (1)\n\n            mstore(0x2e0, 0x01) // 1 input note\n\n\n\n            // 0x300 = relative offset to input note (0x60)\n\n            mstore(0x300, 0x60) // relative offset to note data\n\n\n\n            /**\n\n            * Encoding of input note\n\n            * 0x00 : 0x20 = byte length of note (0xc0)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            *\n\n            * Start of note = 0x320\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // we use memory from 0x00 - 0xa0 as scratch memory to compute note hash\n\n            // Note hash = keccak256(abi.encode(noteType, gammaX, gammaY, sigmaX, sigmaY))\n\n            mstore(0x00, 0x01) // store noteType at 0x01\n\n\n\n            // We want to copy note coordinate data into memory from 0x20 - 0xa0\n\n            // 'notes' points to the start of the notes array\n\n            // i.e. notes + 0x20 will point to the start of the data of the first entry\n\n            // first two entries are \\bar{k} and \\bar{a}, which we wish to skip over\n\n            // input note is notes[0] => we need to point to notes + 0x60\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // copy gamma, sigma into 0x20 - 0xa0\n\n\n\n            // 0x320 = length of note (0xc0)\n\n            mstore(0x320, 0xc0)\n\n\n\n            // 0x340 = note type (UXTO type, 0x01)\n\n            mstore(0x340, 0x01) // note type\n\n\n\n            // 0x360 = note owners. We want the 1st entry in `noteOwners` (calldataload(noteOwners))\n\n            mstore(0x360, calldataload(noteOwners)) // note owner\n\n\n\n            // 0x380 = note hash, which is the hash of memory from 0x00 - 0xa0\n\n            mstore(0x380, keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // 0x3a0 = noteData length (0x40, no metadata)\n\n            mstore(0x3a0, 0x40)\n\n\n\n            // We now need to store compressed note coordinates.\n\n            // We store them in compressed form, as this stuff will be emitted as an event and is not required\n\n            // for additional smart contract logic. Compressing reduces the event data size and saves a fair bit of gas\n\n\n\n            // To compress, we determine if the y-coordinate is odd.\n\n            // If it is, we set the 256th bit of the x-coordinate to 'true'.\n\n            // bn128 field elements are only 254 bits long, so we know that we won't override x-coordinate data\n\n            // (we already have the note coords in memory, so we load from memory instead of calldata)\n\n\n\n            // 0x3c0 = gamma\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20), // load x coordinate\n\n                    mul(         // multiply by (y & 1 ? 2^255 : 0)\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // 0x3e0 = sigma\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                    and(mload(0x80), 0x01),\n\n                    0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /**\n\n            * Encoding of output notes\n\n            *\n\n            * abi format is identical to input notes, but now we don't know the total size\n\n            * (because of variable length metadata)\n\n            * 0x00 : 0x20 = byte length of `outputNotes` (0x40 + L)\n\n            * 0x20 : 0x40 = number of output notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st output note (0x60)\n\n            * 0x60 : 0x60 + L    = 1st output note data\n\n            *\n\n            * Start of outputNotes = 0x400\n\n            **/\n\n\n\n            // 0x400 = byte length of output notes. We don't know what this is so leave blank for now\n\n\n\n            // 0x420 = number of output notes (0x01)\n\n            mstore(0x420, 0x01)\n\n\n\n            // 0x440 = relative offset to output note data (0x60)\n\n            mstore(0x440, 0x60)\n\n\n\n            /**\n\n            * Encoding of output note\n\n            * 0x00 : 0x20 = byte length of note (0xc0 + L)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40 + L)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            * 0xe0 : 0xe0 + L = note metadata\n\n            *\n\n            * Start of note = 0x460\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // next, copy note coordinates into memory to compute hash.\n\n            // We already stored the noteType at position 0x00, no need to do that again\n\n            // We need to copy data from notes[2].\n\n            // 1. notes + 0x20 = start of 1st entry data\n\n            // 2. size of a note entry = 0xc0 bytes\n\n            // 3. we want to point to 3rd word in our note entry, to skip over \\bar{k}, \\bar{a}\n\n            //    (i.e. add 0x40 to caldlata pointer)\n\n            // => offset = notes + 0x20 + 0x40 + (0xc0 * 2) = notes + 0x1e0\n\n            // => calldata pointer = notes + 0x1e0\n\n            calldatacopy(0x20, add(notes, 0x1e0), 0x80) // get gamma, sigma\n\n\n\n            // 0x460 = byte length of output note. Leave blank for now\n\n\n\n            // 0x480 = note type (0x01)\n\n            mstore(0x480, 0x01)      // note type\n\n\n\n            // 0x4a0 = note owner. We are accessing `notes[2]`, therefore\n\n            // the note owner = noteOwners[2].\n\n            // i.e. noteOwners + 0x40\n\n            mstore(0x4a0, calldataload(add(noteOwners, 0x40))) // note owner\n\n\n\n            // 0x4c0 = note hash\n\n            mstore(0x4c0, keccak256(0x00, 0xa0))\n\n\n\n            // 0x4e0 = noteData length. To get this, we need to identify our metadata length\n\n            // `metadataPtr` points to the relative offset, in the `metadata` array, to the first metadata entry\n\n            // ABI encoding of the input data should encode 2 metadata entries.\n\n            // => relative offset to this note's metadata = `calldataload(metadataPtr)`\n\n            let metadataIndex := calldataload(metadataPtr)\n\n\n\n            // To convert this into a calldata offset, we must add the number of bytes of calldata\n\n            // that preceeds the start of the `metadata` array.\n\n\n\n            // `bytes metadata` abi encoding:\n\n            // 0x00 : 0x20 = size of bytes array\n\n            // 0x20 : 0x40 = number of metadata entries (i)\n\n            // 0x40 : 0x40 + (0x20 * j) = relative offsets to each metadata entry\n\n            // 0x40 + (0x20 * j) : ??? = metadata entries\n\n\n\n            // The `metadata` pointer points to the 3rd word (at 0x40), the 1st relative offset\n\n            // Therefore, to compute the calldata offset to the metadata entry,\n\n            // we need to add `metadataPtr - 0x40` to `calldataload(metadataPtr)`.\n\n            // i.e. metadataCalldataPtr = calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // Because each metadata entry is itself a dynamic bytes array, the first word will\n\n            // be the length of the metadata entry. This is what we want, so we directly call\n\n            // `calldataload` on our offset\n\n            let metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // 0x4e0 = noteData length = 0x40 + metadata length\n\n            mstore(0x4e0, add(0x40, metadataLength))\n\n\n\n            // 0x500 = compressed note coordinate gamma\n\n            mstore(\n\n                0x500,\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // 0x520 = compressed note coordinate sigma\n\n            mstore(\n\n                0x520,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // To complete `noteData`, we need to copy note metadata into memory (0x540)\n\n            // We know that metadataIndex + metadataPtr - 0x40 points to the start of the metadata entry in calldata.\n\n            // But the first word is the length of the metadata entry, which we don't want.\n\n            // So we need to point to the second word (the byte array data).\n\n            // i.e. we want to start copying at (metadataIndex + metadataPtr - 0x20)\n\n            // and we want to copy `metadataLength` number of bytes.\n\n            calldatacopy(0x540, add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // We now need to work backwards and fill in the parts of `bytes proofOutput` that we left blank,\n\n            // as we now can identify the size of the array\n\n\n\n            // 0x460 points to the size of the output note. The actual size is 0xe0 + metadataLength.\n\n            // So we record 0xc0 + metadataLength\n\n            // (because the 'size' of a byte array does not take into account the word needed to record the size)\n\n            mstore(0x460, add(0xc0, metadataLength))  // update size of note\n\n\n\n            // 0x400 = the size of `bytes outputNotes`.\n\n            // Raw size = 0x140 + metadataLength, so record 0x120 + metadataLength\n\n            mstore(0x400, add(0x120, metadataLength)) // update size of outputNotes\n\n\n\n            // 0x200 = the size of `bytes proofOutput`\n\n            // Raw size = 0x340 + metadataLength, so record 0x340 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength))\n\n\n\n            // Great! We've now finished writing the 1st proof output.\n\n            // We now need to write the ABI encoding of the 2nd proof output entry.\n\n\n\n            // 0x1e0 points to the relative offset in `bytes proofOutputs` to the second proof entry.\n\n            // This will be equal to the size of the 1st proof, plus the 0x80 preceeding bytes\n\n            // that are used to record `bytes proofOutputs`\n\n            // i.e. relative offset = 0x340 + 0x80 + metadataLength = 0x3c0 + metadataLength\n\n            mstore(0x1e0, add(0x3c0, metadataLength))\n\n\n\n            /** \n\n            * proofOutput[1]\n\n            **/\n\n\n\n            // When writing data into proofOutputs[1], we cannot use an absolute offset as \n\n            // metadataLength is not known at compile time.\n\n            // `proofPtr` points to the start of `proofOutputs[1]`\n\n            let proofPtr := add(0x540, metadataLength)\n\n\n\n            // (proofPtr) = size of proofOutput (leave blank for now)\n\n\n\n            // (proofPtr + 0x20) = offset to inputNotes (0xc0)\n\n            mstore(add(proofPtr, 0x20), 0xc0)\n\n\n\n            // (proofPtr + 0x40) = offset to outputNotes (0x200)\n\n            mstore(add(proofPtr, 0x40), 0x200)\n\n\n\n            // (proofPtr + 0x60) = publicOwner (0)\n\n            mstore(add(proofPtr, 0x60), 0x00) // publicOwner\n\n\n\n            // (proofPtr + 0x80) = publicValue (0)\n\n            mstore(add(proofPtr, 0x80), 0x00) // publicValue\n\n\n\n            // (proofPtr + 0xa0) = challenge\n\n            // we hash the challenge to get the second proof output's challenge - to preserve uniqueness\n\n            mstore(0xe0, calldataload(0x124))\n\n            mstore(add(proofPtr, 0xa0), keccak256(0xe0, 0x20)) // challenge\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes\n\n            *\n\n            * starts at (proofPtr + 0xc0)\n\n            **/\n\n\n\n            // (proofPtr + 0xc0) = byte size of inputNotes (0x120)\n\n            mstore(add(proofPtr, 0xc0), 0x120)\n\n\n\n            // (proofPtr + 0xe0) = number of input notes (0x01)\n\n            mstore(add(proofPtr, 0xe0), 0x01)\n\n\n\n            // (proofPtr + 0x100) = relative offset to input note data (0x60)\n\n            mstore(add(proofPtr, 0x100), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x120)\n\n            **/\n\n\n\n            // input note = notes[3]\n\n            // => offset = notes + 0x60 + (0xc0 * 3) = notes + 0x2a0\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x2a0), 0x80)\n\n\n\n            // (proofPtr + 0x120) = byte length of input note (0xc0)\n\n            mstore(add(proofPtr, 0x120), 0xc0) // length of input note\n\n\n\n            // (proofPtr + 0x140) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x140), 0x01) // note type\n\n\n\n            // (proofPtr + 0x160) = note owner = noteOwners[3]\n\n            mstore(add(proofPtr, 0x160), calldataload(add(noteOwners, 0x60))) // note owner\n\n\n\n            // (proofPtr + 0x180) = note hash\n\n            mstore(add(proofPtr, 0x180), keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // (proofPtr + 0x1a0) = noteData length (0x40 bytes)\n\n            mstore(add(proofPtr, 0x1a0), 0x40)\n\n\n\n            // (proofPtr + 0x1c0) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x1c0),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x1e0) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x1e0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes\n\n            *\n\n            * starts at (proofPtr + 0x200)\n\n            **/\n\n\n\n            // (proofPtr + 0x200) = byte length of output notes, leave blank for now\n\n\n\n            // (proofPtr + 0x220) = number of output notes (0x01)\n\n            mstore(add(proofPtr, 0x220), 0x01)\n\n\n\n            // (proofPtr + 0x240) = offset to output notes (0x60)\n\n            mstore(add(proofPtr, 0x240), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x260)\n\n            **/\n\n            // output note = notes[1]\n\n            // => offset = notes + 0x60 + 0xc0 = notes + 0x120\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80)\n\n\n\n            // (proofPtr + 0x260) = length of note, leave blank for now\n\n\n\n            // (proofPtr + 0x280) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x280), 0x01) // note type\n\n\n\n            // (proofPtr + 0x2a0) = note owner (noteOwners[1])\n\n            mstore(add(proofPtr, 0x2a0), calldataload(add(noteOwners, 0x20)))\n\n\n\n            // (proofPtr + 0x2c0) = note hash\n\n            mstore(add(proofPtr, 0x2c0), keccak256(0x00, 0xa0))\n\n\n\n            // We now need to compute the metadata length. We want to access the 2nd metadata entry,\n\n            // at (metadataPtr + 0x20)\n\n            metadataIndex := calldataload(add(metadataPtr, 0x20))\n\n            metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // (proofPtr + 0x2e0) = noteData length (0x40 + metadataLength)\n\n            mstore(add(proofPtr, 0x2e0), add(0x40, metadataLength))\n\n\n\n            // (proofPtr + 0x300) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x300),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x320) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x320),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x340) = start of note metadata\n\n            calldatacopy(add(proofPtr, 0x340), add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // Next, work backwards and fill in the remaining gaps\n\n            // (proofPtr + 0x260) = proofOutputs[1].outputNotes[0].length (0xc0 + metadataLength)\n\n            mstore(add(proofPtr, 0x260), add(0xc0, metadataLength))\n\n\n\n            // (proofPtr + 0x200) = proofOutputs[1].outputNotes.length (0x120 + metadataLength)\n\n            mstore(add(proofPtr, 0x200), add(0x120, metadataLength))\n\n\n\n            // (proofPtr) = proofOutputs[1].length = (0x320 + metadataLength)\n\n            mstore(proofPtr, add(0x320, metadataLength))\n\n\n\n            // (0x180) = proofOutputs.length\n\n            // We previously stored proofOutputs[0].length at 0x200\n\n            // Total length = combination of\n\n            // 1. proofOutputs[0].length + 0x20 (extra word because of length variable)\n\n            // 2. proofOutputs[1].length + 0x20 (^^)\n\n            // 3. data to record relative offsets (0x20 * number of outputs) = (0x40)\n\n            // 4. data to record number of entries (0x20)\n\n            \n\n            // We stored proofOutputs[0].length at 0x200\n\n            // and we know that proofOutputs[1].length = 0x320 + metadataLength\n\n            // => length = mload(0x200) + metadataLength + 0x320 + 0x40 + 0x40 + 0x20\n\n            // => length = mload(0x200) + metadataLength + 0x3c0\n\n            mstore(0x180, add(add(0x3c0, metadataLength), mload(0x200)))\n\n\n\n            // Great, we've done it! Now all that is left is to return from this transaction.\n\n            // Our return data starts at 0x160.\n\n            // Total size of `bytes proofOutpust` = proofOutputs.length + 0x20\n\n            // We need 1 extra word (at 0x160) for the relative offset to get to `bytes proofOutputs`\n\n            // => returndata size = proofOutputs.length + 0x40\n\n            // = mload(0x180) + 0x40\n\n            return(0x160, add(mload(0x180), 0x40)) // *kazoo noises*\n\n        }\n",
                    "message": "BilateralSwapABIEncoder.encodeAndExit (BilateralSwapABIEncoderTest.sol#38-604) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 604,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n\n        assembly {\n\n            // set up initial variables\n\n            let notes := add(0x104, calldataload(0x144))\n\n            let noteOwners := add(0x124, calldataload(0x164)) // // one word after inputOwners = 1st\n\n            let metadataPtr := add(0x144, calldataload(0x184)) // two words after metadata = 1st\n\n\n\n            // First up, we need to do some checks to ensure we have been provided with correct data.\n\n            // We should only have 2 entries inside `bytes metadata` (only 2 output notes in total),\n\n            // and only 4 entries inside `noteOwners` (4 notes in bilateral swap proof)\n\n            if iszero(and(\n\n                eq(0x02, calldataload(sub(metadataPtr, 0x20))),\n\n                eq(0x04, calldataload(sub(noteOwners, 0x20)))\n\n            )) {\n\n                revert(0x00, 0x00) // no! bad! come back with good inputs!\n\n            }\n\n\n\n            // memory map of `proofOutputs`\n\n            // 0x00 - 0x160  = scratch data for note hash computation\n\n\n\n            // `returndata` starts at 0x160\n\n            // `proofOutputs` starts at 0x180\n\n            // 0x160 - 0x180 = relative offset in returndata to first bytes argument (0x20)\n\n            // 0x180 - 0x1a0 = byte length of `proofOutputs`\n\n            // 0x1a0 - 0x1c0 = number of `proofOutputs` entries (2)\n\n            // 0x1c0 - 0x1e0 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            // 0x1e0 - 0x200 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n    \n\n            // `proofOutput` - t, starts at 0x200\n\n            // 0x200 - 0x220 = length of `proofOutput`\n\n            // 0x220 - 0x240 = relative offset between `t` and `inputNotes`\n\n            // 0x240 - 0x260 = relative offset between `t` and `outputNotes`\n\n            // 0x260 - 0x280 = `publicOwner`\n\n            // 0x280 - 0x2a0 = `publicValue`\n\n            // 0x2a0 - 0x2c0 = `challenge`\n\n\n\n            // `inputNotes` starts at 0x2c0\n\n            // structure of `inputNotes` and `outputNotes`\n\n            // 0x00 - 0x20 = byte length of notes array\n\n            // 0x20 - 0x40 = number of notes = 1\n\n            // 0x40 - 0x60 = offset to start of input note (0x60)\n\n\n\n            // structure of a `note`\n\n            // 0x00 - 0x20 = size of `note`\n\n            // 0x20 - 0x40 = `owner`\n\n            // 0x40 - 0x60 = `noteHash`\n\n            // 0x60 - 0x80 = size of note `data`\n\n            // 0x80 - 0xa0 = compressed note coordinate `gamma` (part of `data`)\n\n            // 0xa0 - 0xc0 = compressed note coordinate `sigma` (part of `data`)\n\n            // 0xc0 - ???? = remaining note metadata\n\n\n\n            // Note organisation...\n\n            // The bilateral swap proof proves the following:\n\n            //   1. note[0].value == note[2].value\n\n            //   2. note[1].value == note[3].value\n\n            // In other words...\n\n            // note[0] = maker bid note\n\n            // note[1] = maker ask note\n\n            // note[2] = taker ask note\n\n            // note[3] = taker bid note\n\n\n\n            // We therefore have 2 balancing relationships\n\n            // 1. The maker bid note is destroyed and replaced with the taker ask note\n\n            // 2. The taker bid note is destroyed and replaced with the maker ask note\n\n\n\n            // Finally, we can translate this into 2 proofOutputs entries...\n\n            // In the first entry, `inputNotes` = [note[0]] and `outputNotes` = [note[2]]\n\n            // In the second entry, `inputNotes` = [note[3]] and `outputNotes` = [note[1]]\n\n\n\n            // `proofOutputs` must form a monolithic block of memory that we can return.\n\n            // `s` points to the memory location of the start of the current note\n\n            // `inputPtr` points to the start of the current `notes` dynamic bytes array\n\n\n\n            // length of proofOutputs is at 0x180\n\n\n\n            // we use memory from 0x00 - 0x140 as scratch memory\n\n\n\n            // return data starts at 0x160. As return data is `bytes proofOutputs`,\n\n            // the first word is the relative offset to the start of `proofOutputs` (i.e. 0x20)\n\n            mstore(0x160, 0x20)\n\n\n\n            /**\n\n            * Encoding of proofOutputs\n\n            * abi encoding of proofOutputs\n\n            * 0x00 : 0x20 = byte length of `proofOutputs` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = number of `proofOutputs` entries (2)\n\n            * 0x40 : 0x60 = relative memory offset between `v` and start of `proofOutputs[0]` (0x80)\n\n            * 0x60 : 0x80 = relative memory offset between `v` and start of `proofOutputs[1]`\n\n            * 0x80 : 0x80 + L1    = start of proofOutputs[0]\n\n            * 0x80 + L1   : 0x80 + L1 + L2 = start of proofOutputs[1]\n\n            **/\n\n        \n\n            // 0x180 stores the total size of `bytes proofOutputs`. We don't know that yet, so leave blank\n\n\n\n            // 0x1a0 = number of proof outputs (2)\n\n            mstore(0x1a0, 0x02)                            // number of proofs\n\n\n\n            // 0x1c0 = relative offset to 1st entry (0x80, 4 words)\n\n            mstore(0x1c0, 0x80)                            // offset to 1st proof\n\n\n\n            /**\n\n            * Encoding of proofOutput\n\n            * 0x00 : 0x20 = byte length of `proofOutput` = 0x60 + L1 + L2\n\n            * 0x20 : 0x40 = relative offset to `bytes inputNotes`\n\n            * 0x40 : 0x60 = relative offset to `bytes outputNotes`\n\n            * 0x60 : 0x80 = publicOwner\n\n            * 0x80 : 0xa0 = publicValue\n\n            * 0xa0 : 0xc0 = challenge\n\n            * 0xc0 : 0xc0 + L1 = `bytes inputNotes` (L1 = 0x140 bytes)\n\n            * 0xc0 + L1 : 0xc0 + L1 + L2 = `bytes inputNotes`\n\n            *\n\n            * Start of proofOutput = 0x200\n\n            **/\n\n\n\n            // length of proofOutput is at 0x200. We don't know that yet, so leave blank\n\n\n\n            // relative offset to inputNotes = 0xc0 (6 words)\n\n            mstore(0x220, 0xc0)                            // location of inputNotes\n\n\n\n            // we know that inputNotes has 1 entry, and input notes don't have metadata.\n\n            // So we actually know the complete size of `bytes inputNotes`\n\n            // (it's 0x140 bytes, we'll get to that in a bit)\n\n            // => relative offset to outputNotes = 0x140 + 0xc0 = 0x200\n\n            mstore(0x240, 0x200)                           // location of outputNotes\n\n\n\n            // bilateral swap proof hardcodes `publicOwner` and `publicValue` to 0 (no public tokens)\n\n            mstore(0x260, 0x00)                             // publicOwner\n\n            mstore(0x280, 0x00)                             // publicValue\n\n            mstore(0x2a0, calldataload(0x124))              // challenge\n\n            /**\n\n            * Encoding of inputNotes\n\n            * 0x00 : 0x20 = byte length of `inputNotes` (0x120)\n\n            * 0x20 : 0x40 = number of input notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st input note (0x60)\n\n            * 0x60 : L    = 1st input note data (L = 0xe0)\n\n            *\n\n            * Start of inputNotes = 0x2a0\n\n            * Because we only have 1 note in this array, and that note has no metadata\n\n            * we know that the size of the note is 0xe0 bytes\n\n            * therefore, the size of inputNotes = 0xe0 + 3 words = 0x140 bytes.\n\n            * We store the byte length as 0x120 bytes because the length parameter\n\n            * of a dynamic bytes array does not include itself in the length calculation\n\n            **/\n\n\n\n            // 0x2c0 = length of inputNotes = 0x120\n\n            mstore(0x2c0, 0x120)\n\n\n\n            // 0x2e0 = number of notes (1)\n\n            mstore(0x2e0, 0x01) // 1 input note\n\n\n\n            // 0x300 = relative offset to input note (0x60)\n\n            mstore(0x300, 0x60) // relative offset to note data\n\n\n\n            /**\n\n            * Encoding of input note\n\n            * 0x00 : 0x20 = byte length of note (0xc0)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            *\n\n            * Start of note = 0x320\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // we use memory from 0x00 - 0xa0 as scratch memory to compute note hash\n\n            // Note hash = keccak256(abi.encode(noteType, gammaX, gammaY, sigmaX, sigmaY))\n\n            mstore(0x00, 0x01) // store noteType at 0x01\n\n\n\n            // We want to copy note coordinate data into memory from 0x20 - 0xa0\n\n            // 'notes' points to the start of the notes array\n\n            // i.e. notes + 0x20 will point to the start of the data of the first entry\n\n            // first two entries are \\bar{k} and \\bar{a}, which we wish to skip over\n\n            // input note is notes[0] => we need to point to notes + 0x60\n\n            calldatacopy(0x20, add(notes, 0x60), 0x80) // copy gamma, sigma into 0x20 - 0xa0\n\n\n\n            // 0x320 = length of note (0xc0)\n\n            mstore(0x320, 0xc0)\n\n\n\n            // 0x340 = note type (UXTO type, 0x01)\n\n            mstore(0x340, 0x01) // note type\n\n\n\n            // 0x360 = note owners. We want the 1st entry in `noteOwners` (calldataload(noteOwners))\n\n            mstore(0x360, calldataload(noteOwners)) // note owner\n\n\n\n            // 0x380 = note hash, which is the hash of memory from 0x00 - 0xa0\n\n            mstore(0x380, keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // 0x3a0 = noteData length (0x40, no metadata)\n\n            mstore(0x3a0, 0x40)\n\n\n\n            // We now need to store compressed note coordinates.\n\n            // We store them in compressed form, as this stuff will be emitted as an event and is not required\n\n            // for additional smart contract logic. Compressing reduces the event data size and saves a fair bit of gas\n\n\n\n            // To compress, we determine if the y-coordinate is odd.\n\n            // If it is, we set the 256th bit of the x-coordinate to 'true'.\n\n            // bn128 field elements are only 254 bits long, so we know that we won't override x-coordinate data\n\n            // (we already have the note coords in memory, so we load from memory instead of calldata)\n\n\n\n            // 0x3c0 = gamma\n\n            mstore(\n\n                0x3c0,\n\n                or(\n\n                    mload(0x20), // load x coordinate\n\n                    mul(         // multiply by (y & 1 ? 2^255 : 0)\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // 0x3e0 = sigma\n\n            mstore(\n\n                0x3e0,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                    and(mload(0x80), 0x01),\n\n                    0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /**\n\n            * Encoding of output notes\n\n            *\n\n            * abi format is identical to input notes, but now we don't know the total size\n\n            * (because of variable length metadata)\n\n            * 0x00 : 0x20 = byte length of `outputNotes` (0x40 + L)\n\n            * 0x20 : 0x40 = number of output notes (0x01)\n\n            * 0x40 : 0x60 = relative offset to 1st output note (0x60)\n\n            * 0x60 : 0x60 + L    = 1st output note data\n\n            *\n\n            * Start of outputNotes = 0x400\n\n            **/\n\n\n\n            // 0x400 = byte length of output notes. We don't know what this is so leave blank for now\n\n\n\n            // 0x420 = number of output notes (0x01)\n\n            mstore(0x420, 0x01)\n\n\n\n            // 0x440 = relative offset to output note data (0x60)\n\n            mstore(0x440, 0x60)\n\n\n\n            /**\n\n            * Encoding of output note\n\n            * 0x00 : 0x20 = byte length of note (0xc0 + L)\n\n            * 0x20 : 0x40 = note type (UXTO type = 0x01)\n\n            * 0x40 : 0x60 = note owner\n\n            * 0x60 : 0x80 = note hash\n\n            * 0x80 : 0xa0 = note data length (0x40 + L)\n\n            * 0xa0 : 0xc0 = note coordinate 'gamma' (compressed)\n\n            * 0xc0 : 0xe0 = note coordinate 'sigma' (compressed)\n\n            * 0xe0 : 0xe0 + L = note metadata\n\n            *\n\n            * Start of note = 0x460\n\n            * The size of this note = 0xe0 bytes, so we store 0xc0 in the length parameter\n\n            **/\n\n\n\n            // next, copy note coordinates into memory to compute hash.\n\n            // We already stored the noteType at position 0x00, no need to do that again\n\n            // We need to copy data from notes[2].\n\n            // 1. notes + 0x20 = start of 1st entry data\n\n            // 2. size of a note entry = 0xc0 bytes\n\n            // 3. we want to point to 3rd word in our note entry, to skip over \\bar{k}, \\bar{a}\n\n            //    (i.e. add 0x40 to caldlata pointer)\n\n            // => offset = notes + 0x20 + 0x40 + (0xc0 * 2) = notes + 0x1e0\n\n            // => calldata pointer = notes + 0x1e0\n\n            calldatacopy(0x20, add(notes, 0x1e0), 0x80) // get gamma, sigma\n\n\n\n            // 0x460 = byte length of output note. Leave blank for now\n\n\n\n            // 0x480 = note type (0x01)\n\n            mstore(0x480, 0x01)      // note type\n\n\n\n            // 0x4a0 = note owner. We are accessing `notes[2]`, therefore\n\n            // the note owner = noteOwners[2].\n\n            // i.e. noteOwners + 0x40\n\n            mstore(0x4a0, calldataload(add(noteOwners, 0x40))) // note owner\n\n\n\n            // 0x4c0 = note hash\n\n            mstore(0x4c0, keccak256(0x00, 0xa0))\n\n\n\n            // 0x4e0 = noteData length. To get this, we need to identify our metadata length\n\n            // `metadataPtr` points to the relative offset, in the `metadata` array, to the first metadata entry\n\n            // ABI encoding of the input data should encode 2 metadata entries.\n\n            // => relative offset to this note's metadata = `calldataload(metadataPtr)`\n\n            let metadataIndex := calldataload(metadataPtr)\n\n\n\n            // To convert this into a calldata offset, we must add the number of bytes of calldata\n\n            // that preceeds the start of the `metadata` array.\n\n\n\n            // `bytes metadata` abi encoding:\n\n            // 0x00 : 0x20 = size of bytes array\n\n            // 0x20 : 0x40 = number of metadata entries (i)\n\n            // 0x40 : 0x40 + (0x20 * j) = relative offsets to each metadata entry\n\n            // 0x40 + (0x20 * j) : ??? = metadata entries\n\n\n\n            // The `metadata` pointer points to the 3rd word (at 0x40), the 1st relative offset\n\n            // Therefore, to compute the calldata offset to the metadata entry,\n\n            // we need to add `metadataPtr - 0x40` to `calldataload(metadataPtr)`.\n\n            // i.e. metadataCalldataPtr = calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // Because each metadata entry is itself a dynamic bytes array, the first word will\n\n            // be the length of the metadata entry. This is what we want, so we directly call\n\n            // `calldataload` on our offset\n\n            let metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // 0x4e0 = noteData length = 0x40 + metadata length\n\n            mstore(0x4e0, add(0x40, metadataLength))\n\n\n\n            // 0x500 = compressed note coordinate gamma\n\n            mstore(\n\n                0x500,\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // 0x520 = compressed note coordinate sigma\n\n            mstore(\n\n                0x520,\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n            \n\n            // To complete `noteData`, we need to copy note metadata into memory (0x540)\n\n            // We know that metadataIndex + metadataPtr - 0x40 points to the start of the metadata entry in calldata.\n\n            // But the first word is the length of the metadata entry, which we don't want.\n\n            // So we need to point to the second word (the byte array data).\n\n            // i.e. we want to start copying at (metadataIndex + metadataPtr - 0x20)\n\n            // and we want to copy `metadataLength` number of bytes.\n\n            calldatacopy(0x540, add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // We now need to work backwards and fill in the parts of `bytes proofOutput` that we left blank,\n\n            // as we now can identify the size of the array\n\n\n\n            // 0x460 points to the size of the output note. The actual size is 0xe0 + metadataLength.\n\n            // So we record 0xc0 + metadataLength\n\n            // (because the 'size' of a byte array does not take into account the word needed to record the size)\n\n            mstore(0x460, add(0xc0, metadataLength))  // update size of note\n\n\n\n            // 0x400 = the size of `bytes outputNotes`.\n\n            // Raw size = 0x140 + metadataLength, so record 0x120 + metadataLength\n\n            mstore(0x400, add(0x120, metadataLength)) // update size of outputNotes\n\n\n\n            // 0x200 = the size of `bytes proofOutput`\n\n            // Raw size = 0x340 + metadataLength, so record 0x340 + metadataLength\n\n            mstore(0x200, add(0x320, metadataLength))\n\n\n\n            // Great! We've now finished writing the 1st proof output.\n\n            // We now need to write the ABI encoding of the 2nd proof output entry.\n\n\n\n            // 0x1e0 points to the relative offset in `bytes proofOutputs` to the second proof entry.\n\n            // This will be equal to the size of the 1st proof, plus the 0x80 preceeding bytes\n\n            // that are used to record `bytes proofOutputs`\n\n            // i.e. relative offset = 0x340 + 0x80 + metadataLength = 0x3c0 + metadataLength\n\n            mstore(0x1e0, add(0x3c0, metadataLength))\n\n\n\n            /** \n\n            * proofOutput[1]\n\n            **/\n\n\n\n            // When writing data into proofOutputs[1], we cannot use an absolute offset as \n\n            // metadataLength is not known at compile time.\n\n            // `proofPtr` points to the start of `proofOutputs[1]`\n\n            let proofPtr := add(0x540, metadataLength)\n\n\n\n            // (proofPtr) = size of proofOutput (leave blank for now)\n\n\n\n            // (proofPtr + 0x20) = offset to inputNotes (0xc0)\n\n            mstore(add(proofPtr, 0x20), 0xc0)\n\n\n\n            // (proofPtr + 0x40) = offset to outputNotes (0x200)\n\n            mstore(add(proofPtr, 0x40), 0x200)\n\n\n\n            // (proofPtr + 0x60) = publicOwner (0)\n\n            mstore(add(proofPtr, 0x60), 0x00) // publicOwner\n\n\n\n            // (proofPtr + 0x80) = publicValue (0)\n\n            mstore(add(proofPtr, 0x80), 0x00) // publicValue\n\n\n\n            // (proofPtr + 0xa0) = challenge\n\n            // we hash the challenge to get the second proof output's challenge - to preserve uniqueness\n\n            mstore(0xe0, calldataload(0x124))\n\n            mstore(add(proofPtr, 0xa0), keccak256(0xe0, 0x20)) // challenge\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes\n\n            *\n\n            * starts at (proofPtr + 0xc0)\n\n            **/\n\n\n\n            // (proofPtr + 0xc0) = byte size of inputNotes (0x120)\n\n            mstore(add(proofPtr, 0xc0), 0x120)\n\n\n\n            // (proofPtr + 0xe0) = number of input notes (0x01)\n\n            mstore(add(proofPtr, 0xe0), 0x01)\n\n\n\n            // (proofPtr + 0x100) = relative offset to input note data (0x60)\n\n            mstore(add(proofPtr, 0x100), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].inputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x120)\n\n            **/\n\n\n\n            // input note = notes[3]\n\n            // => offset = notes + 0x60 + (0xc0 * 3) = notes + 0x2a0\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x2a0), 0x80)\n\n\n\n            // (proofPtr + 0x120) = byte length of input note (0xc0)\n\n            mstore(add(proofPtr, 0x120), 0xc0) // length of input note\n\n\n\n            // (proofPtr + 0x140) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x140), 0x01) // note type\n\n\n\n            // (proofPtr + 0x160) = note owner = noteOwners[3]\n\n            mstore(add(proofPtr, 0x160), calldataload(add(noteOwners, 0x60))) // note owner\n\n\n\n            // (proofPtr + 0x180) = note hash\n\n            mstore(add(proofPtr, 0x180), keccak256(0x00, 0xa0)) // note hash\n\n\n\n            // (proofPtr + 0x1a0) = noteData length (0x40 bytes)\n\n            mstore(add(proofPtr, 0x1a0), 0x40)\n\n\n\n            // (proofPtr + 0x1c0) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x1c0),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x1e0) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x1e0),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes\n\n            *\n\n            * starts at (proofPtr + 0x200)\n\n            **/\n\n\n\n            // (proofPtr + 0x200) = byte length of output notes, leave blank for now\n\n\n\n            // (proofPtr + 0x220) = number of output notes (0x01)\n\n            mstore(add(proofPtr, 0x220), 0x01)\n\n\n\n            // (proofPtr + 0x240) = offset to output notes (0x60)\n\n            mstore(add(proofPtr, 0x240), 0x60)\n\n\n\n            /** \n\n            * proofOutput[1].outputNotes[0]\n\n            *\n\n            * starts at (proofPtr + 0x260)\n\n            **/\n\n            // output note = notes[1]\n\n            // => offset = notes + 0x60 + 0xc0 = notes + 0x120\n\n            // copy note data into scratch memory to hash\n\n            calldatacopy(0x20, add(notes, 0x120), 0x80)\n\n\n\n            // (proofPtr + 0x260) = length of note, leave blank for now\n\n\n\n            // (proofPtr + 0x280) = note type (UXTO type, 0x01)\n\n            mstore(add(proofPtr, 0x280), 0x01) // note type\n\n\n\n            // (proofPtr + 0x2a0) = note owner (noteOwners[1])\n\n            mstore(add(proofPtr, 0x2a0), calldataload(add(noteOwners, 0x20)))\n\n\n\n            // (proofPtr + 0x2c0) = note hash\n\n            mstore(add(proofPtr, 0x2c0), keccak256(0x00, 0xa0))\n\n\n\n            // We now need to compute the metadata length. We want to access the 2nd metadata entry,\n\n            // at (metadataPtr + 0x20)\n\n            metadataIndex := calldataload(add(metadataPtr, 0x20))\n\n            metadataLength := calldataload(add(sub(metadataPtr, 0x40), metadataIndex))\n\n\n\n            // (proofPtr + 0x2e0) = noteData length (0x40 + metadataLength)\n\n            mstore(add(proofPtr, 0x2e0), add(0x40, metadataLength))\n\n\n\n            // (proofPtr + 0x300) = compressed coordinate 'gamma'\n\n            mstore(\n\n                add(proofPtr, 0x300),\n\n                or(\n\n                    mload(0x20),\n\n                    mul(\n\n                        and(mload(0x40), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x320) = compressed coordinate 'sigma'\n\n            mstore(\n\n                add(proofPtr, 0x320),\n\n                or(\n\n                    mload(0x60),\n\n                    mul(\n\n                        and(mload(0x80), 0x01),\n\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n\n                    )\n\n                )\n\n            )\n\n\n\n            // (proofPtr + 0x340) = start of note metadata\n\n            calldatacopy(add(proofPtr, 0x340), add(metadataIndex, sub(metadataPtr, 0x20)), metadataLength)\n\n\n\n            // Next, work backwards and fill in the remaining gaps\n\n            // (proofPtr + 0x260) = proofOutputs[1].outputNotes[0].length (0xc0 + metadataLength)\n\n            mstore(add(proofPtr, 0x260), add(0xc0, metadataLength))\n\n\n\n            // (proofPtr + 0x200) = proofOutputs[1].outputNotes.length (0x120 + metadataLength)\n\n            mstore(add(proofPtr, 0x200), add(0x120, metadataLength))\n\n\n\n            // (proofPtr) = proofOutputs[1].length = (0x320 + metadataLength)\n\n            mstore(proofPtr, add(0x320, metadataLength))\n\n\n\n            // (0x180) = proofOutputs.length\n\n            // We previously stored proofOutputs[0].length at 0x200\n\n            // Total length = combination of\n\n            // 1. proofOutputs[0].length + 0x20 (extra word because of length variable)\n\n            // 2. proofOutputs[1].length + 0x20 (^^)\n\n            // 3. data to record relative offsets (0x20 * number of outputs) = (0x40)\n\n            // 4. data to record number of entries (0x20)\n\n            \n\n            // We stored proofOutputs[0].length at 0x200\n\n            // and we know that proofOutputs[1].length = 0x320 + metadataLength\n\n            // => length = mload(0x200) + metadataLength + 0x320 + 0x40 + 0x40 + 0x20\n\n            // => length = mload(0x200) + metadataLength + 0x3c0\n\n            mstore(0x180, add(add(0x3c0, metadataLength), mload(0x200)))\n\n\n\n            // Great, we've done it! Now all that is left is to return from this transaction.\n\n            // Our return data starts at 0x160.\n\n            // Total size of `bytes proofOutpust` = proofOutputs.length + 0x20\n\n            // We need 1 extra word (at 0x160) for the relative offset to get to `bytes proofOutputs`\n\n            // => returndata size = proofOutputs.length + 0x40\n\n            // = mload(0x180) + 0x40\n\n            return(0x160, add(mload(0x180), 0x40)) // *kazoo noises*\n\n        }\n",
                    "message": "BilateralSwapABIEncoder.encodeAndExit uses assembly (BilateralSwapABIEncoderTest.sol#38-604)\n\t- BilateralSwapABIEncoderTest.sol#39-603\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in BilateralSwapABIEncoderTest.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (BilateralSwapABIEncoderTest.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (BilateralSwapABIEncoderTest.sol#609): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 624,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata, \n",
                    "message": "Parameter '' of BilateralSwapABIEncoderTest.validateBilateralSwap (BilateralSwapABIEncoderTest.sol#624) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 625,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address, \n",
                    "message": "Parameter '_scope_0' of BilateralSwapABIEncoderTest.validateBilateralSwap (BilateralSwapABIEncoderTest.sol#625) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6] calldata\n",
                    "message": "Parameter '_scope_1' of BilateralSwapABIEncoderTest.validateBilateralSwap (BilateralSwapABIEncoderTest.sol#626) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validateBilateralSwap(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeAndExit() internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/interfaces/DividendComputationInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in DividendComputationInterface.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (DividendComputationInterface.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata,\n",
                    "message": "Parameter '' of DividendComputationInterface.validateDividendComputation (DividendComputationInterface.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address,\n",
                    "message": "Parameter '_scope_0' of DividendComputationInterface.validateDividendComputation (DividendComputationInterface.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6] calldata\n",
                    "message": "Parameter '_scope_1' of DividendComputationInterface.validateDividendComputation (DividendComputationInterface.sol#9) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validateDividendComputation(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/interfaces/IERC20.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in IERC20.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (IERC20.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/interfaces/JoinSplitInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_12"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-state",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "JoinSplitInterface.EIP712_DOMAIN_HASH (JoinSplitInterface.sol#128) shadows:\n\t- LibEIP712.EIP712_DOMAIN_HASH (JoinSplitInterface.sol#30)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message (JoinSplitInterface.sol#46-72) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature (JoinSplitInterface.sol#78-119) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message uses assembly (JoinSplitInterface.sol#46-72)\n\t- JoinSplitInterface.sol#60-71\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature uses assembly (JoinSplitInterface.sol#78-119)\n\t- JoinSplitInterface.sol#83-113\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "JoinSplitInterface.EIP712_DOMAIN_HASH should be constant (JoinSplitInterface.sol#128)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in JoinSplitInterface.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitInterface.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (JoinSplitInterface.sol#124): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (JoinSplitInterface.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata, \n",
                    "message": "Parameter '' of JoinSplitInterface.validateJoinSplit (JoinSplitInterface.sol#133) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address, \n",
                    "message": "Parameter '_scope_0' of JoinSplitInterface.validateJoinSplit (JoinSplitInterface.sol#134) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6] calldata\n",
                    "message": "Parameter '_scope_1' of JoinSplitInterface.validateJoinSplit (JoinSplitInterface.sol#135) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'JoinSplitInterface.EIP712_DOMAIN_HASH' (JoinSplitInterface.sol#128) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validateJoinSplit(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/interfaces/BilateralSwapInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in BilateralSwapInterface.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (BilateralSwapInterface.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata, \n",
                    "message": "Parameter '' of BilateralSwapInterface.validateBilateralSwap (BilateralSwapInterface.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address, \n",
                    "message": "Parameter '_scope_0' of BilateralSwapInterface.validateBilateralSwap (BilateralSwapInterface.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6] calldata\n",
                    "message": "Parameter '_scope_1' of BilateralSwapInterface.validateBilateralSwap (BilateralSwapInterface.sol#9) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validateBilateralSwap(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/interfaces/IZkAsset.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in IZkAsset.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (IZkAsset.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/interfaces/IAZTEC.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in IAZTEC.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (IAZTEC.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                }
            ]
        }
    },
    "AZTEC-7a020f4ced9680f6e4a452fe570671aac0802471/packages/protocol/contracts/interfaces/AdjustSupplyInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_NAME)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            address(this)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(result, \"signature recovery failed\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_9"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message (AdjustSupplyInterface.sol#46-72) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature (AdjustSupplyInterface.sol#78-119) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n\n        internal\n\n        view\n\n        returns (bytes32 _result)\n\n    {\n\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer. We're not going to use it - we're going to overwrite it!\n\n            // We need 0x60 bytes of memory for this hash,\n\n            // cheaper to overwrite the free memory pointer at 0x40, and then replace it, than allocating free memory\n\n            let memPtr := mload(0x40)\n\n            mstore(0x00, 0x1901)               // EIP191 header\n\n            mstore(0x20, eip712DomainHash)     // EIP712 domain hash\n\n            mstore(0x40, _hashStruct)          // Hash of struct\n\n            _result := keccak256(0x1e, 0x42)   // compute hash\n\n            // replace memory pointer\n\n            mstore(0x40, memPtr)\n\n        }\n",
                    "message": "LibEIP712.hashEIP712Message uses assembly (AdjustSupplyInterface.sol#46-72)\n\t- AdjustSupplyInterface.sol#60-71\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function recoverSignature(\n\n        bytes32 _message,\n\n        bytes memory _signature\n\n    ) internal view returns (address _signer) {\n\n        bool result;\n\n        assembly {\n\n            // Here's a little trick we can pull. We expect `_signature` to be a byte array, of length 0x60, with\n\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `_signature`.\n\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\n\n\n\n            // load length as a temporary variable\n\n            let byteLength := mload(_signature)\n\n\n\n            // store the signature message\n\n            mstore(_signature, _message)\n\n\n\n            // load 'v' - we need it for a condition check\n\n            let v := mload(add(_signature, 0x20))\n\n\n\n            result := and(\n\n                and(\n\n                    // validate signature length == 0x60 bytes\n\n                    eq(byteLength, 0x60),\n\n                    // validate v == 27 or v == 28\n\n                    or(eq(v, 27), eq(v, 28))\n\n                ),\n\n                // validate call to precompile succeeds\n\n                staticcall(gas, 0x01, _signature, 0x80, _signature, 0x20)\n\n            )\n\n            // save the _signer only if the first word in _signature is not `_message` anymore\n\n            switch eq(_message, mload(_signature))\n\n            case 0 {\n\n                _signer := mload(_signature)\n\n            }\n\n            mstore(_signature, byteLength) // and put the byte length back where it belongs\n\n        }\n\n        // wrap failure states in a single if test, so that happy path only has 1 conditional jump\n\n        if (!(result && (_signer == address(0x0)))) {\n\n            require(_signer != address(0x0), \"signer address cannot be 0\");\n\n            require(result, \"signature recovery failed\");\n\n        }\n",
                    "message": "LibEIP712.recoverSignature uses assembly (AdjustSupplyInterface.sol#78-119)\n\t- AdjustSupplyInterface.sol#83-113\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": "Detected issues with version pragma in AdjustSupplyInterface.sol:\n\t- pragma solidity>=0.5.0<0.6.0 (AdjustSupplyInterface.sol#3): it allows old versions\n\t- pragma solidity>=0.5.0<0.6.0 (AdjustSupplyInterface.sol#124): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public EIP712_DOMAIN_HASH;\n",
                    "message": "Variable 'LibEIP712.EIP712_DOMAIN_HASH' (AdjustSupplyInterface.sol#30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata, // proof data\n",
                    "message": "Parameter '' of AdjustSupplyInterface.validateAdjustSupply (AdjustSupplyInterface.sol#132) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address, // sender address\n",
                    "message": "Parameter '_scope_0' of AdjustSupplyInterface.validateAdjustSupply (AdjustSupplyInterface.sol#133) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint[6] calldata // common reference string\n",
                    "message": "Parameter '_scope_1' of AdjustSupplyInterface.validateAdjustSupply (AdjustSupplyInterface.sol#134) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!(result && (_signer == address(0x0)))) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_signer != address(0x0), \"signer address cannot be 0\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function validateAdjustSupply(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.0 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 _hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recoverSignature(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    }
}