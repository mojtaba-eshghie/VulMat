{
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/interest/JumpRateInterestModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = owner_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        updateJumpRateModelInternal(baseRatePerYear,  multiplierPerYear, jumpMultiplierPerYear, kink_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \tBaseJumpRateModelV2(baseRatePerYear,multiplierPerYear,jumpMultiplierPerYear,kink_,owner_) public {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == owner, \"only the owner may call this function.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == owner, \"only the owner may call this function.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": 343,
                    "vulnerability_code": "    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) public view returns (uint) {\n\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);\n\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n",
                    "message": "BaseJumpRateModelV2.getSupplyRate (JumpRateInterestModel.sol#338-343) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in JumpRateInterestModel.sol:\n\t- pragma solidity^0.5.16 (JumpRateInterestModel.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (JumpRateInterestModel.sol#192): it allows old versions\n\t- pragma solidity^0.5.16 (JumpRateInterestModel.sol#225): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'InterestRateModel.isInterestRateModel' (JumpRateInterestModel.sol#200) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public constant blocksPerYear = 10512000;\n",
                    "message": "Constant 'BaseJumpRateModelV2.blocksPerYear' (JumpRateInterestModel.sol#246) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint;\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/interest/InterestRateModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in InterestRateModel.sol:\n\t- pragma solidity^0.5.16 (InterestRateModel.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'InterestRateModel.isInterestRateModel' (InterestRateModel.sol#11) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/0.8.4/IRToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": false,
            "errors": [
                "EXIT_CODE_255",
                "error parsing results: file could not be opened successfully:\n- method gz: ReadError('empty file')\n- method bz2: ReadError('not a bzip2 file')\n- method xz: ReadError('not an lzma file')\n- method tar: ReadError('empty file')"
            ],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/0.8.4/libs/Babylonian.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": false,
            "errors": [
                "EXIT_CODE_255",
                "error parsing results: file could not be opened successfully:\n- method gz: ReadError('empty file')\n- method bz2: ReadError('not a bzip2 file')\n- method xz: ReadError('not an lzma file')\n- method tar: ReadError('empty file')"
            ],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            while (x < z) {\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/controller/IronControllerStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(RTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newIronController.isIronController(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 2016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2685,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 825,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1092,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/controller/IronDelegateController.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2843,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to caller\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2846,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(RTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newIronController.isIronController(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 2016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2881,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingIronControllerImplementation = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2933,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingAdmin = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2821,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IronDelegateController is IronDelegateControllerAdminStorage, IronControllerErrorReporter {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 698,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2685,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 825,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1092,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 2948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, ) = ironControllerImplementation.delegatecall(msg.data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2950,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/controller/IronDelegateControllerAdminStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public admin;\n",
                    "message": "IronDelegateControllerAdminStorage.admin should be constant (IronDelegateControllerAdminStorage.sol#10)\nIronDelegateControllerAdminStorage.ironControllerImplementation should be constant (IronDelegateControllerAdminStorage.sol#20)\nIronDelegateControllerAdminStorage.pendingAdmin should be constant (IronDelegateControllerAdminStorage.sol#15)\nIronDelegateControllerAdminStorage.pendingIronControllerImplementation should be constant (IronDelegateControllerAdminStorage.sol#25)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in IronDelegateControllerAdminStorage.sol:\n\t- pragma solidity^0.5.16 (IronDelegateControllerAdminStorage.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/controller/IronController.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 3683,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 3902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 4176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rTokens.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 4182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 4189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to caller\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2853,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3045,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3046,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3080,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3683,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < numMarkets; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 4176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rTokens.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 4182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 4189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(RTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newIronController.isIronController(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!mintGuardianPaused[rToken], \"mint is paused\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!borrowGuardianPaused[rToken], \"borrow is paused\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(msg.sender == rToken, \"sender must be rToken\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!seizeGuardianPaused, \"seize is paused\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3562,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!transferGuardianPaused, \"transfer is paused\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \trequire(msg.sender == admin, \"only admin can set close factor\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3903,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(allMarkets[i] != RToken(rToken), \"market already added\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3921,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(markets[address(rToken)].isListed, \"cannot pause a market that is not listed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3970,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(markets[address(rToken)].isListed, \"cannot pause a market that is not listed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3980,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3981,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3989,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3990,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3998,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3999,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin || state == true, \"only admin can unpause\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 4007,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 4008,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 4035,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(market.isListed == true, \"market is not listed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 4178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(markets[address(rToken)].isListed, \"market must be listed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 4221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(adminOrInitializing(), \"only admin can set reward speed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 3921,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3285,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(rToken) == 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3839,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4037,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (rewardSupplyState[address(rToken)].index == 0 && rewardSupplyState[address(rToken)].block == 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4038,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                rewardSupplyState[address(rToken)] = RewardMarketState({\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4039,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    index: rewardInitialIndex,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4040,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4041,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                });\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4042,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4044,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (rewardBorrowState[address(rToken)].index == 0 && rewardBorrowState[address(rToken)].block == 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4045,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                rewardBorrowState[address(rToken)] = RewardMarketState({\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4046,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    index: rewardInitialIndex,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4047,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4048,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                });\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (deltaBlocks > 0 && supplySpeed > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4068,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint supplyTokens = RToken(rToken).totalSupply();\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4069,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint rewardAccrued = mul_(deltaBlocks, supplySpeed);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4070,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Double memory ratio = supplyTokens > 0 ? fraction(rewardAccrued, supplyTokens) : Double({mantissa: 0});\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4071,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            rewardSupplyState[rToken] = RewardMarketState({\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4073,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            });\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4076,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (deltaBlocks > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4090,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (deltaBlocks > 0 && borrowSpeed > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4091,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint borrowAmount = div_(RToken(rToken).totalBorrows(), marketBorrowIndex);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4092,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint rewardAccrued = mul_(deltaBlocks, borrowSpeed);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4093,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Double memory ratio = borrowAmount > 0 ? fraction(rewardAccrued, borrowAmount) : Double({mantissa: 0});\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            rewardBorrowState[rToken] = RewardMarketState({\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4096,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4097,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                block: safe32(blockNumber, \"block number exceeds 32 bits\")\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4098,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            });\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4099,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (deltaBlocks > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            supplierIndex.mantissa = rewardInitialIndex;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 4117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 3173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        storedList.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3080,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3683,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < numMarkets; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 4176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rTokens.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 4182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 4189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(markets[address(rToken)].isListed, \"cannot pause a market that is not listed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3970,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(markets[address(rToken)].isListed, \"cannot pause a market that is not listed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3980,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3989,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3998,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 4007,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 2016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 4243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return 0x4C93950Fe844c367f1C661B79b666BE2b88eD29a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingIronControllerImplementation = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingAdmin = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 3173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        storedList.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 3683,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 3902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 4176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rTokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 4182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 4189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3080,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3683,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < allMarkets.length; i ++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < numMarkets; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 4176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rTokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 4182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 4189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = 0; j < holders.length; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2829,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IronDelegateController is IronDelegateControllerAdminStorage, IronControllerErrorReporter {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2685,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2720,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2821,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 3283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 825,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1092,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3625,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3655,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint borrowAmount) public view returns (uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint borrowAmount) internal view returns (Error, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3738,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateCalculateSeizeTokens(address rTokenBorrowed, address rTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 2956,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, ) = ironControllerImplementation.delegatecall(msg.data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2958,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/common/Exponential.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_9"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
                    "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ Exponential.sol#410) shadows:\n\t- ExponentialNoError.fraction (function @ Exponential.sol#282-284)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in Exponential.sol:\n\t- pragma solidity^0.5.16 (Exponential.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (Exponential.sol#91): it allows old versions\n\t- pragma solidity^0.5.16 (Exponential.sol#289): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": 129,
                    "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncate' (Exponential.sol#126-129) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncateAddUInt' (Exponential.sol#134-137) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant expScale = 1e18;\n",
                    "message": "Constant 'ExponentialNoError.expScale' (Exponential.sol#101) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant doubleScale = 1e36;\n",
                    "message": "Constant 'ExponentialNoError.doubleScale' (Exponential.sol#102) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'ExponentialNoError.halfExpScale' (Exponential.sol#103) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant mantissaOne = expScale;\n",
                    "message": "Constant 'ExponentialNoError.mantissaOne' (Exponential.sol#104) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant mantissaOne = expScale;\n",
                    "message": "ExponentialNoError.mantissaOne (Exponential.sol#104) is never used in Exponential\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/common/ExponentialNoError.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in ExponentialNoError.sol:\n\t- pragma solidity^0.5.16 (ExponentialNoError.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncate' (ExponentialNoError.sol#38-41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncateAddUInt' (ExponentialNoError.sol#46-49) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant expScale = 1e18;\n",
                    "message": "Constant 'ExponentialNoError.expScale' (ExponentialNoError.sol#13) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant doubleScale = 1e36;\n",
                    "message": "Constant 'ExponentialNoError.doubleScale' (ExponentialNoError.sol#14) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'ExponentialNoError.halfExpScale' (ExponentialNoError.sol#15) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant mantissaOne = expScale;\n",
                    "message": "Constant 'ExponentialNoError.mantissaOne' (ExponentialNoError.sol#16) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant halfExpScale = expScale/2;\n",
                    "message": "ExponentialNoError.halfExpScale (ExponentialNoError.sol#15) is never used in ExponentialNoError\nExponentialNoError.mantissaOne (ExponentialNoError.sol#16) is never used in ExponentialNoError\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/common/SafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in SafeMath.sol:\n\t- pragma solidity^0.5.16 (SafeMath.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/common/ErrorReporter.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in ErrorReporter.sol:\n\t- pragma solidity^0.5.16 (ErrorReporter.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/common/CarefulMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in CarefulMath.sol:\n\t- pragma solidity^0.5.16 (CarefulMath.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/RToken/RErc20Delegate.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(RTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newIronController.isIronController(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \trequire(address(token) != underlying, \"RErc20::sweepToken: can not sweep underlying token\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2841,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2872,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2904,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \trequire(address(token) != underlying, \"RErc20::sweepToken: can not sweep underlying token\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2904,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 2016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                },
                {
                    "name": "compound-sweeptoken-not-restricted",
                    "vulnerability_from_line": 2785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \ttoken.transfer(admin, balance);\n",
                    "message": "Function sweepToken is allowed to be called by anyone"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_103"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (RErc20Delegate.sol#117-179) has incorrect ERC20 function interface(s):\n\t-transfer (RErc20Delegate.sol#143)\n\t-transferFrom (RErc20Delegate.sol#157)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2468,
                    "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._addReservesInternal (RErc20Delegate.sol#2456-2468):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Delegate.sol#2457-2458)\n\tState variables written after the call(s):\n\t- totalReserves (RErc20Delegate.sol#2464-2465)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": 2529,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._reduceReserves (RErc20Delegate.sol#2519-2529):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Delegate.sol#2520-2521)\n\tState variables written after the call(s):\n\t- totalReserves (RErc20Delegate.sol#2526-2527)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setInterestRateModel (RErc20Delegate.sol#2584-2594):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Delegate.sol#2585-2586)\n\t- _setInterestRateModelFresh(newInterestRateModel) (RErc20Delegate.sol#2591-2592)\n\tState variables written after the call(s):\n\t- interestRateModel (RErc20Delegate.sol#2591-2592)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2600,
                    "vulnerability_to_line": 2630,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setInterestRateModelFresh (RErc20Delegate.sol#2600-2630):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (RErc20Delegate.sol#2619-2621)\n\tState variables written after the call(s):\n\t- interestRateModel (RErc20Delegate.sol#2622-2624)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2407,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_IRON_CONTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        IronControllerInterface oldIronController = ironController;\n\n        // Ensure invoke ironController.isIronController() returns true\n\n        require(newIronController.isIronController(), \"marker method returned false\");\n\n\n\n        // Set market's ironController to newIronController\n\n        ironController = newIronController;\n\n\n\n        // Emit NewIronController(oldIronController, newIronController)\n\n        emit NewIronController(oldIronController, newIronController);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setIronController (RErc20Delegate.sol#2388-2407):\n\tExternal calls:\n\t- require(bool,string)(newIronController.isIronController(),marker method returned false) (RErc20Delegate.sol#2396-2397)\n\tState variables written after the call(s):\n\t- ironController (RErc20Delegate.sol#2399-2400)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": 2422,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setReserveFactor (RErc20Delegate.sol#2412-2422):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Delegate.sol#2413-2414)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (RErc20Delegate.sol#2419-2420)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1614,
                    "vulnerability_to_line": 1692,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor;\n\n        uint interestAccumulated;\n\n        uint totalBorrowsNew;\n\n        uint totalReservesNew;\n\n        uint borrowIndexNew;\n\n\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.accrueInterest (RErc20Delegate.sol#1614-1692):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (RErc20Delegate.sol#1631)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (RErc20Delegate.sol#1683)\n\t- borrowIndex (RErc20Delegate.sol#1684)\n\t- totalBorrows (RErc20Delegate.sol#1685)\n\t- totalReserves (RErc20Delegate.sol#1686)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1945,
                    "vulnerability_to_line": 1953,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
                    "message": "Reentrancy in RToken.borrowInternal (RErc20Delegate.sol#1945-1953):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Delegate.sol#1946)\n\t- borrowFresh(msg.sender,borrowAmount) (RErc20Delegate.sol#1952)\n\tState variables written after the call(s):\n\t- totalBorrows (RErc20Delegate.sol#1952)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": 1286,
                    "vulnerability_code": "    function initialize(IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the ironController\n\n        uint err = _setIronController(ironController_);\n\n        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on ironController being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
                    "message": "Reentrancy in RToken.initialize (RErc20Delegate.sol#1255-1286):\n\tExternal calls:\n\t- err = _setIronController(ironController_) (RErc20Delegate.sol#1269)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (RErc20Delegate.sol#1273)\n\t- borrowIndex (RErc20Delegate.sol#1274)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2159,
                    "vulnerability_to_line": 2174,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = RTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, RTokenCollateral);\n",
                    "message": "Reentrancy in RToken.liquidateBorrowInternal (RErc20Delegate.sol#2159-2174):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Delegate.sol#2160)\n\t- error = RTokenCollateral.accrueInterest() (RErc20Delegate.sol#2166)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,RTokenCollateral) (RErc20Delegate.sol#2173)\n\tState variables written after the call(s):\n\t- totalBorrows (RErc20Delegate.sol#2173)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": 1938,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = ironController.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REDEEM_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        ironController.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.redeemFresh (RErc20Delegate.sol#1844-1938):\n\tExternal calls:\n\t- allowed = ironController.redeemAllowed(address(this),redeemer,vars.redeemTokens) (RErc20Delegate.sol#1884)\n\tState variables written after the call(s):\n\t- totalSupply (RErc20Delegate.sol#1927)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2054,
                    "vulnerability_to_line": 2062,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowBehalfInternal (RErc20Delegate.sol#2054-2062):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Delegate.sol#2055)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (RErc20Delegate.sol#2061)\n\tState variables written after the call(s):\n\t- totalBorrows (RErc20Delegate.sol#2061)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2038,
                    "vulnerability_to_line": 2046,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowInternal (RErc20Delegate.sol#2038-2046):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Delegate.sol#2039)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (RErc20Delegate.sol#2045)\n\tState variables written after the call(s):\n\t- totalBorrows (RErc20Delegate.sol#2045)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 2094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
                    "message": "vars in RToken.repayBorrowFresh (RErc20Delegate.sol#2094) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 2477,
                    "vulnerability_to_line": 2479,
                    "vulnerability_code": "        uint actualAddAmount;\n\n\n",
                    "message": "actualAddAmount in RToken._addReservesFresh (RErc20Delegate.sol#2477-2479) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MintLocalVars memory vars;\n",
                    "message": "vars in RToken.mintFresh (RErc20Delegate.sol#1739) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": "vars in RToken.redeemFresh (RErc20Delegate.sol#1847) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1984,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n",
                    "message": "vars in RToken.borrowFresh (RErc20Delegate.sol#1984) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2687,
                    "vulnerability_to_line": 2702,
                    "vulnerability_code": "    function initialize(address underlying_,\n\n                        IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
                    "message": "RErc20.initialize (RErc20Delegate.sol#2687-2702) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (RErc20Delegate.sol#2699-2700)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
                    "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ RErc20Delegate.sol#1170) shadows:\n\t- ExponentialNoError.fraction (function @ RErc20Delegate.sol#1042-1044)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1967,
                    "vulnerability_to_line": 2031,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = ironController.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.BORROW_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.borrowFresh (RErc20Delegate.sol#1967-2031):\n\tExternal calls:\n\t- allowed = ironController.borrowAllowed(address(this),borrower,borrowAmount) (RErc20Delegate.sol#1969)\n\tState variables written after the call(s):\n\t- accountBorrows (RErc20Delegate.sol#2019)\n\t- accountBorrows (RErc20Delegate.sol#2020)\n\t- totalBorrows (RErc20Delegate.sol#2021)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": 1286,
                    "vulnerability_code": "    function initialize(IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the ironController\n\n        uint err = _setIronController(ironController_);\n\n        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on ironController being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
                    "message": "Reentrancy in RToken.initialize (RErc20Delegate.sol#1255-1286):\n\tExternal calls:\n\t- err = _setIronController(ironController_) (RErc20Delegate.sol#1269)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (RErc20Delegate.sol#1277)\n\tState variables written after the call(s):\n\t- _notEntered (RErc20Delegate.sol#1285)\n\t- decimals (RErc20Delegate.sol#1282)\n\t- name (RErc20Delegate.sol#1280)\n\t- symbol (RErc20Delegate.sol#1281)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2687,
                    "vulnerability_to_line": 2702,
                    "vulnerability_code": "    function initialize(address underlying_,\n\n                        IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
                    "message": "Reentrancy in RErc20.initialize (RErc20Delegate.sol#2687-2702):\n\tExternal calls:\n\t- super.initialize(ironController_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (RErc20Delegate.sol#2695-2697)\n\tState variables written after the call(s):\n\t- underlying (RErc20Delegate.sol#2698-2699)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": 1792,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = ironController.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.MINT_IRON_CONTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the RToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of RTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n\n\n        /*\n\n         * We calculate the new total supply of RTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n",
                    "message": "Reentrancy in RToken.mintFresh (RErc20Delegate.sol#1727-1792):\n\tExternal calls:\n\t- allowed = ironController.mintAllowed(address(this),minter,mintAmount) (RErc20Delegate.sol#1729)\n\tState variables written after the call(s):\n\t- accountTokens (RErc20Delegate.sol#1781)\n\t- totalSupply (RErc20Delegate.sol#1780)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": 1938,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = ironController.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REDEEM_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        ironController.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.redeemFresh (RErc20Delegate.sol#1844-1938):\n\tExternal calls:\n\t- allowed = ironController.redeemAllowed(address(this),redeemer,vars.redeemTokens) (RErc20Delegate.sol#1884)\n\tState variables written after the call(s):\n\t- accountTokens (RErc20Delegate.sol#1928)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2082,
                    "vulnerability_to_line": 2149,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = ironController.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REPAY_BORROW_IRON_CONTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowFresh (RErc20Delegate.sol#2082-2149):\n\tExternal calls:\n\t- allowed = ironController.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (RErc20Delegate.sol#2084)\n\tState variables written after the call(s):\n\t- accountBorrows (RErc20Delegate.sol#2137)\n\t- accountBorrows (RErc20Delegate.sol#2138)\n\t- totalBorrows (RErc20Delegate.sol#2139)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2279,
                    "vulnerability_to_line": 2326,
                    "vulnerability_code": "    function seizeInternal(address seizeRToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = ironController.seizeAllowed(address(this), seizeRToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borroweRTokensNew;\n\n        uint liquidatoRTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borroweRTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatoRTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borroweRTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatoRTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borroweRTokensNew;\n\n        accountTokens[liquidator] = liquidatoRTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.seizeVerify(address(this), seizeRToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.seizeInternal (RErc20Delegate.sol#2279-2326):\n\tExternal calls:\n\t- allowed = ironController.seizeAllowed(address(this),seizeRToken,liquidator,borrower,seizeTokens) (RErc20Delegate.sol#2281)\n\tState variables written after the call(s):\n\t- accountTokens (RErc20Delegate.sol#2315)\n\t- accountTokens (RErc20Delegate.sol#2316)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1297,
                    "vulnerability_to_line": 1357,
                    "vulnerability_code": "    function transfeRTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = ironController.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.TRANSFER_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srRTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srRTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srRTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // ironController.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.transfeRTokens (RErc20Delegate.sol#1297-1357):\n\tExternal calls:\n\t- allowed = ironController.transferAllowed(address(this),src,dst,tokens) (RErc20Delegate.sol#1299)\n\tState variables written after the call(s):\n\t- accountTokens (RErc20Delegate.sol#1342)\n\t- accountTokens (RErc20Delegate.sol#1343)\n\t- transferAllowances (RErc20Delegate.sol#1347)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2818,
                    "vulnerability_to_line": 2845,
                    "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (uint) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                       // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                      // This is a compliant ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n\n\n        // Calculate the amount that was *actually* transferred\n\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\n\n    }\n\n\n",
                    "message": "RErc20.doTransferIn uses assembly (RErc20Delegate.sol#2818-2845)\n\t- RErc20Delegate.sol#2824-2837\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": 2876,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        token.transfer(to, amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n\n    }\n\n}\n\n\n",
                    "message": "RErc20.doTransferOut uses assembly (RErc20Delegate.sol#2854-2876)\n\t- RErc20Delegate.sol#2859-2872\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "RTokenInterface._setInterestRateModel (RErc20Delegate.sol#421) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "RToken._setInterestRateModel (RErc20Delegate.sol#2584-2594) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "rDelegatorInterface._setImplementation (RErc20Delegate.sol#469) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2895,
                    "vulnerability_to_line": 2907,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        // Shh -- currently unused\n\n        data;\n\n\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n\n    }\n\n\n",
                    "message": "RErc20Delegate._becomeImplementation (RErc20Delegate.sol#2895-2907) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "RDelegateInterface._becomeImplementation (RErc20Delegate.sol#478) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2910,
                    "vulnerability_to_line": 2918,
                    "vulnerability_code": "    function _resignImplementation() public {\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n\n    }\n",
                    "message": "RErc20Delegate._resignImplementation (RErc20Delegate.sol#2910-2918) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "RDelegateInterface._resignImplementation (RErc20Delegate.sol#483) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2687,
                    "vulnerability_to_line": 2702,
                    "vulnerability_code": "    function initialize(address underlying_,\n\n                        IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
                    "message": "RErc20.initialize (RErc20Delegate.sol#2687-2702) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in RErc20Delegate.sol:\n\t- pragma solidity^0.5.16 (RErc20Delegate.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegate.sol#77): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegate.sol#110): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegate.sol#183): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegate.sol#488): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegate.sol#553): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegate.sol#763): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegate.sol#851): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegate.sol#1049): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegate.sol#1233): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegate.sol#2668-2671): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegate.sol#2878-2881): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function enterMarkets(address[] calldata RTokens) external returns (uint[] memory);\n",
                    "message": "Parameter 'RTokens' of IronControllerInterface.enterMarkets (RErc20Delegate.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exitMarket(address RToken) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.exitMarket (RErc20Delegate.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintAllowed(address RToken, address minter, uint mintAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintAllowed (RErc20Delegate.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintVerify(address RToken, address minter, uint mintAmount, uint mintTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintVerify (RErc20Delegate.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemAllowed(address RToken, address redeemer, uint redeemTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemAllowed (RErc20Delegate.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemVerify(address RToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemVerify (RErc20Delegate.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowAllowed(address RToken, address borrower, uint borrowAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowAllowed (RErc20Delegate.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowVerify(address RToken, address borrower, uint borrowAmount) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowVerify (RErc20Delegate.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowAllowed (RErc20Delegate.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowVerify (RErc20Delegate.sol#31) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowAllowed (RErc20Delegate.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowAllowed (RErc20Delegate.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowVerify (RErc20Delegate.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowVerify (RErc20Delegate.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeAllowed (RErc20Delegate.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeAllowed (RErc20Delegate.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeVerify (RErc20Delegate.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeVerify (RErc20Delegate.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferAllowed(address RToken, address src, address dst, uint transfeRTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferAllowed (RErc20Delegate.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferVerify(address RToken, address src, address dst, uint transfeRTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferVerify (RErc20Delegate.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateCalculateSeizeTokens (RErc20Delegate.sol#70) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateCalculateSeizeTokens (RErc20Delegate.sol#71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isIronController = true;\n",
                    "message": "Constant 'IronControllerInterface.isIronController' (RErc20Delegate.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'InterestRateModel.isInterestRateModel' (RErc20Delegate.sol#85) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _notEntered;\n",
                    "message": "Variable 'RTokenStorage._notEntered' (RErc20Delegate.sol#191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
                    "message": "Constant 'RTokenStorage.borrowRateMaxMantissa' (RErc20Delegate.sol#212) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'RTokenStorage.reserveFactorMaxMantissa' (RErc20Delegate.sol#217) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setPendingAdmin' (RErc20Delegate.sol#416) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
                    "message": "Function 'RTokenInterface._acceptAdmin' (RErc20Delegate.sol#417) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setIronController' (RErc20Delegate.sol#418) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setReserveFactor' (RErc20Delegate.sol#419) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._reduceReserves' (RErc20Delegate.sol#420) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setInterestRateModel' (RErc20Delegate.sol#421) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isRToken = true;\n",
                    "message": "Constant 'RTokenInterface.isRToken' (RErc20Delegate.sol#304) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrow(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) external returns (uint);\n",
                    "message": "Parameter 'RTokenCollateral' of RErc20Interface.liquidateBorrow (RErc20Delegate.sol#441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
                    "message": "Function 'RErc20Interface._addReserves' (RErc20Delegate.sol#447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": 470,
                    "vulnerability_code": "contract rDelegatorInterface is RDelegationStorage {\n\n    /**\n\n     * @notice Emitted when implementation is changed\n\n     */\n\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n\n\n    /**\n\n     * @notice Called by the admin to update the implementation of the delegator\n\n     * @param implementation_ The address of the new implementation for delegation\n\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n\n     */\n\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Contract 'rDelegatorInterface' (RErc20Delegate.sol#457-470) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Function 'rDelegatorInterface._setImplementation' (RErc20Delegate.sol#469) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "Function 'RDelegateInterface._becomeImplementation' (RErc20Delegate.sol#478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "Function 'RDelegateInterface._resignImplementation' (RErc20Delegate.sol#483) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 886,
                    "vulnerability_to_line": 889,
                    "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncate' (RErc20Delegate.sol#886-889) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": 897,
                    "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncateAddUInt' (RErc20Delegate.sol#894-897) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant expScale = 1e18;\n",
                    "message": "Constant 'ExponentialNoError.expScale' (RErc20Delegate.sol#861) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant doubleScale = 1e36;\n",
                    "message": "Constant 'ExponentialNoError.doubleScale' (RErc20Delegate.sol#862) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'ExponentialNoError.halfExpScale' (RErc20Delegate.sol#863) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant mantissaOne = expScale;\n",
                    "message": "Constant 'ExponentialNoError.mantissaOne' (RErc20Delegate.sol#864) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2337,
                    "vulnerability_to_line": 2353,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Function 'RToken._setPendingAdmin' (RErc20Delegate.sol#2337-2353) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2360,
                    "vulnerability_to_line": 2383,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        // SWC-Code With No Effects: L1133\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._acceptAdmin' (RErc20Delegate.sol#2360-2383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2407,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_IRON_CONTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        IronControllerInterface oldIronController = ironController;\n\n        // Ensure invoke ironController.isIronController() returns true\n\n        require(newIronController.isIronController(), \"marker method returned false\");\n\n\n\n        // Set market's ironController to newIronController\n\n        ironController = newIronController;\n\n\n\n        // Emit NewIronController(oldIronController, newIronController)\n\n        emit NewIronController(oldIronController, newIronController);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setIronController' (RErc20Delegate.sol#2388-2407) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": 2422,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setReserveFactor' (RErc20Delegate.sol#2412-2422) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": 2529,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'RToken._reduceReserves' (RErc20Delegate.sol#2519-2529) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setInterestRateModel' (RErc20Delegate.sol#2584-2594) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal nonReentrant returns (uint, uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RToken.liquidateBorrowInternal (RErc20Delegate.sol#2159) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal returns (uint, uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RToken.liquidateBorrowFresh (RErc20Delegate.sol#2185) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": 2451,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setReserveFactorFresh' (RErc20Delegate.sol#2427-2451) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2468,
                    "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
                    "message": "Function 'RToken._addReservesInternal' (RErc20Delegate.sol#2456-2468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2474,
                    "vulnerability_to_line": 2514,
                    "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n\n\n        /* Revert on overflow */\n\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
                    "message": "Function 'RToken._addReservesFresh' (RErc20Delegate.sol#2474-2514) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2535,
                    "vulnerability_to_line": 2578,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._reduceReservesFresh' (RErc20Delegate.sol#2535-2578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2600,
                    "vulnerability_to_line": 2630,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setInterestRateModelFresh' (RErc20Delegate.sol#2600-2630) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrow(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) external returns (uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RErc20.liquidateBorrow (RErc20Delegate.sol#2773) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2793,
                    "vulnerability_to_line": 2797,
                    "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        return _addReservesInternal(addAmount);\n\n    }\n\n\n",
                    "message": "Function 'RErc20._addReserves' (RErc20Delegate.sol#2793-2797) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2895,
                    "vulnerability_to_line": 2907,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public {\n\n        // Shh -- currently unused\n\n        data;\n\n\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n\n    }\n\n\n",
                    "message": "Function 'RErc20Delegate._becomeImplementation' (RErc20Delegate.sol#2895-2907) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2910,
                    "vulnerability_to_line": 2918,
                    "vulnerability_code": "    function _resignImplementation() public {\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n\n    }\n",
                    "message": "Function 'RErc20Delegate._resignImplementation' (RErc20Delegate.sol#2910-2918) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2901,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            implementation = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            implementation = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2878,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 825,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1092,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2824,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2856,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2856,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2858,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool success;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2860,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2860,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    success := not(0)          // set success to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    success := not(0)          // set success to true\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/RToken/REther.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2821,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(IronControllerInterface ironController_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2687,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2688,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2690,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2691,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint8 decimals_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address payable admin_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Creator of the contract is admin during initialization\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2695,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(RTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newIronController.isIronController(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == from, \"sender mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == amount, \"value mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2821,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 2016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_96"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (REther.sol#117-179) has incorrect ERC20 function interface(s):\n\t-transfer (REther.sol#143)\n\t-transferFrom (REther.sol#157)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 2789,
                    "vulnerability_to_line": 2795,
                    "vulnerability_code": "    function getCashPrior() internal view returns (uint) {\n\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n\n        require(err == MathError.NO_ERROR);\n\n        return startingBalance;\n\n    }\n\n\n",
                    "message": "REther.getCashPrior (REther.sol#2789-2795) uses a dangerous strict equality:\n\t- require(bool)(err == MathError.NO_ERROR)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2468,
                    "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._addReservesInternal (REther.sol#2456-2468):\n\tExternal calls:\n\t- error = accrueInterest() (REther.sol#2457-2458)\n\tState variables written after the call(s):\n\t- totalReserves (REther.sol#2464-2465)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": 2529,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._reduceReserves (REther.sol#2519-2529):\n\tExternal calls:\n\t- error = accrueInterest() (REther.sol#2520-2521)\n\tState variables written after the call(s):\n\t- totalReserves (REther.sol#2526-2527)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setInterestRateModel (REther.sol#2584-2594):\n\tExternal calls:\n\t- error = accrueInterest() (REther.sol#2585-2586)\n\t- _setInterestRateModelFresh(newInterestRateModel) (REther.sol#2591-2592)\n\tState variables written after the call(s):\n\t- interestRateModel (REther.sol#2591-2592)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2600,
                    "vulnerability_to_line": 2630,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setInterestRateModelFresh (REther.sol#2600-2630):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (REther.sol#2619-2621)\n\tState variables written after the call(s):\n\t- interestRateModel (REther.sol#2622-2624)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2407,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_IRON_CONTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        IronControllerInterface oldIronController = ironController;\n\n        // Ensure invoke ironController.isIronController() returns true\n\n        require(newIronController.isIronController(), \"marker method returned false\");\n\n\n\n        // Set market's ironController to newIronController\n\n        ironController = newIronController;\n\n\n\n        // Emit NewIronController(oldIronController, newIronController)\n\n        emit NewIronController(oldIronController, newIronController);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setIronController (REther.sol#2388-2407):\n\tExternal calls:\n\t- require(bool,string)(newIronController.isIronController(),marker method returned false) (REther.sol#2396-2397)\n\tState variables written after the call(s):\n\t- ironController (REther.sol#2399-2400)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": 2422,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setReserveFactor (REther.sol#2412-2422):\n\tExternal calls:\n\t- error = accrueInterest() (REther.sol#2413-2414)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (REther.sol#2419-2420)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1614,
                    "vulnerability_to_line": 1692,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor;\n\n        uint interestAccumulated;\n\n        uint totalBorrowsNew;\n\n        uint totalReservesNew;\n\n        uint borrowIndexNew;\n\n\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.accrueInterest (REther.sol#1614-1692):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (REther.sol#1631)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (REther.sol#1683)\n\t- borrowIndex (REther.sol#1684)\n\t- totalBorrows (REther.sol#1685)\n\t- totalReserves (REther.sol#1686)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1945,
                    "vulnerability_to_line": 1953,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
                    "message": "Reentrancy in RToken.borrowInternal (REther.sol#1945-1953):\n\tExternal calls:\n\t- error = accrueInterest() (REther.sol#1946)\n\t- borrowFresh(msg.sender,borrowAmount) (REther.sol#1952)\n\tState variables written after the call(s):\n\t- totalBorrows (REther.sol#1952)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2686,
                    "vulnerability_to_line": 2703,
                    "vulnerability_code": "    constructor(IronControllerInterface ironController_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint8 decimals_,\n\n                address payable admin_) public {\n\n        // Creator of the contract is admin during initialization\n\n        admin = msg.sender;\n\n\n\n        initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set the proper admin now that initialization is done\n\n        admin = admin_;\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in REther.constructor (REther.sol#2686-2703):\n\tExternal calls:\n\t- initialize(ironController_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (REther.sol#2696-2698)\n\tState variables written after the call(s):\n\t- admin (REther.sol#2699-2700)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": 1286,
                    "vulnerability_code": "    function initialize(IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the ironController\n\n        uint err = _setIronController(ironController_);\n\n        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on ironController being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
                    "message": "Reentrancy in RToken.initialize (REther.sol#1255-1286):\n\tExternal calls:\n\t- err = _setIronController(ironController_) (REther.sol#1269)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (REther.sol#1273)\n\t- borrowIndex (REther.sol#1274)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2159,
                    "vulnerability_to_line": 2174,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = RTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, RTokenCollateral);\n",
                    "message": "Reentrancy in RToken.liquidateBorrowInternal (REther.sol#2159-2174):\n\tExternal calls:\n\t- error = accrueInterest() (REther.sol#2160)\n\t- error = RTokenCollateral.accrueInterest() (REther.sol#2166)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,RTokenCollateral) (REther.sol#2173)\n\tState variables written after the call(s):\n\t- totalBorrows (REther.sol#2173)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": 1938,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = ironController.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REDEEM_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        ironController.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.redeemFresh (REther.sol#1844-1938):\n\tExternal calls:\n\t- allowed = ironController.redeemAllowed(address(this),redeemer,vars.redeemTokens) (REther.sol#1884)\n\tState variables written after the call(s):\n\t- totalSupply (REther.sol#1927)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2054,
                    "vulnerability_to_line": 2062,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowBehalfInternal (REther.sol#2054-2062):\n\tExternal calls:\n\t- error = accrueInterest() (REther.sol#2055)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (REther.sol#2061)\n\tState variables written after the call(s):\n\t- totalBorrows (REther.sol#2061)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2038,
                    "vulnerability_to_line": 2046,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowInternal (REther.sol#2038-2046):\n\tExternal calls:\n\t- error = accrueInterest() (REther.sol#2039)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (REther.sol#2045)\n\tState variables written after the call(s):\n\t- totalBorrows (REther.sol#2045)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MintLocalVars memory vars;\n",
                    "message": "vars in RToken.mintFresh (REther.sol#1739) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 2094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
                    "message": "vars in RToken.repayBorrowFresh (REther.sol#2094) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 2477,
                    "vulnerability_to_line": 2479,
                    "vulnerability_code": "        uint actualAddAmount;\n\n\n",
                    "message": "actualAddAmount in RToken._addReservesFresh (REther.sol#2477-2479) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1984,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n",
                    "message": "vars in RToken.borrowFresh (REther.sol#1984) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": "vars in RToken.redeemFresh (REther.sol#1847) is a local variable never initialiazed\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
                    "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ REther.sol#1170) shadows:\n\t- ExponentialNoError.fraction (function @ REther.sol#1042-1044)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1967,
                    "vulnerability_to_line": 2031,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = ironController.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.BORROW_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.borrowFresh (REther.sol#1967-2031):\n\tExternal calls:\n\t- allowed = ironController.borrowAllowed(address(this),borrower,borrowAmount) (REther.sol#1969)\n\tState variables written after the call(s):\n\t- accountBorrows (REther.sol#2019)\n\t- accountBorrows (REther.sol#2020)\n\t- totalBorrows (REther.sol#2021)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": 1286,
                    "vulnerability_code": "    function initialize(IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the ironController\n\n        uint err = _setIronController(ironController_);\n\n        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on ironController being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
                    "message": "Reentrancy in RToken.initialize (REther.sol#1255-1286):\n\tExternal calls:\n\t- err = _setIronController(ironController_) (REther.sol#1269)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (REther.sol#1277)\n\tState variables written after the call(s):\n\t- _notEntered (REther.sol#1285)\n\t- decimals (REther.sol#1282)\n\t- name (REther.sol#1280)\n\t- symbol (REther.sol#1281)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": 1792,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = ironController.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.MINT_IRON_CONTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the RToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of RTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n\n\n        /*\n\n         * We calculate the new total supply of RTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n",
                    "message": "Reentrancy in RToken.mintFresh (REther.sol#1727-1792):\n\tExternal calls:\n\t- allowed = ironController.mintAllowed(address(this),minter,mintAmount) (REther.sol#1729)\n\tState variables written after the call(s):\n\t- accountTokens (REther.sol#1781)\n\t- totalSupply (REther.sol#1780)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": 1938,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = ironController.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REDEEM_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        ironController.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.redeemFresh (REther.sol#1844-1938):\n\tExternal calls:\n\t- allowed = ironController.redeemAllowed(address(this),redeemer,vars.redeemTokens) (REther.sol#1884)\n\tState variables written after the call(s):\n\t- accountTokens (REther.sol#1928)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2082,
                    "vulnerability_to_line": 2149,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = ironController.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REPAY_BORROW_IRON_CONTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowFresh (REther.sol#2082-2149):\n\tExternal calls:\n\t- allowed = ironController.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (REther.sol#2084)\n\tState variables written after the call(s):\n\t- accountBorrows (REther.sol#2137)\n\t- accountBorrows (REther.sol#2138)\n\t- totalBorrows (REther.sol#2139)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2279,
                    "vulnerability_to_line": 2326,
                    "vulnerability_code": "    function seizeInternal(address seizeRToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = ironController.seizeAllowed(address(this), seizeRToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borroweRTokensNew;\n\n        uint liquidatoRTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borroweRTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatoRTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borroweRTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatoRTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borroweRTokensNew;\n\n        accountTokens[liquidator] = liquidatoRTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.seizeVerify(address(this), seizeRToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.seizeInternal (REther.sol#2279-2326):\n\tExternal calls:\n\t- allowed = ironController.seizeAllowed(address(this),seizeRToken,liquidator,borrower,seizeTokens) (REther.sol#2281)\n\tState variables written after the call(s):\n\t- accountTokens (REther.sol#2315)\n\t- accountTokens (REther.sol#2316)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1297,
                    "vulnerability_to_line": 1357,
                    "vulnerability_code": "    function transfeRTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = ironController.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.TRANSFER_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srRTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srRTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srRTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // ironController.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.transfeRTokens (REther.sol#1297-1357):\n\tExternal calls:\n\t- allowed = ironController.transferAllowed(address(this),src,dst,tokens) (REther.sol#1299)\n\tState variables written after the call(s):\n\t- accountTokens (REther.sol#1342)\n\t- accountTokens (REther.sol#1343)\n\t- transferAllowances (REther.sol#1347)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public implementation;\n",
                    "message": "RDelegationStorage.implementation should be constant (REther.sol#454)\nRErc20Storage.underlying should be constant (REther.sol#428)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "RTokenInterface._setInterestRateModel (REther.sol#421) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "RToken._setInterestRateModel (REther.sol#2584-2594) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "rDelegatorInterface._setImplementation (REther.sol#469) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "RDelegateInterface._becomeImplementation (REther.sol#478) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "RDelegateInterface._resignImplementation (REther.sol#483) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in REther.sol:\n\t- pragma solidity^0.5.16 (REther.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (REther.sol#77): it allows old versions\n\t- pragma solidity^0.5.16 (REther.sol#110): it allows old versions\n\t- pragma solidity^0.5.16 (REther.sol#183): it allows old versions\n\t- pragma solidity^0.5.16 (REther.sol#488): it allows old versions\n\t- pragma solidity^0.5.16 (REther.sol#553): it allows old versions\n\t- pragma solidity^0.5.16 (REther.sol#763): it allows old versions\n\t- pragma solidity^0.5.16 (REther.sol#851): it allows old versions\n\t- pragma solidity^0.5.16 (REther.sol#1049): it allows old versions\n\t- pragma solidity^0.5.16 (REther.sol#1233): it allows old versions\n\t- pragma solidity^0.5.16 (REther.sol#2668-2671): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function enterMarkets(address[] calldata RTokens) external returns (uint[] memory);\n",
                    "message": "Parameter 'RTokens' of IronControllerInterface.enterMarkets (REther.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exitMarket(address RToken) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.exitMarket (REther.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintAllowed(address RToken, address minter, uint mintAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintAllowed (REther.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintVerify(address RToken, address minter, uint mintAmount, uint mintTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintVerify (REther.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemAllowed(address RToken, address redeemer, uint redeemTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemAllowed (REther.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemVerify(address RToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemVerify (REther.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowAllowed(address RToken, address borrower, uint borrowAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowAllowed (REther.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowVerify(address RToken, address borrower, uint borrowAmount) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowVerify (REther.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowAllowed (REther.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowVerify (REther.sol#31) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowAllowed (REther.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowAllowed (REther.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowVerify (REther.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowVerify (REther.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeAllowed (REther.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeAllowed (REther.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeVerify (REther.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeVerify (REther.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferAllowed(address RToken, address src, address dst, uint transfeRTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferAllowed (REther.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferVerify(address RToken, address src, address dst, uint transfeRTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferVerify (REther.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateCalculateSeizeTokens (REther.sol#70) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateCalculateSeizeTokens (REther.sol#71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isIronController = true;\n",
                    "message": "Constant 'IronControllerInterface.isIronController' (REther.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'InterestRateModel.isInterestRateModel' (REther.sol#85) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _notEntered;\n",
                    "message": "Variable 'RTokenStorage._notEntered' (REther.sol#191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
                    "message": "Constant 'RTokenStorage.borrowRateMaxMantissa' (REther.sol#212) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'RTokenStorage.reserveFactorMaxMantissa' (REther.sol#217) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setPendingAdmin' (REther.sol#416) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
                    "message": "Function 'RTokenInterface._acceptAdmin' (REther.sol#417) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setIronController' (REther.sol#418) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setReserveFactor' (REther.sol#419) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._reduceReserves' (REther.sol#420) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setInterestRateModel' (REther.sol#421) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isRToken = true;\n",
                    "message": "Constant 'RTokenInterface.isRToken' (REther.sol#304) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrow(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) external returns (uint);\n",
                    "message": "Parameter 'RTokenCollateral' of RErc20Interface.liquidateBorrow (REther.sol#441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
                    "message": "Function 'RErc20Interface._addReserves' (REther.sol#447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": 470,
                    "vulnerability_code": "contract rDelegatorInterface is RDelegationStorage {\n\n    /**\n\n     * @notice Emitted when implementation is changed\n\n     */\n\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n\n\n    /**\n\n     * @notice Called by the admin to update the implementation of the delegator\n\n     * @param implementation_ The address of the new implementation for delegation\n\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n\n     */\n\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Contract 'rDelegatorInterface' (REther.sol#457-470) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Function 'rDelegatorInterface._setImplementation' (REther.sol#469) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "Function 'RDelegateInterface._becomeImplementation' (REther.sol#478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "Function 'RDelegateInterface._resignImplementation' (REther.sol#483) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 886,
                    "vulnerability_to_line": 889,
                    "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncate' (REther.sol#886-889) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": 897,
                    "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncateAddUInt' (REther.sol#894-897) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant expScale = 1e18;\n",
                    "message": "Constant 'ExponentialNoError.expScale' (REther.sol#861) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant doubleScale = 1e36;\n",
                    "message": "Constant 'ExponentialNoError.doubleScale' (REther.sol#862) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'ExponentialNoError.halfExpScale' (REther.sol#863) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant mantissaOne = expScale;\n",
                    "message": "Constant 'ExponentialNoError.mantissaOne' (REther.sol#864) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2337,
                    "vulnerability_to_line": 2353,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Function 'RToken._setPendingAdmin' (REther.sol#2337-2353) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2360,
                    "vulnerability_to_line": 2383,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        // SWC-Code With No Effects: L1133\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._acceptAdmin' (REther.sol#2360-2383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2407,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_IRON_CONTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        IronControllerInterface oldIronController = ironController;\n\n        // Ensure invoke ironController.isIronController() returns true\n\n        require(newIronController.isIronController(), \"marker method returned false\");\n\n\n\n        // Set market's ironController to newIronController\n\n        ironController = newIronController;\n\n\n\n        // Emit NewIronController(oldIronController, newIronController)\n\n        emit NewIronController(oldIronController, newIronController);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setIronController' (REther.sol#2388-2407) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": 2422,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setReserveFactor' (REther.sol#2412-2422) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": 2529,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'RToken._reduceReserves' (REther.sol#2519-2529) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setInterestRateModel' (REther.sol#2584-2594) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal nonReentrant returns (uint, uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RToken.liquidateBorrowInternal (REther.sol#2159) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal returns (uint, uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RToken.liquidateBorrowFresh (REther.sol#2185) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": 2451,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setReserveFactorFresh' (REther.sol#2427-2451) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2468,
                    "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
                    "message": "Function 'RToken._addReservesInternal' (REther.sol#2456-2468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2474,
                    "vulnerability_to_line": 2514,
                    "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n\n\n        /* Revert on overflow */\n\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
                    "message": "Function 'RToken._addReservesFresh' (REther.sol#2474-2514) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2535,
                    "vulnerability_to_line": 2578,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._reduceReservesFresh' (REther.sol#2535-2578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2600,
                    "vulnerability_to_line": 2630,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setInterestRateModelFresh' (REther.sol#2600-2630) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2769,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrow(address borrower, RToken RTokenCollateral) external payable {\n",
                    "message": "Parameter 'RTokenCollateral' of REther.liquidateBorrow (REther.sol#2769) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2675,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract REther is RToken {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 825,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1092,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(IronControllerInterface ironController_,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2699,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = admin_;\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/RToken/RErc20Immutable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2897,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                IronControllerInterface ironController_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2899,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2900,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2901,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2903,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint8 decimals_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2904,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address payable admin_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2905,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Creator of the contract is admin during initialization\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2906,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(RTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newIronController.isIronController(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \trequire(address(token) != underlying, \"RErc20::sweepToken: can not sweep underlying token\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2841,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2872,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \trequire(address(token) != underlying, \"RErc20::sweepToken: can not sweep underlying token\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 2016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                },
                {
                    "name": "compound-sweeptoken-not-restricted",
                    "vulnerability_from_line": 2785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \ttoken.transfer(admin, balance);\n",
                    "message": "Function sweepToken is allowed to be called by anyone"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_100"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (RErc20Immutable.sol#117-179) has incorrect ERC20 function interface(s):\n\t-transfer (RErc20Immutable.sol#143)\n\t-transferFrom (RErc20Immutable.sol#157)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2468,
                    "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._addReservesInternal (RErc20Immutable.sol#2456-2468):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Immutable.sol#2457-2458)\n\tState variables written after the call(s):\n\t- totalReserves (RErc20Immutable.sol#2464-2465)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": 2529,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._reduceReserves (RErc20Immutable.sol#2519-2529):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Immutable.sol#2520-2521)\n\tState variables written after the call(s):\n\t- totalReserves (RErc20Immutable.sol#2526-2527)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setInterestRateModel (RErc20Immutable.sol#2584-2594):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Immutable.sol#2585-2586)\n\t- _setInterestRateModelFresh(newInterestRateModel) (RErc20Immutable.sol#2591-2592)\n\tState variables written after the call(s):\n\t- interestRateModel (RErc20Immutable.sol#2591-2592)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2600,
                    "vulnerability_to_line": 2630,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setInterestRateModelFresh (RErc20Immutable.sol#2600-2630):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (RErc20Immutable.sol#2619-2621)\n\tState variables written after the call(s):\n\t- interestRateModel (RErc20Immutable.sol#2622-2624)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2407,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_IRON_CONTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        IronControllerInterface oldIronController = ironController;\n\n        // Ensure invoke ironController.isIronController() returns true\n\n        require(newIronController.isIronController(), \"marker method returned false\");\n\n\n\n        // Set market's ironController to newIronController\n\n        ironController = newIronController;\n\n\n\n        // Emit NewIronController(oldIronController, newIronController)\n\n        emit NewIronController(oldIronController, newIronController);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setIronController (RErc20Immutable.sol#2388-2407):\n\tExternal calls:\n\t- require(bool,string)(newIronController.isIronController(),marker method returned false) (RErc20Immutable.sol#2396-2397)\n\tState variables written after the call(s):\n\t- ironController (RErc20Immutable.sol#2399-2400)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": 2422,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setReserveFactor (RErc20Immutable.sol#2412-2422):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Immutable.sol#2413-2414)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (RErc20Immutable.sol#2419-2420)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1614,
                    "vulnerability_to_line": 1692,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor;\n\n        uint interestAccumulated;\n\n        uint totalBorrowsNew;\n\n        uint totalReservesNew;\n\n        uint borrowIndexNew;\n\n\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.accrueInterest (RErc20Immutable.sol#1614-1692):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (RErc20Immutable.sol#1631)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (RErc20Immutable.sol#1683)\n\t- borrowIndex (RErc20Immutable.sol#1684)\n\t- totalBorrows (RErc20Immutable.sol#1685)\n\t- totalReserves (RErc20Immutable.sol#1686)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1945,
                    "vulnerability_to_line": 1953,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
                    "message": "Reentrancy in RToken.borrowInternal (RErc20Immutable.sol#1945-1953):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Immutable.sol#1946)\n\t- borrowFresh(msg.sender,borrowAmount) (RErc20Immutable.sol#1952)\n\tState variables written after the call(s):\n\t- totalBorrows (RErc20Immutable.sol#1952)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2897,
                    "vulnerability_to_line": 2914,
                    "vulnerability_code": "    constructor(address underlying_,\n\n                IronControllerInterface ironController_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint8 decimals_,\n\n                address payable admin_) public {\n\n        // Creator of the contract is admin during initialization\n\n        admin = msg.sender;\n\n\n\n        // Initialize the market\n\n        initialize(underlying_, ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set the proper admin now that initialization is done\n\n        admin = admin_;\n\n    }\n",
                    "message": "Reentrancy in RErc20Immutable.constructor (RErc20Immutable.sol#2897-2914):\n\tExternal calls:\n\t- initialize(underlying_,ironController_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (RErc20Immutable.sol#2909-2911)\n\tState variables written after the call(s):\n\t- admin (RErc20Immutable.sol#2912-2913)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": 1286,
                    "vulnerability_code": "    function initialize(IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the ironController\n\n        uint err = _setIronController(ironController_);\n\n        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on ironController being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
                    "message": "Reentrancy in RToken.initialize (RErc20Immutable.sol#1255-1286):\n\tExternal calls:\n\t- err = _setIronController(ironController_) (RErc20Immutable.sol#1269)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (RErc20Immutable.sol#1273)\n\t- borrowIndex (RErc20Immutable.sol#1274)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2159,
                    "vulnerability_to_line": 2174,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = RTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, RTokenCollateral);\n",
                    "message": "Reentrancy in RToken.liquidateBorrowInternal (RErc20Immutable.sol#2159-2174):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Immutable.sol#2160)\n\t- error = RTokenCollateral.accrueInterest() (RErc20Immutable.sol#2166)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,RTokenCollateral) (RErc20Immutable.sol#2173)\n\tState variables written after the call(s):\n\t- totalBorrows (RErc20Immutable.sol#2173)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": 1938,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = ironController.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REDEEM_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        ironController.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.redeemFresh (RErc20Immutable.sol#1844-1938):\n\tExternal calls:\n\t- allowed = ironController.redeemAllowed(address(this),redeemer,vars.redeemTokens) (RErc20Immutable.sol#1884)\n\tState variables written after the call(s):\n\t- totalSupply (RErc20Immutable.sol#1927)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2054,
                    "vulnerability_to_line": 2062,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowBehalfInternal (RErc20Immutable.sol#2054-2062):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Immutable.sol#2055)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (RErc20Immutable.sol#2061)\n\tState variables written after the call(s):\n\t- totalBorrows (RErc20Immutable.sol#2061)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2038,
                    "vulnerability_to_line": 2046,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowInternal (RErc20Immutable.sol#2038-2046):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20Immutable.sol#2039)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (RErc20Immutable.sol#2045)\n\tState variables written after the call(s):\n\t- totalBorrows (RErc20Immutable.sol#2045)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MintLocalVars memory vars;\n",
                    "message": "vars in RToken.mintFresh (RErc20Immutable.sol#1739) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1984,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n",
                    "message": "vars in RToken.borrowFresh (RErc20Immutable.sol#1984) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": "vars in RToken.redeemFresh (RErc20Immutable.sol#1847) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 2477,
                    "vulnerability_to_line": 2479,
                    "vulnerability_code": "        uint actualAddAmount;\n\n\n",
                    "message": "actualAddAmount in RToken._addReservesFresh (RErc20Immutable.sol#2477-2479) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 2094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
                    "message": "vars in RToken.repayBorrowFresh (RErc20Immutable.sol#2094) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2687,
                    "vulnerability_to_line": 2702,
                    "vulnerability_code": "    function initialize(address underlying_,\n\n                        IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
                    "message": "RErc20.initialize (RErc20Immutable.sol#2687-2702) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (RErc20Immutable.sol#2699-2700)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
                    "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ RErc20Immutable.sol#1170) shadows:\n\t- ExponentialNoError.fraction (function @ RErc20Immutable.sol#1042-1044)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1967,
                    "vulnerability_to_line": 2031,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = ironController.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.BORROW_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.borrowFresh (RErc20Immutable.sol#1967-2031):\n\tExternal calls:\n\t- allowed = ironController.borrowAllowed(address(this),borrower,borrowAmount) (RErc20Immutable.sol#1969)\n\tState variables written after the call(s):\n\t- accountBorrows (RErc20Immutable.sol#2019)\n\t- accountBorrows (RErc20Immutable.sol#2020)\n\t- totalBorrows (RErc20Immutable.sol#2021)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": 1286,
                    "vulnerability_code": "    function initialize(IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the ironController\n\n        uint err = _setIronController(ironController_);\n\n        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on ironController being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
                    "message": "Reentrancy in RToken.initialize (RErc20Immutable.sol#1255-1286):\n\tExternal calls:\n\t- err = _setIronController(ironController_) (RErc20Immutable.sol#1269)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (RErc20Immutable.sol#1277)\n\tState variables written after the call(s):\n\t- _notEntered (RErc20Immutable.sol#1285)\n\t- decimals (RErc20Immutable.sol#1282)\n\t- name (RErc20Immutable.sol#1280)\n\t- symbol (RErc20Immutable.sol#1281)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2687,
                    "vulnerability_to_line": 2702,
                    "vulnerability_code": "    function initialize(address underlying_,\n\n                        IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
                    "message": "Reentrancy in RErc20.initialize (RErc20Immutable.sol#2687-2702):\n\tExternal calls:\n\t- super.initialize(ironController_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (RErc20Immutable.sol#2695-2697)\n\tState variables written after the call(s):\n\t- underlying (RErc20Immutable.sol#2698-2699)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": 1792,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = ironController.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.MINT_IRON_CONTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the RToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of RTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n\n\n        /*\n\n         * We calculate the new total supply of RTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n",
                    "message": "Reentrancy in RToken.mintFresh (RErc20Immutable.sol#1727-1792):\n\tExternal calls:\n\t- allowed = ironController.mintAllowed(address(this),minter,mintAmount) (RErc20Immutable.sol#1729)\n\tState variables written after the call(s):\n\t- accountTokens (RErc20Immutable.sol#1781)\n\t- totalSupply (RErc20Immutable.sol#1780)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": 1938,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = ironController.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REDEEM_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        ironController.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.redeemFresh (RErc20Immutable.sol#1844-1938):\n\tExternal calls:\n\t- allowed = ironController.redeemAllowed(address(this),redeemer,vars.redeemTokens) (RErc20Immutable.sol#1884)\n\tState variables written after the call(s):\n\t- accountTokens (RErc20Immutable.sol#1928)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2082,
                    "vulnerability_to_line": 2149,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = ironController.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REPAY_BORROW_IRON_CONTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowFresh (RErc20Immutable.sol#2082-2149):\n\tExternal calls:\n\t- allowed = ironController.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (RErc20Immutable.sol#2084)\n\tState variables written after the call(s):\n\t- accountBorrows (RErc20Immutable.sol#2137)\n\t- accountBorrows (RErc20Immutable.sol#2138)\n\t- totalBorrows (RErc20Immutable.sol#2139)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2279,
                    "vulnerability_to_line": 2326,
                    "vulnerability_code": "    function seizeInternal(address seizeRToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = ironController.seizeAllowed(address(this), seizeRToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borroweRTokensNew;\n\n        uint liquidatoRTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borroweRTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatoRTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borroweRTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatoRTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borroweRTokensNew;\n\n        accountTokens[liquidator] = liquidatoRTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.seizeVerify(address(this), seizeRToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.seizeInternal (RErc20Immutable.sol#2279-2326):\n\tExternal calls:\n\t- allowed = ironController.seizeAllowed(address(this),seizeRToken,liquidator,borrower,seizeTokens) (RErc20Immutable.sol#2281)\n\tState variables written after the call(s):\n\t- accountTokens (RErc20Immutable.sol#2315)\n\t- accountTokens (RErc20Immutable.sol#2316)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1297,
                    "vulnerability_to_line": 1357,
                    "vulnerability_code": "    function transfeRTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = ironController.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.TRANSFER_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srRTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srRTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srRTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // ironController.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.transfeRTokens (RErc20Immutable.sol#1297-1357):\n\tExternal calls:\n\t- allowed = ironController.transferAllowed(address(this),src,dst,tokens) (RErc20Immutable.sol#1299)\n\tState variables written after the call(s):\n\t- accountTokens (RErc20Immutable.sol#1342)\n\t- accountTokens (RErc20Immutable.sol#1343)\n\t- transferAllowances (RErc20Immutable.sol#1347)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2818,
                    "vulnerability_to_line": 2845,
                    "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (uint) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                       // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                      // This is a compliant ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n\n\n        // Calculate the amount that was *actually* transferred\n\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\n\n    }\n\n\n",
                    "message": "RErc20.doTransferIn uses assembly (RErc20Immutable.sol#2818-2845)\n\t- RErc20Immutable.sol#2824-2837\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": 2876,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        token.transfer(to, amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n\n    }\n\n}\n\n\n",
                    "message": "RErc20.doTransferOut uses assembly (RErc20Immutable.sol#2854-2876)\n\t- RErc20Immutable.sol#2859-2872\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public implementation;\n",
                    "message": "RDelegationStorage.implementation should be constant (RErc20Immutable.sol#454)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "RToken._setInterestRateModel (RErc20Immutable.sol#2584-2594) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "RTokenInterface._setInterestRateModel (RErc20Immutable.sol#421) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "rDelegatorInterface._setImplementation (RErc20Immutable.sol#469) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "RDelegateInterface._becomeImplementation (RErc20Immutable.sol#478) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "RDelegateInterface._resignImplementation (RErc20Immutable.sol#483) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in RErc20Immutable.sol:\n\t- pragma solidity^0.5.16 (RErc20Immutable.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Immutable.sol#77): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Immutable.sol#110): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Immutable.sol#183): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Immutable.sol#488): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Immutable.sol#553): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Immutable.sol#763): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Immutable.sol#851): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Immutable.sol#1049): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Immutable.sol#1233): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Immutable.sol#2668-2671): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Immutable.sol#2878-2881): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function enterMarkets(address[] calldata RTokens) external returns (uint[] memory);\n",
                    "message": "Parameter 'RTokens' of IronControllerInterface.enterMarkets (RErc20Immutable.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exitMarket(address RToken) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.exitMarket (RErc20Immutable.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintAllowed(address RToken, address minter, uint mintAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintAllowed (RErc20Immutable.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintVerify(address RToken, address minter, uint mintAmount, uint mintTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintVerify (RErc20Immutable.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemAllowed(address RToken, address redeemer, uint redeemTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemAllowed (RErc20Immutable.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemVerify(address RToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemVerify (RErc20Immutable.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowAllowed(address RToken, address borrower, uint borrowAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowAllowed (RErc20Immutable.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowVerify(address RToken, address borrower, uint borrowAmount) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowVerify (RErc20Immutable.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowAllowed (RErc20Immutable.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowVerify (RErc20Immutable.sol#31) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowAllowed (RErc20Immutable.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowAllowed (RErc20Immutable.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowVerify (RErc20Immutable.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowVerify (RErc20Immutable.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeAllowed (RErc20Immutable.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeAllowed (RErc20Immutable.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeVerify (RErc20Immutable.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeVerify (RErc20Immutable.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferAllowed(address RToken, address src, address dst, uint transfeRTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferAllowed (RErc20Immutable.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferVerify(address RToken, address src, address dst, uint transfeRTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferVerify (RErc20Immutable.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateCalculateSeizeTokens (RErc20Immutable.sol#70) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateCalculateSeizeTokens (RErc20Immutable.sol#71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isIronController = true;\n",
                    "message": "Constant 'IronControllerInterface.isIronController' (RErc20Immutable.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'InterestRateModel.isInterestRateModel' (RErc20Immutable.sol#85) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _notEntered;\n",
                    "message": "Variable 'RTokenStorage._notEntered' (RErc20Immutable.sol#191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
                    "message": "Constant 'RTokenStorage.borrowRateMaxMantissa' (RErc20Immutable.sol#212) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'RTokenStorage.reserveFactorMaxMantissa' (RErc20Immutable.sol#217) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setPendingAdmin' (RErc20Immutable.sol#416) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
                    "message": "Function 'RTokenInterface._acceptAdmin' (RErc20Immutable.sol#417) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setIronController' (RErc20Immutable.sol#418) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setReserveFactor' (RErc20Immutable.sol#419) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._reduceReserves' (RErc20Immutable.sol#420) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setInterestRateModel' (RErc20Immutable.sol#421) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isRToken = true;\n",
                    "message": "Constant 'RTokenInterface.isRToken' (RErc20Immutable.sol#304) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrow(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) external returns (uint);\n",
                    "message": "Parameter 'RTokenCollateral' of RErc20Interface.liquidateBorrow (RErc20Immutable.sol#441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
                    "message": "Function 'RErc20Interface._addReserves' (RErc20Immutable.sol#447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": 470,
                    "vulnerability_code": "contract rDelegatorInterface is RDelegationStorage {\n\n    /**\n\n     * @notice Emitted when implementation is changed\n\n     */\n\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n\n\n    /**\n\n     * @notice Called by the admin to update the implementation of the delegator\n\n     * @param implementation_ The address of the new implementation for delegation\n\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n\n     */\n\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Contract 'rDelegatorInterface' (RErc20Immutable.sol#457-470) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Function 'rDelegatorInterface._setImplementation' (RErc20Immutable.sol#469) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "Function 'RDelegateInterface._becomeImplementation' (RErc20Immutable.sol#478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "Function 'RDelegateInterface._resignImplementation' (RErc20Immutable.sol#483) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 886,
                    "vulnerability_to_line": 889,
                    "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncate' (RErc20Immutable.sol#886-889) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": 897,
                    "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncateAddUInt' (RErc20Immutable.sol#894-897) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant expScale = 1e18;\n",
                    "message": "Constant 'ExponentialNoError.expScale' (RErc20Immutable.sol#861) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant doubleScale = 1e36;\n",
                    "message": "Constant 'ExponentialNoError.doubleScale' (RErc20Immutable.sol#862) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'ExponentialNoError.halfExpScale' (RErc20Immutable.sol#863) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant mantissaOne = expScale;\n",
                    "message": "Constant 'ExponentialNoError.mantissaOne' (RErc20Immutable.sol#864) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2337,
                    "vulnerability_to_line": 2353,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Function 'RToken._setPendingAdmin' (RErc20Immutable.sol#2337-2353) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2360,
                    "vulnerability_to_line": 2383,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        // SWC-Code With No Effects: L1133\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._acceptAdmin' (RErc20Immutable.sol#2360-2383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2407,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_IRON_CONTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        IronControllerInterface oldIronController = ironController;\n\n        // Ensure invoke ironController.isIronController() returns true\n\n        require(newIronController.isIronController(), \"marker method returned false\");\n\n\n\n        // Set market's ironController to newIronController\n\n        ironController = newIronController;\n\n\n\n        // Emit NewIronController(oldIronController, newIronController)\n\n        emit NewIronController(oldIronController, newIronController);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setIronController' (RErc20Immutable.sol#2388-2407) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": 2422,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setReserveFactor' (RErc20Immutable.sol#2412-2422) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": 2529,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'RToken._reduceReserves' (RErc20Immutable.sol#2519-2529) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setInterestRateModel' (RErc20Immutable.sol#2584-2594) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal nonReentrant returns (uint, uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RToken.liquidateBorrowInternal (RErc20Immutable.sol#2159) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal returns (uint, uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RToken.liquidateBorrowFresh (RErc20Immutable.sol#2185) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": 2451,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setReserveFactorFresh' (RErc20Immutable.sol#2427-2451) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2468,
                    "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
                    "message": "Function 'RToken._addReservesInternal' (RErc20Immutable.sol#2456-2468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2474,
                    "vulnerability_to_line": 2514,
                    "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n\n\n        /* Revert on overflow */\n\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
                    "message": "Function 'RToken._addReservesFresh' (RErc20Immutable.sol#2474-2514) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2535,
                    "vulnerability_to_line": 2578,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._reduceReservesFresh' (RErc20Immutable.sol#2535-2578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2600,
                    "vulnerability_to_line": 2630,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setInterestRateModelFresh' (RErc20Immutable.sol#2600-2630) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrow(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) external returns (uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RErc20.liquidateBorrow (RErc20Immutable.sol#2773) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2793,
                    "vulnerability_to_line": 2797,
                    "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        return _addReservesInternal(addAmount);\n\n    }\n\n\n",
                    "message": "Function 'RErc20._addReserves' (RErc20Immutable.sol#2793-2797) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2885,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RErc20Immutable is RErc20 {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2878,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 825,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1092,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2824,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2897,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2856,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2856,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2858,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool success;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2860,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2860,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    success := not(0)          // set success to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    success := not(0)          // set success to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2909,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        initialize(underlying_, ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2909,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        initialize(underlying_, ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2909,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        initialize(underlying_, ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2909,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        initialize(underlying_, ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2912,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = admin_;\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/RToken/RErc20Delegator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                IronControllerInterface ironController_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 515,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint8 decimals_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 516,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address payable admin_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address implementation_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                bytes memory becomeImplementationData) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"RErc20Delegator::_setImplementation: Caller must be admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 947,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == 0,\"RErc20Delegator:fallback: cannot send value to fallback\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"RErc20Delegator::_setImplementation: Caller must be admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 947,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == 0,\"RErc20Delegator:fallback: cannot send value to fallback\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_78"
            ],
            "vulnerability_findings": [
                {
                    "name": "controlled-delegatecall",
                    "vulnerability_from_line": 905,
                    "vulnerability_to_line": 913,
                    "vulnerability_code": "    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return returnData;\n",
                    "message": "RErc20Delegator.delegateTo (RErc20Delegator.sol#905-913) uses delegatecall to a input-controlled function id\n\t(success,returnData) = callee.delegatecall(data) (RErc20Delegator.sol#906)\n"
                },
                {
                    "name": "controlled-delegatecall",
                    "vulnerability_from_line": 946,
                    "vulnerability_to_line": 960,
                    "vulnerability_code": "    function () external payable {\n\n        require(msg.value == 0,\"RErc20Delegator:fallback: cannot send value to fallback\");\n\n\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n            case 0 { revert(free_mem_ptr, returndatasize) }\n\n            default { return(free_mem_ptr, returndatasize) }\n\n        }\n",
                    "message": "RErc20Delegator.fallback (RErc20Delegator.sol#946-960) uses delegatecall to a input-controlled function id\n\t(success) = implementation.delegatecall(msg.data) (RErc20Delegator.sol#950)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 932,
                    "vulnerability_to_line": 940,
                    "vulnerability_code": "    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return abi.decode(returnData, (bytes));\n",
                    "message": "RErc20Delegator.delegateToViewImplementation (RErc20Delegator.sol#932-940) is declared view but contains assembly code\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (RErc20Delegator.sol#117-179) has incorrect ERC20 function interface(s):\n\t-transfer (RErc20Delegator.sol#143)\n\t-transferFrom (RErc20Delegator.sol#157)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": 558,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\n\n        require(msg.sender == admin, \"RErc20Delegator::_setImplementation: Caller must be admin\");\n\n\n\n        if (allowResign) {\n\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n\n        }\n\n\n\n        address oldImplementation = implementation;\n\n        implementation = implementation_;\n\n\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n\n\n        emit NewImplementation(oldImplementation, implementation);\n",
                    "message": "Reentrancy in RErc20Delegator._setImplementation (RErc20Delegator.sol#545-558):\n\tExternal calls:\n\t- delegateToImplementation(abi.encodeWithSignature(_resignImplementation())) (RErc20Delegator.sol#549)\n\tState variables written after the call(s):\n\t- implementation (RErc20Delegator.sol#553)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": 537,
                    "vulnerability_code": "    constructor(address underlying_,\n\n                IronControllerInterface ironController_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint8 decimals_,\n\n                address payable admin_,\n\n                address implementation_,\n\n                bytes memory becomeImplementationData) public {\n\n        // Creator of the contract is admin during initialization\n\n        admin = msg.sender;\n\n\n\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n\n                                                            underlying_,\n\n                                                            ironController_,\n\n                                                            interestRateModel_,\n\n                                                            initialExchangeRateMantissa_,\n\n                                                            name_,\n\n                                                            symbol_,\n\n                                                            decimals_));\n\n\n\n        // New implementations always get set via the settor (post-initialize)\n\n        _setImplementation(implementation_, false, becomeImplementationData);\n\n\n\n        // Set the proper admin now that initialization is done\n\n        admin = admin_;\n",
                    "message": "Reentrancy in RErc20Delegator.constructor (RErc20Delegator.sol#509-537):\n\tExternal calls:\n\t- delegateTo(implementation_,abi.encodeWithSignature(initialize(address,address,address,uint256,string,string,uint8),underlying_,ironController_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_)) (RErc20Delegator.sol#523-530)\n\t- _setImplementation(implementation_,false,becomeImplementationData) (RErc20Delegator.sol#533)\n\tState variables written after the call(s):\n\t- admin (RErc20Delegator.sol#536)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 905,
                    "vulnerability_to_line": 913,
                    "vulnerability_code": "    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return returnData;\n",
                    "message": "RErc20Delegator.delegateTo uses assembly (RErc20Delegator.sol#905-913)\n\t- RErc20Delegator.sol#907-911\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 932,
                    "vulnerability_to_line": 940,
                    "vulnerability_code": "    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return abi.decode(returnData, (bytes));\n",
                    "message": "RErc20Delegator.delegateToViewImplementation uses assembly (RErc20Delegator.sol#932-940)\n\t- RErc20Delegator.sol#934-938\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 946,
                    "vulnerability_to_line": 960,
                    "vulnerability_code": "    function () external payable {\n\n        require(msg.value == 0,\"RErc20Delegator:fallback: cannot send value to fallback\");\n\n\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n            case 0 { revert(free_mem_ptr, returndatasize) }\n\n            default { return(free_mem_ptr, returndatasize) }\n\n        }\n",
                    "message": "RErc20Delegator.fallback uses assembly (RErc20Delegator.sol#946-960)\n\t- RErc20Delegator.sol#952-959\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public underlying;\n",
                    "message": "RErc20Storage.underlying should be constant (RErc20Delegator.sol#428)\nRTokenStorage._notEntered should be constant (RErc20Delegator.sol#191)\nRTokenStorage.accrualBlockNumber should be constant (RErc20Delegator.sol#252)\nRTokenStorage.borrowIndex should be constant (RErc20Delegator.sol#257)\nRTokenStorage.decimals should be constant (RErc20Delegator.sol#206)\nRTokenStorage.initialExchangeRateMantissa should be constant (RErc20Delegator.sol#242)\nRTokenStorage.name should be constant (RErc20Delegator.sol#196)\nRTokenStorage.pendingAdmin should be constant (RErc20Delegator.sol#227)\nRTokenStorage.reserveFactorMantissa should be constant (RErc20Delegator.sol#247)\nRTokenStorage.symbol should be constant (RErc20Delegator.sol#201)\nRTokenStorage.totalBorrows should be constant (RErc20Delegator.sol#262)\nRTokenStorage.totalReserves should be constant (RErc20Delegator.sol#267)\nRTokenStorage.totalSupply should be constant (RErc20Delegator.sol#272)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 758,
                    "vulnerability_to_line": 761,
                    "vulnerability_code": "    function borrowBalanceStored(address account) public view returns (uint) {\n\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowBalanceStored(address)\", account));\n\n        return abi.decode(data, (uint));\n",
                    "message": "RErc20Delegator.borrowBalanceStored (RErc20Delegator.sol#758-761) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStored(address account) public view returns (uint);\n",
                    "message": "RTokenInterface.borrowBalanceStored (RErc20Delegator.sol#406) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateCurrent() public returns (uint);\n",
                    "message": "RTokenInterface.exchangeRateCurrent (RErc20Delegator.sol#407) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": 770,
                    "vulnerability_code": "    function exchangeRateCurrent() public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"exchangeRateCurrent()\"));\n\n        return abi.decode(data, (uint));\n",
                    "message": "RErc20Delegator.exchangeRateCurrent (RErc20Delegator.sol#767-770) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": 780,
                    "vulnerability_code": "    function exchangeRateStored() public view returns (uint) {\n\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"exchangeRateStored()\"));\n\n        return abi.decode(data, (uint));\n",
                    "message": "RErc20Delegator.exchangeRateStored (RErc20Delegator.sol#777-780) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 408,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStored() public view returns (uint);\n",
                    "message": "RTokenInterface.exchangeRateStored (RErc20Delegator.sol#408) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 796,
                    "vulnerability_to_line": 799,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"accrueInterest()\"));\n\n        return abi.decode(data, (uint));\n",
                    "message": "RErc20Delegator.accrueInterest (RErc20Delegator.sol#796-799) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function accrueInterest() public returns (uint);\n",
                    "message": "RTokenInterface.accrueInterest (RErc20Delegator.sol#410) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint);\n",
                    "message": "RTokenInterface._setIronController (RErc20Delegator.sol#418) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": 845,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setIronController(address)\", newIronController));\n\n        return abi.decode(data, (uint));\n",
                    "message": "RErc20Delegator._setIronController (RErc20Delegator.sol#842-845) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": 896,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel));\n\n        return abi.decode(data, (uint));\n",
                    "message": "RErc20Delegator._setInterestRateModel (RErc20Delegator.sol#893-896) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "RTokenInterface._setInterestRateModel (RErc20Delegator.sol#421) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "RDelegateInterface._becomeImplementation (RErc20Delegator.sol#478) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "RDelegateInterface._resignImplementation (RErc20Delegator.sol#483) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in RErc20Delegator.sol:\n\t- pragma solidity^0.5.16 (RErc20Delegator.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegator.sol#36): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegator.sol#110): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegator.sol#183): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20Delegator.sol#488): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 905,
                    "vulnerability_to_line": 913,
                    "vulnerability_code": "    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return returnData;\n",
                    "message": "Low level call in RErc20Delegator.delegateTo (RErc20Delegator.sol#905-913):\n\t-(success,returnData) = callee.delegatecall(data) RErc20Delegator.sol#906\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 932,
                    "vulnerability_to_line": 940,
                    "vulnerability_code": "    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n\n        assembly {\n\n            if eq(success, 0) {\n\n                revert(add(returnData, 0x20), returndatasize)\n\n            }\n\n        }\n\n        return abi.decode(returnData, (bytes));\n",
                    "message": "Low level call in RErc20Delegator.delegateToViewImplementation (RErc20Delegator.sol#932-940):\n\t-(success,returnData) = address(this).staticcall(abi.encodeWithSignature(delegateToImplementation(bytes),data)) RErc20Delegator.sol#933\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 946,
                    "vulnerability_to_line": 960,
                    "vulnerability_code": "    function () external payable {\n\n        require(msg.value == 0,\"RErc20Delegator:fallback: cannot send value to fallback\");\n\n\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n            case 0 { revert(free_mem_ptr, returndatasize) }\n\n            default { return(free_mem_ptr, returndatasize) }\n\n        }\n",
                    "message": "Low level call in RErc20Delegator.fallback (RErc20Delegator.sol#946-960):\n\t-(success) = implementation.delegatecall(msg.data) RErc20Delegator.sol#950\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'InterestRateModel.isInterestRateModel' (RErc20Delegator.sol#11) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function enterMarkets(address[] calldata RTokens) external returns (uint[] memory);\n",
                    "message": "Parameter 'RTokens' of IronControllerInterface.enterMarkets (RErc20Delegator.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exitMarket(address RToken) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.exitMarket (RErc20Delegator.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintAllowed(address RToken, address minter, uint mintAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintAllowed (RErc20Delegator.sol#49) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintVerify(address RToken, address minter, uint mintAmount, uint mintTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintVerify (RErc20Delegator.sol#50) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemAllowed(address RToken, address redeemer, uint redeemTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemAllowed (RErc20Delegator.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemVerify(address RToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemVerify (RErc20Delegator.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowAllowed(address RToken, address borrower, uint borrowAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowAllowed (RErc20Delegator.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowVerify(address RToken, address borrower, uint borrowAmount) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowVerify (RErc20Delegator.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowAllowed (RErc20Delegator.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowVerify (RErc20Delegator.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowAllowed (RErc20Delegator.sol#71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowAllowed (RErc20Delegator.sol#72) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowVerify (RErc20Delegator.sol#77) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowVerify (RErc20Delegator.sol#78) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeAllowed (RErc20Delegator.sol#85) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeAllowed (RErc20Delegator.sol#86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeVerify (RErc20Delegator.sol#91) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeVerify (RErc20Delegator.sol#92) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferAllowed(address RToken, address src, address dst, uint transfeRTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferAllowed (RErc20Delegator.sol#97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferVerify(address RToken, address src, address dst, uint transfeRTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferVerify (RErc20Delegator.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateCalculateSeizeTokens (RErc20Delegator.sol#103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateCalculateSeizeTokens (RErc20Delegator.sol#104) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isIronController = true;\n",
                    "message": "Constant 'IronControllerInterface.isIronController' (RErc20Delegator.sol#40) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _notEntered;\n",
                    "message": "Variable 'RTokenStorage._notEntered' (RErc20Delegator.sol#191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
                    "message": "Constant 'RTokenStorage.borrowRateMaxMantissa' (RErc20Delegator.sol#212) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'RTokenStorage.reserveFactorMaxMantissa' (RErc20Delegator.sol#217) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setPendingAdmin' (RErc20Delegator.sol#416) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
                    "message": "Function 'RTokenInterface._acceptAdmin' (RErc20Delegator.sol#417) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setIronController' (RErc20Delegator.sol#418) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setReserveFactor' (RErc20Delegator.sol#419) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._reduceReserves' (RErc20Delegator.sol#420) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setInterestRateModel' (RErc20Delegator.sol#421) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isRToken = true;\n",
                    "message": "Constant 'RTokenInterface.isRToken' (RErc20Delegator.sol#304) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrow(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) external returns (uint);\n",
                    "message": "Parameter 'RTokenCollateral' of RErc20Interface.liquidateBorrow (RErc20Delegator.sol#441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
                    "message": "Function 'RErc20Interface._addReserves' (RErc20Delegator.sol#447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": 470,
                    "vulnerability_code": "contract rDelegatorInterface is RDelegationStorage {\n\n    /**\n\n     * @notice Emitted when implementation is changed\n\n     */\n\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n\n\n    /**\n\n     * @notice Called by the admin to update the implementation of the delegator\n\n     * @param implementation_ The address of the new implementation for delegation\n\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n\n     */\n\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Contract 'rDelegatorInterface' (RErc20Delegator.sol#457-470) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Function 'rDelegatorInterface._setImplementation' (RErc20Delegator.sol#469) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "Function 'RDelegateInterface._becomeImplementation' (RErc20Delegator.sol#478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "Function 'RDelegateInterface._resignImplementation' (RErc20Delegator.sol#483) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 832,
                    "vulnerability_to_line": 835,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin));\n\n        return abi.decode(data, (uint));\n",
                    "message": "Function 'RErc20Delegator._setPendingAdmin' (RErc20Delegator.sol#832-835) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": 865,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_acceptAdmin()\"));\n\n        return abi.decode(data, (uint));\n",
                    "message": "Function 'RErc20Delegator._acceptAdmin' (RErc20Delegator.sol#862-865) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": 845,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setIronController(address)\", newIronController));\n\n        return abi.decode(data, (uint));\n",
                    "message": "Function 'RErc20Delegator._setIronController' (RErc20Delegator.sol#842-845) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": 855,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setReserveFactor(uint256)\", newReserveFactorMantissa));\n\n        return abi.decode(data, (uint));\n",
                    "message": "Function 'RErc20Delegator._setReserveFactor' (RErc20Delegator.sol#852-855) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 882,
                    "vulnerability_to_line": 885,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount));\n\n        return abi.decode(data, (uint));\n",
                    "message": "Function 'RErc20Delegator._reduceReserves' (RErc20Delegator.sol#882-885) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": 896,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel));\n\n        return abi.decode(data, (uint));\n",
                    "message": "Function 'RErc20Delegator._setInterestRateModel' (RErc20Delegator.sol#893-896) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrow(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) external returns (uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RErc20Delegator.liquidateBorrow (RErc20Delegator.sol#632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 872,
                    "vulnerability_to_line": 875,
                    "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount));\n\n        return abi.decode(data, (uint));\n",
                    "message": "Function 'RErc20Delegator._addReserves' (RErc20Delegator.sol#872-875) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": 558,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\n\n        require(msg.sender == admin, \"RErc20Delegator::_setImplementation: Caller must be admin\");\n\n\n\n        if (allowResign) {\n\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n\n        }\n\n\n\n        address oldImplementation = implementation;\n\n        implementation = implementation_;\n\n\n\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n\n\n        emit NewImplementation(oldImplementation, implementation);\n",
                    "message": "Function 'RErc20Delegator._setImplementation' (RErc20Delegator.sol#545-558) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _notEntered;\n",
                    "message": "RTokenStorage._notEntered (RErc20Delegator.sol#191) is never used in RErc20Delegator\nRTokenStorage.borrowRateMaxMantissa (RErc20Delegator.sol#212) is never used in RErc20Delegator\nRTokenStorage.reserveFactorMaxMantissa (RErc20Delegator.sol#217) is never used in RErc20Delegator\nRTokenStorage.initialExchangeRateMantissa (RErc20Delegator.sol#242) is never used in RErc20Delegator\nRTokenStorage.accountTokens (RErc20Delegator.sol#277) is never used in RErc20Delegator\nRTokenStorage.transferAllowances (RErc20Delegator.sol#282) is never used in RErc20Delegator\nRTokenStorage.accountBorrows (RErc20Delegator.sol#297) is never used in RErc20Delegator\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RErc20Delegator is RTokenInterface, RErc20Interface, rDelegatorInterface {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 516,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address payable admin_,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                address implementation_,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                bytes memory becomeImplementationData) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                                                            ironController_,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                                                            initialExchangeRateMantissa_,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                                                            symbol_,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _setImplementation(implementation_, false, becomeImplementationData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _setImplementation(implementation_, false, becomeImplementationData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = admin_;\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/RToken/RToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(RTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newIronController.isIronController(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 2016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_94"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (RToken.sol#117-179) has incorrect ERC20 function interface(s):\n\t-transfer (RToken.sol#143)\n\t-transferFrom (RToken.sol#157)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2468,
                    "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._addReservesInternal (RToken.sol#2456-2468):\n\tExternal calls:\n\t- error = accrueInterest() (RToken.sol#2457-2458)\n\tState variables written after the call(s):\n\t- totalReserves (RToken.sol#2464-2465)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": 2529,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._reduceReserves (RToken.sol#2519-2529):\n\tExternal calls:\n\t- error = accrueInterest() (RToken.sol#2520-2521)\n\tState variables written after the call(s):\n\t- totalReserves (RToken.sol#2526-2527)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setInterestRateModel (RToken.sol#2584-2594):\n\tExternal calls:\n\t- error = accrueInterest() (RToken.sol#2585-2586)\n\t- _setInterestRateModelFresh(newInterestRateModel) (RToken.sol#2591-2592)\n\tState variables written after the call(s):\n\t- interestRateModel (RToken.sol#2591-2592)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2600,
                    "vulnerability_to_line": 2630,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setInterestRateModelFresh (RToken.sol#2600-2630):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (RToken.sol#2619-2621)\n\tState variables written after the call(s):\n\t- interestRateModel (RToken.sol#2622-2624)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2407,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_IRON_CONTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        IronControllerInterface oldIronController = ironController;\n\n        // Ensure invoke ironController.isIronController() returns true\n\n        require(newIronController.isIronController(), \"marker method returned false\");\n\n\n\n        // Set market's ironController to newIronController\n\n        ironController = newIronController;\n\n\n\n        // Emit NewIronController(oldIronController, newIronController)\n\n        emit NewIronController(oldIronController, newIronController);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setIronController (RToken.sol#2388-2407):\n\tExternal calls:\n\t- require(bool,string)(newIronController.isIronController(),marker method returned false) (RToken.sol#2396-2397)\n\tState variables written after the call(s):\n\t- ironController (RToken.sol#2399-2400)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": 2422,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setReserveFactor (RToken.sol#2412-2422):\n\tExternal calls:\n\t- error = accrueInterest() (RToken.sol#2413-2414)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (RToken.sol#2419-2420)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1614,
                    "vulnerability_to_line": 1692,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor;\n\n        uint interestAccumulated;\n\n        uint totalBorrowsNew;\n\n        uint totalReservesNew;\n\n        uint borrowIndexNew;\n\n\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.accrueInterest (RToken.sol#1614-1692):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (RToken.sol#1631)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (RToken.sol#1683)\n\t- borrowIndex (RToken.sol#1684)\n\t- totalBorrows (RToken.sol#1685)\n\t- totalReserves (RToken.sol#1686)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1945,
                    "vulnerability_to_line": 1953,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
                    "message": "Reentrancy in RToken.borrowInternal (RToken.sol#1945-1953):\n\tExternal calls:\n\t- error = accrueInterest() (RToken.sol#1946)\n\t- borrowFresh(msg.sender,borrowAmount) (RToken.sol#1952)\n\tState variables written after the call(s):\n\t- totalBorrows (RToken.sol#1952)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": 1286,
                    "vulnerability_code": "    function initialize(IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the ironController\n\n        uint err = _setIronController(ironController_);\n\n        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on ironController being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
                    "message": "Reentrancy in RToken.initialize (RToken.sol#1255-1286):\n\tExternal calls:\n\t- err = _setIronController(ironController_) (RToken.sol#1269)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (RToken.sol#1273)\n\t- borrowIndex (RToken.sol#1274)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2159,
                    "vulnerability_to_line": 2174,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = RTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, RTokenCollateral);\n",
                    "message": "Reentrancy in RToken.liquidateBorrowInternal (RToken.sol#2159-2174):\n\tExternal calls:\n\t- error = accrueInterest() (RToken.sol#2160)\n\t- error = RTokenCollateral.accrueInterest() (RToken.sol#2166)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,RTokenCollateral) (RToken.sol#2173)\n\tState variables written after the call(s):\n\t- totalBorrows (RToken.sol#2173)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": 1938,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = ironController.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REDEEM_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        ironController.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.redeemFresh (RToken.sol#1844-1938):\n\tExternal calls:\n\t- allowed = ironController.redeemAllowed(address(this),redeemer,vars.redeemTokens) (RToken.sol#1884)\n\tState variables written after the call(s):\n\t- totalSupply (RToken.sol#1927)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2054,
                    "vulnerability_to_line": 2062,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowBehalfInternal (RToken.sol#2054-2062):\n\tExternal calls:\n\t- error = accrueInterest() (RToken.sol#2055)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (RToken.sol#2061)\n\tState variables written after the call(s):\n\t- totalBorrows (RToken.sol#2061)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2038,
                    "vulnerability_to_line": 2046,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowInternal (RToken.sol#2038-2046):\n\tExternal calls:\n\t- error = accrueInterest() (RToken.sol#2039)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (RToken.sol#2045)\n\tState variables written after the call(s):\n\t- totalBorrows (RToken.sol#2045)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 2094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
                    "message": "vars in RToken.repayBorrowFresh (RToken.sol#2094) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 2477,
                    "vulnerability_to_line": 2479,
                    "vulnerability_code": "        uint actualAddAmount;\n\n\n",
                    "message": "actualAddAmount in RToken._addReservesFresh (RToken.sol#2477-2479) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1984,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n",
                    "message": "vars in RToken.borrowFresh (RToken.sol#1984) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MintLocalVars memory vars;\n",
                    "message": "vars in RToken.mintFresh (RToken.sol#1739) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": "vars in RToken.redeemFresh (RToken.sol#1847) is a local variable never initialiazed\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
                    "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ RToken.sol#1170) shadows:\n\t- ExponentialNoError.fraction (function @ RToken.sol#1042-1044)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1967,
                    "vulnerability_to_line": 2031,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = ironController.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.BORROW_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.borrowFresh (RToken.sol#1967-2031):\n\tExternal calls:\n\t- allowed = ironController.borrowAllowed(address(this),borrower,borrowAmount) (RToken.sol#1969)\n\tState variables written after the call(s):\n\t- accountBorrows (RToken.sol#2019)\n\t- accountBorrows (RToken.sol#2020)\n\t- totalBorrows (RToken.sol#2021)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": 1286,
                    "vulnerability_code": "    function initialize(IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the ironController\n\n        uint err = _setIronController(ironController_);\n\n        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on ironController being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
                    "message": "Reentrancy in RToken.initialize (RToken.sol#1255-1286):\n\tExternal calls:\n\t- err = _setIronController(ironController_) (RToken.sol#1269)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (RToken.sol#1277)\n\tState variables written after the call(s):\n\t- _notEntered (RToken.sol#1285)\n\t- decimals (RToken.sol#1282)\n\t- name (RToken.sol#1280)\n\t- symbol (RToken.sol#1281)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": 1792,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = ironController.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.MINT_IRON_CONTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the RToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of RTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n\n\n        /*\n\n         * We calculate the new total supply of RTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n",
                    "message": "Reentrancy in RToken.mintFresh (RToken.sol#1727-1792):\n\tExternal calls:\n\t- allowed = ironController.mintAllowed(address(this),minter,mintAmount) (RToken.sol#1729)\n\tState variables written after the call(s):\n\t- accountTokens (RToken.sol#1781)\n\t- totalSupply (RToken.sol#1780)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": 1938,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = ironController.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REDEEM_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        ironController.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.redeemFresh (RToken.sol#1844-1938):\n\tExternal calls:\n\t- allowed = ironController.redeemAllowed(address(this),redeemer,vars.redeemTokens) (RToken.sol#1884)\n\tState variables written after the call(s):\n\t- accountTokens (RToken.sol#1928)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2082,
                    "vulnerability_to_line": 2149,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = ironController.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REPAY_BORROW_IRON_CONTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowFresh (RToken.sol#2082-2149):\n\tExternal calls:\n\t- allowed = ironController.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (RToken.sol#2084)\n\tState variables written after the call(s):\n\t- accountBorrows (RToken.sol#2137)\n\t- accountBorrows (RToken.sol#2138)\n\t- totalBorrows (RToken.sol#2139)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2279,
                    "vulnerability_to_line": 2326,
                    "vulnerability_code": "    function seizeInternal(address seizeRToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = ironController.seizeAllowed(address(this), seizeRToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borroweRTokensNew;\n\n        uint liquidatoRTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borroweRTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatoRTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borroweRTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatoRTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borroweRTokensNew;\n\n        accountTokens[liquidator] = liquidatoRTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.seizeVerify(address(this), seizeRToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.seizeInternal (RToken.sol#2279-2326):\n\tExternal calls:\n\t- allowed = ironController.seizeAllowed(address(this),seizeRToken,liquidator,borrower,seizeTokens) (RToken.sol#2281)\n\tState variables written after the call(s):\n\t- accountTokens (RToken.sol#2315)\n\t- accountTokens (RToken.sol#2316)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1297,
                    "vulnerability_to_line": 1357,
                    "vulnerability_code": "    function transfeRTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = ironController.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.TRANSFER_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srRTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srRTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srRTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // ironController.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.transfeRTokens (RToken.sol#1297-1357):\n\tExternal calls:\n\t- allowed = ironController.transferAllowed(address(this),src,dst,tokens) (RToken.sol#1299)\n\tState variables written after the call(s):\n\t- accountTokens (RToken.sol#1342)\n\t- accountTokens (RToken.sol#1343)\n\t- transferAllowances (RToken.sol#1347)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public implementation;\n",
                    "message": "RDelegationStorage.implementation should be constant (RToken.sol#454)\nRErc20Storage.underlying should be constant (RToken.sol#428)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "RTokenInterface._setInterestRateModel (RToken.sol#421) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "RToken._setInterestRateModel (RToken.sol#2584-2594) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "rDelegatorInterface._setImplementation (RToken.sol#469) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "RDelegateInterface._becomeImplementation (RToken.sol#478) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "RDelegateInterface._resignImplementation (RToken.sol#483) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": 1286,
                    "vulnerability_code": "    function initialize(IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the ironController\n\n        uint err = _setIronController(ironController_);\n\n        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on ironController being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
                    "message": "RToken.initialize (RToken.sol#1255-1286) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in RToken.sol:\n\t- pragma solidity^0.5.16 (RToken.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (RToken.sol#77): it allows old versions\n\t- pragma solidity^0.5.16 (RToken.sol#110): it allows old versions\n\t- pragma solidity^0.5.16 (RToken.sol#183): it allows old versions\n\t- pragma solidity^0.5.16 (RToken.sol#488): it allows old versions\n\t- pragma solidity^0.5.16 (RToken.sol#553): it allows old versions\n\t- pragma solidity^0.5.16 (RToken.sol#763): it allows old versions\n\t- pragma solidity^0.5.16 (RToken.sol#851): it allows old versions\n\t- pragma solidity^0.5.16 (RToken.sol#1049): it allows old versions\n\t- pragma solidity^0.5.16 (RToken.sol#1233): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function enterMarkets(address[] calldata RTokens) external returns (uint[] memory);\n",
                    "message": "Parameter 'RTokens' of IronControllerInterface.enterMarkets (RToken.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exitMarket(address RToken) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.exitMarket (RToken.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintAllowed(address RToken, address minter, uint mintAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintAllowed (RToken.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintVerify(address RToken, address minter, uint mintAmount, uint mintTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintVerify (RToken.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemAllowed(address RToken, address redeemer, uint redeemTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemAllowed (RToken.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemVerify(address RToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemVerify (RToken.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowAllowed(address RToken, address borrower, uint borrowAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowAllowed (RToken.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowVerify(address RToken, address borrower, uint borrowAmount) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowVerify (RToken.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowAllowed (RToken.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowVerify (RToken.sol#31) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowAllowed (RToken.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowAllowed (RToken.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowVerify (RToken.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowVerify (RToken.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeAllowed (RToken.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeAllowed (RToken.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeVerify (RToken.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeVerify (RToken.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferAllowed(address RToken, address src, address dst, uint transfeRTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferAllowed (RToken.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferVerify(address RToken, address src, address dst, uint transfeRTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferVerify (RToken.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateCalculateSeizeTokens (RToken.sol#70) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateCalculateSeizeTokens (RToken.sol#71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isIronController = true;\n",
                    "message": "Constant 'IronControllerInterface.isIronController' (RToken.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'InterestRateModel.isInterestRateModel' (RToken.sol#85) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _notEntered;\n",
                    "message": "Variable 'RTokenStorage._notEntered' (RToken.sol#191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
                    "message": "Constant 'RTokenStorage.borrowRateMaxMantissa' (RToken.sol#212) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'RTokenStorage.reserveFactorMaxMantissa' (RToken.sol#217) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setPendingAdmin' (RToken.sol#416) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
                    "message": "Function 'RTokenInterface._acceptAdmin' (RToken.sol#417) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setIronController' (RToken.sol#418) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setReserveFactor' (RToken.sol#419) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._reduceReserves' (RToken.sol#420) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setInterestRateModel' (RToken.sol#421) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isRToken = true;\n",
                    "message": "Constant 'RTokenInterface.isRToken' (RToken.sol#304) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrow(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) external returns (uint);\n",
                    "message": "Parameter 'RTokenCollateral' of RErc20Interface.liquidateBorrow (RToken.sol#441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
                    "message": "Function 'RErc20Interface._addReserves' (RToken.sol#447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": 470,
                    "vulnerability_code": "contract rDelegatorInterface is RDelegationStorage {\n\n    /**\n\n     * @notice Emitted when implementation is changed\n\n     */\n\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n\n\n    /**\n\n     * @notice Called by the admin to update the implementation of the delegator\n\n     * @param implementation_ The address of the new implementation for delegation\n\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n\n     */\n\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Contract 'rDelegatorInterface' (RToken.sol#457-470) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Function 'rDelegatorInterface._setImplementation' (RToken.sol#469) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "Function 'RDelegateInterface._becomeImplementation' (RToken.sol#478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "Function 'RDelegateInterface._resignImplementation' (RToken.sol#483) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 886,
                    "vulnerability_to_line": 889,
                    "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncate' (RToken.sol#886-889) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": 897,
                    "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncateAddUInt' (RToken.sol#894-897) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant expScale = 1e18;\n",
                    "message": "Constant 'ExponentialNoError.expScale' (RToken.sol#861) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant doubleScale = 1e36;\n",
                    "message": "Constant 'ExponentialNoError.doubleScale' (RToken.sol#862) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'ExponentialNoError.halfExpScale' (RToken.sol#863) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant mantissaOne = expScale;\n",
                    "message": "Constant 'ExponentialNoError.mantissaOne' (RToken.sol#864) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2337,
                    "vulnerability_to_line": 2353,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Function 'RToken._setPendingAdmin' (RToken.sol#2337-2353) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2360,
                    "vulnerability_to_line": 2383,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        // SWC-Code With No Effects: L1133\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._acceptAdmin' (RToken.sol#2360-2383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2407,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_IRON_CONTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        IronControllerInterface oldIronController = ironController;\n\n        // Ensure invoke ironController.isIronController() returns true\n\n        require(newIronController.isIronController(), \"marker method returned false\");\n\n\n\n        // Set market's ironController to newIronController\n\n        ironController = newIronController;\n\n\n\n        // Emit NewIronController(oldIronController, newIronController)\n\n        emit NewIronController(oldIronController, newIronController);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setIronController' (RToken.sol#2388-2407) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": 2422,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setReserveFactor' (RToken.sol#2412-2422) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": 2529,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'RToken._reduceReserves' (RToken.sol#2519-2529) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setInterestRateModel' (RToken.sol#2584-2594) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal nonReentrant returns (uint, uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RToken.liquidateBorrowInternal (RToken.sol#2159) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal returns (uint, uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RToken.liquidateBorrowFresh (RToken.sol#2185) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": 2451,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setReserveFactorFresh' (RToken.sol#2427-2451) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2468,
                    "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
                    "message": "Function 'RToken._addReservesInternal' (RToken.sol#2456-2468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2474,
                    "vulnerability_to_line": 2514,
                    "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n\n\n        /* Revert on overflow */\n\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
                    "message": "Function 'RToken._addReservesFresh' (RToken.sol#2474-2514) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2535,
                    "vulnerability_to_line": 2578,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._reduceReservesFresh' (RToken.sol#2535-2578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2600,
                    "vulnerability_to_line": 2630,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setInterestRateModelFresh' (RToken.sol#2600-2630) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 825,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1092,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/RToken/RErc20.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(RTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newIronController.isIronController(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \trequire(address(token) != underlying, \"RErc20::sweepToken: can not sweep underlying token\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2841,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2872,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \trequire(address(token) != underlying, \"RErc20::sweepToken: can not sweep underlying token\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 2016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                },
                {
                    "name": "compound-sweeptoken-not-restricted",
                    "vulnerability_from_line": 2785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    \ttoken.transfer(admin, balance);\n",
                    "message": "Function sweepToken is allowed to be called by anyone"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_100"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (RErc20.sol#117-179) has incorrect ERC20 function interface(s):\n\t-transfer (RErc20.sol#143)\n\t-transferFrom (RErc20.sol#157)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2468,
                    "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._addReservesInternal (RErc20.sol#2456-2468):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20.sol#2457-2458)\n\tState variables written after the call(s):\n\t- totalReserves (RErc20.sol#2464-2465)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": 2529,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._reduceReserves (RErc20.sol#2519-2529):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20.sol#2520-2521)\n\tState variables written after the call(s):\n\t- totalReserves (RErc20.sol#2526-2527)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setInterestRateModel (RErc20.sol#2584-2594):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20.sol#2585-2586)\n\t- _setInterestRateModelFresh(newInterestRateModel) (RErc20.sol#2591-2592)\n\tState variables written after the call(s):\n\t- interestRateModel (RErc20.sol#2591-2592)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2600,
                    "vulnerability_to_line": 2630,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setInterestRateModelFresh (RErc20.sol#2600-2630):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (RErc20.sol#2619-2621)\n\tState variables written after the call(s):\n\t- interestRateModel (RErc20.sol#2622-2624)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2407,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_IRON_CONTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        IronControllerInterface oldIronController = ironController;\n\n        // Ensure invoke ironController.isIronController() returns true\n\n        require(newIronController.isIronController(), \"marker method returned false\");\n\n\n\n        // Set market's ironController to newIronController\n\n        ironController = newIronController;\n\n\n\n        // Emit NewIronController(oldIronController, newIronController)\n\n        emit NewIronController(oldIronController, newIronController);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setIronController (RErc20.sol#2388-2407):\n\tExternal calls:\n\t- require(bool,string)(newIronController.isIronController(),marker method returned false) (RErc20.sol#2396-2397)\n\tState variables written after the call(s):\n\t- ironController (RErc20.sol#2399-2400)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": 2422,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in RToken._setReserveFactor (RErc20.sol#2412-2422):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20.sol#2413-2414)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (RErc20.sol#2419-2420)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1614,
                    "vulnerability_to_line": 1692,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        /* Remember the initial block number */\n\n        uint currentBlockNumber = getBlockNumber();\n\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n\n\n        /* Short-circuit accumulating 0 interest */\n\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Read the previous values out of storage */\n\n        uint cashPrior = getCashPrior();\n\n        uint borrowsPrior = totalBorrows;\n\n        uint reservesPrior = totalReserves;\n\n        uint borrowIndexPrior = borrowIndex;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n\n\n        Exp memory simpleInterestFactor;\n\n        uint interestAccumulated;\n\n        uint totalBorrowsNew;\n\n        uint totalReservesNew;\n\n        uint borrowIndexNew;\n\n\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = currentBlockNumber;\n\n        borrowIndex = borrowIndexNew;\n\n        totalBorrows = totalBorrowsNew;\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.accrueInterest (RErc20.sol#1614-1692):\n\tExternal calls:\n\t- borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior,borrowsPrior,reservesPrior) (RErc20.sol#1631)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (RErc20.sol#1683)\n\t- borrowIndex (RErc20.sol#1684)\n\t- totalBorrows (RErc20.sol#1685)\n\t- totalReserves (RErc20.sol#1686)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1945,
                    "vulnerability_to_line": 1953,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n",
                    "message": "Reentrancy in RToken.borrowInternal (RErc20.sol#1945-1953):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20.sol#1946)\n\t- borrowFresh(msg.sender,borrowAmount) (RErc20.sol#1952)\n\tState variables written after the call(s):\n\t- totalBorrows (RErc20.sol#1952)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": 1286,
                    "vulnerability_code": "    function initialize(IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the ironController\n\n        uint err = _setIronController(ironController_);\n\n        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on ironController being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
                    "message": "Reentrancy in RToken.initialize (RErc20.sol#1255-1286):\n\tExternal calls:\n\t- err = _setIronController(ironController_) (RErc20.sol#1269)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (RErc20.sol#1273)\n\t- borrowIndex (RErc20.sol#1274)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2159,
                    "vulnerability_to_line": 2174,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        error = RTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, RTokenCollateral);\n",
                    "message": "Reentrancy in RToken.liquidateBorrowInternal (RErc20.sol#2159-2174):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20.sol#2160)\n\t- error = RTokenCollateral.accrueInterest() (RErc20.sol#2166)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,RTokenCollateral) (RErc20.sol#2173)\n\tState variables written after the call(s):\n\t- totalBorrows (RErc20.sol#2173)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": 1938,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = ironController.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REDEEM_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        ironController.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.redeemFresh (RErc20.sol#1844-1938):\n\tExternal calls:\n\t- allowed = ironController.redeemAllowed(address(this),redeemer,vars.redeemTokens) (RErc20.sol#1884)\n\tState variables written after the call(s):\n\t- totalSupply (RErc20.sol#1927)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2054,
                    "vulnerability_to_line": 2062,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowBehalfInternal (RErc20.sol#2054-2062):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20.sol#2055)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (RErc20.sol#2061)\n\tState variables written after the call(s):\n\t- totalBorrows (RErc20.sol#2061)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2038,
                    "vulnerability_to_line": 2046,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowInternal (RErc20.sol#2038-2046):\n\tExternal calls:\n\t- error = accrueInterest() (RErc20.sol#2039)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (RErc20.sol#2045)\n\tState variables written after the call(s):\n\t- totalBorrows (RErc20.sol#2045)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": "vars in RToken.redeemFresh (RErc20.sol#1847) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MintLocalVars memory vars;\n",
                    "message": "vars in RToken.mintFresh (RErc20.sol#1739) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 2477,
                    "vulnerability_to_line": 2479,
                    "vulnerability_code": "        uint actualAddAmount;\n\n\n",
                    "message": "actualAddAmount in RToken._addReservesFresh (RErc20.sol#2477-2479) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 2094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n",
                    "message": "vars in RToken.repayBorrowFresh (RErc20.sol#2094) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1984,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n",
                    "message": "vars in RToken.borrowFresh (RErc20.sol#1984) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2687,
                    "vulnerability_to_line": 2702,
                    "vulnerability_code": "    function initialize(address underlying_,\n\n                        IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
                    "message": "RErc20.initialize (RErc20.sol#2687-2702) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (RErc20.sol#2699-2700)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n",
                    "message": "Exponential.divScalarByExpTruncate.fraction (local variable @ RErc20.sol#1170) shadows:\n\t- ExponentialNoError.fraction (function @ RErc20.sol#1042-1044)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1967,
                    "vulnerability_to_line": 2031,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = ironController.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.BORROW_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken borrowAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(borrower, borrowAmount);\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.borrowFresh (RErc20.sol#1967-2031):\n\tExternal calls:\n\t- allowed = ironController.borrowAllowed(address(this),borrower,borrowAmount) (RErc20.sol#1969)\n\tState variables written after the call(s):\n\t- accountBorrows (RErc20.sol#2019)\n\t- accountBorrows (RErc20.sol#2020)\n\t- totalBorrows (RErc20.sol#2021)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": 1286,
                    "vulnerability_code": "    function initialize(IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        require(msg.sender == admin, \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the ironController\n\n        uint err = _setIronController(ironController_);\n\n        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on ironController being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n",
                    "message": "Reentrancy in RToken.initialize (RErc20.sol#1255-1286):\n\tExternal calls:\n\t- err = _setIronController(ironController_) (RErc20.sol#1269)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (RErc20.sol#1277)\n\tState variables written after the call(s):\n\t- _notEntered (RErc20.sol#1285)\n\t- decimals (RErc20.sol#1282)\n\t- name (RErc20.sol#1280)\n\t- symbol (RErc20.sol#1281)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2687,
                    "vulnerability_to_line": 2702,
                    "vulnerability_code": "    function initialize(address underlying_,\n\n                        IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
                    "message": "Reentrancy in RErc20.initialize (RErc20.sol#2687-2702):\n\tExternal calls:\n\t- super.initialize(ironController_,interestRateModel_,initialExchangeRateMantissa_,name_,symbol_,decimals_) (RErc20.sol#2695-2697)\n\tState variables written after the call(s):\n\t- underlying (RErc20.sol#2698-2699)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": 1792,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = ironController.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.MINT_IRON_CONTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         *  We call `doTransferIn` for the minter and the mintAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n\n         *  side-effects occurred. The function returns the amount actually transferred,\n\n         *  in case of a fee. On success, the RToken holds an additional `actualMintAmount`\n\n         *  of cash.\n\n         */\n\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of RTokens to be minted:\n\n         *  mintTokens = actualMintAmount / exchangeRate\n\n         */\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n\n\n        /*\n\n         * We calculate the new total supply of RTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n",
                    "message": "Reentrancy in RToken.mintFresh (RErc20.sol#1727-1792):\n\tExternal calls:\n\t- allowed = ironController.mintAllowed(address(this),minter,mintAmount) (RErc20.sol#1729)\n\tState variables written after the call(s):\n\t- accountTokens (RErc20.sol#1781)\n\t- totalSupply (RErc20.sol#1780)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": 1938,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = ironController.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REDEEM_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken has redeemAmount less of cash.\n\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         */\n\n        doTransferOut(redeemer, vars.redeemAmount);\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        ironController.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.redeemFresh (RErc20.sol#1844-1938):\n\tExternal calls:\n\t- allowed = ironController.redeemAllowed(address(this),redeemer,vars.redeemTokens) (RErc20.sol#1884)\n\tState variables written after the call(s):\n\t- accountTokens (RErc20.sol#1928)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2082,
                    "vulnerability_to_line": 2149,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = ironController.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return (failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.REPAY_BORROW_IRON_CONTROLLER_REJECTION, allowed), 0);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken holds an additional repayAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *   it returns the amount actually transferred, in case of a fee.\n\n         */\n\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n\n\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n",
                    "message": "Reentrancy in RToken.repayBorrowFresh (RErc20.sol#2082-2149):\n\tExternal calls:\n\t- allowed = ironController.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (RErc20.sol#2084)\n\tState variables written after the call(s):\n\t- accountBorrows (RErc20.sol#2137)\n\t- accountBorrows (RErc20.sol#2138)\n\t- totalBorrows (RErc20.sol#2139)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2279,
                    "vulnerability_to_line": 2326,
                    "vulnerability_code": "    function seizeInternal(address seizeRToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = ironController.seizeAllowed(address(this), seizeRToken, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borroweRTokensNew;\n\n        uint liquidatoRTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borroweRTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatoRTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borroweRTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatoRTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borroweRTokensNew;\n\n        accountTokens[liquidator] = liquidatoRTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        // unused function\n\n        // ironController.seizeVerify(address(this), seizeRToken, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.seizeInternal (RErc20.sol#2279-2326):\n\tExternal calls:\n\t- allowed = ironController.seizeAllowed(address(this),seizeRToken,liquidator,borrower,seizeTokens) (RErc20.sol#2281)\n\tState variables written after the call(s):\n\t- accountTokens (RErc20.sol#2315)\n\t- accountTokens (RErc20.sol#2316)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1297,
                    "vulnerability_to_line": 1357,
                    "vulnerability_code": "    function transfeRTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = ironController.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.IRON_CONTROLLER_REJECTION, FailureInfo.TRANSFER_IRON_CONTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srRTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srRTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srRTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        // unused function\n\n        // ironController.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Reentrancy in RToken.transfeRTokens (RErc20.sol#1297-1357):\n\tExternal calls:\n\t- allowed = ironController.transferAllowed(address(this),src,dst,tokens) (RErc20.sol#1299)\n\tState variables written after the call(s):\n\t- accountTokens (RErc20.sol#1342)\n\t- accountTokens (RErc20.sol#1343)\n\t- transferAllowances (RErc20.sol#1347)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2818,
                    "vulnerability_to_line": 2845,
                    "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (uint) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                       // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                      // This is a compliant ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n\n\n        // Calculate the amount that was *actually* transferred\n\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\n\n    }\n\n\n",
                    "message": "RErc20.doTransferIn uses assembly (RErc20.sol#2818-2845)\n\t- RErc20.sol#2824-2837\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": 2874,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        token.transfer(to, amount);\n\n\n\n        bool success;\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    success := not(0)          // set success to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    success := mload(0)        // Set `success = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n\n    }\n",
                    "message": "RErc20.doTransferOut uses assembly (RErc20.sol#2854-2874)\n\t- RErc20.sol#2859-2872\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public implementation;\n",
                    "message": "RDelegationStorage.implementation should be constant (RErc20.sol#454)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "RToken._setInterestRateModel (RErc20.sol#2584-2594) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "RTokenInterface._setInterestRateModel (RErc20.sol#421) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "rDelegatorInterface._setImplementation (RErc20.sol#469) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "RDelegateInterface._becomeImplementation (RErc20.sol#478) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "RDelegateInterface._resignImplementation (RErc20.sol#483) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2687,
                    "vulnerability_to_line": 2702,
                    "vulnerability_code": "    function initialize(address underlying_,\n\n                        IronControllerInterface ironController_,\n\n                        InterestRateModel interestRateModel_,\n\n                        uint initialExchangeRateMantissa_,\n\n                        string memory name_,\n\n                        string memory symbol_,\n\n                        uint8 decimals_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(ironController_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }\n\n\n",
                    "message": "RErc20.initialize (RErc20.sol#2687-2702) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in RErc20.sol:\n\t- pragma solidity^0.5.16 (RErc20.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20.sol#77): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20.sol#110): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20.sol#183): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20.sol#488): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20.sol#553): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20.sol#763): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20.sol#851): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20.sol#1049): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20.sol#1233): it allows old versions\n\t- pragma solidity^0.5.16 (RErc20.sol#2668-2671): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function enterMarkets(address[] calldata RTokens) external returns (uint[] memory);\n",
                    "message": "Parameter 'RTokens' of IronControllerInterface.enterMarkets (RErc20.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exitMarket(address RToken) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.exitMarket (RErc20.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintAllowed(address RToken, address minter, uint mintAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintAllowed (RErc20.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintVerify(address RToken, address minter, uint mintAmount, uint mintTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintVerify (RErc20.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemAllowed(address RToken, address redeemer, uint redeemTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemAllowed (RErc20.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemVerify(address RToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemVerify (RErc20.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowAllowed(address RToken, address borrower, uint borrowAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowAllowed (RErc20.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowVerify(address RToken, address borrower, uint borrowAmount) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowVerify (RErc20.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowAllowed (RErc20.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowVerify (RErc20.sol#31) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowAllowed (RErc20.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowAllowed (RErc20.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowVerify (RErc20.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowVerify (RErc20.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeAllowed (RErc20.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeAllowed (RErc20.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeVerify (RErc20.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeVerify (RErc20.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferAllowed(address RToken, address src, address dst, uint transfeRTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferAllowed (RErc20.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferVerify(address RToken, address src, address dst, uint transfeRTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferVerify (RErc20.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateCalculateSeizeTokens (RErc20.sol#70) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateCalculateSeizeTokens (RErc20.sol#71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isIronController = true;\n",
                    "message": "Constant 'IronControllerInterface.isIronController' (RErc20.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'InterestRateModel.isInterestRateModel' (RErc20.sol#85) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _notEntered;\n",
                    "message": "Variable 'RTokenStorage._notEntered' (RErc20.sol#191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
                    "message": "Constant 'RTokenStorage.borrowRateMaxMantissa' (RErc20.sol#212) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'RTokenStorage.reserveFactorMaxMantissa' (RErc20.sol#217) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setPendingAdmin' (RErc20.sol#416) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
                    "message": "Function 'RTokenInterface._acceptAdmin' (RErc20.sol#417) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setIronController' (RErc20.sol#418) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setReserveFactor' (RErc20.sol#419) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._reduceReserves' (RErc20.sol#420) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setInterestRateModel' (RErc20.sol#421) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isRToken = true;\n",
                    "message": "Constant 'RTokenInterface.isRToken' (RErc20.sol#304) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrow(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) external returns (uint);\n",
                    "message": "Parameter 'RTokenCollateral' of RErc20Interface.liquidateBorrow (RErc20.sol#441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
                    "message": "Function 'RErc20Interface._addReserves' (RErc20.sol#447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": 470,
                    "vulnerability_code": "contract rDelegatorInterface is RDelegationStorage {\n\n    /**\n\n     * @notice Emitted when implementation is changed\n\n     */\n\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n\n\n    /**\n\n     * @notice Called by the admin to update the implementation of the delegator\n\n     * @param implementation_ The address of the new implementation for delegation\n\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n\n     */\n\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Contract 'rDelegatorInterface' (RErc20.sol#457-470) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Function 'rDelegatorInterface._setImplementation' (RErc20.sol#469) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "Function 'RDelegateInterface._becomeImplementation' (RErc20.sol#478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "Function 'RDelegateInterface._resignImplementation' (RErc20.sol#483) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 886,
                    "vulnerability_to_line": 889,
                    "vulnerability_code": "    function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return truncate(product);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncate' (RErc20.sol#886-889) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": 897,
                    "vulnerability_code": "    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\n\n        Exp memory product = mul_(a, scalar);\n\n        return add_(truncate(product), addend);\n",
                    "message": "Function 'ExponentialNoError.mul_ScalarTruncateAddUInt' (RErc20.sol#894-897) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant expScale = 1e18;\n",
                    "message": "Constant 'ExponentialNoError.expScale' (RErc20.sol#861) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant doubleScale = 1e36;\n",
                    "message": "Constant 'ExponentialNoError.doubleScale' (RErc20.sol#862) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'ExponentialNoError.halfExpScale' (RErc20.sol#863) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant mantissaOne = expScale;\n",
                    "message": "Constant 'ExponentialNoError.mantissaOne' (RErc20.sol#864) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2337,
                    "vulnerability_to_line": 2353,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Function 'RToken._setPendingAdmin' (RErc20.sol#2337-2353) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2360,
                    "vulnerability_to_line": 2383,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        // SWC-Code With No Effects: L1133\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._acceptAdmin' (RErc20.sol#2360-2383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2407,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_IRON_CONTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        IronControllerInterface oldIronController = ironController;\n\n        // Ensure invoke ironController.isIronController() returns true\n\n        require(newIronController.isIronController(), \"marker method returned false\");\n\n\n\n        // Set market's ironController to newIronController\n\n        ironController = newIronController;\n\n\n\n        // Emit NewIronController(oldIronController, newIronController)\n\n        emit NewIronController(oldIronController, newIronController);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setIronController' (RErc20.sol#2388-2407) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": 2422,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setReserveFactor' (RErc20.sol#2412-2422) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": 2529,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'RToken._reduceReserves' (RErc20.sol#2519-2529) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2584,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setInterestRateModel' (RErc20.sol#2584-2594) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal nonReentrant returns (uint, uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RToken.liquidateBorrowInternal (RErc20.sol#2159) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, RTokenInterface RTokenCollateral) internal returns (uint, uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RToken.liquidateBorrowFresh (RErc20.sol#2185) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": 2451,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setReserveFactorFresh' (RErc20.sol#2427-2451) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2468,
                    "vulnerability_code": "    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n\n\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n\n        (error, ) = _addReservesFresh(addAmount);\n\n        return error;\n\n    }\n\n\n",
                    "message": "Function 'RToken._addReservesInternal' (RErc20.sol#2456-2468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2474,
                    "vulnerability_to_line": 2514,
                    "vulnerability_code": "    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n\n        // totalReserves + actualAddAmount\n\n        uint totalReservesNew;\n\n        uint actualAddAmount;\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the caller and the addAmount\n\n         *  Note: The RToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the RToken holds an additional addAmount of cash.\n\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n         *  it returns the amount actually transferred, in case of a fee.\n\n         */\n\n\n\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n\n\n        totalReservesNew = totalReserves + actualAddAmount;\n\n\n\n        /* Revert on overflow */\n\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n\n\n        /* Return (NO_ERROR, actualAddAmount) */\n\n        return (uint(Error.NO_ERROR), actualAddAmount);\n\n    }\n\n\n\n\n",
                    "message": "Function 'RToken._addReservesFresh' (RErc20.sol#2474-2514) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2535,
                    "vulnerability_to_line": 2578,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n\n        doTransferOut(admin, reduceAmount);\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._reduceReservesFresh' (RErc20.sol#2535-2578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2600,
                    "vulnerability_to_line": 2630,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'RToken._setInterestRateModelFresh' (RErc20.sol#2600-2630) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrow(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) external returns (uint) {\n",
                    "message": "Parameter 'RTokenCollateral' of RErc20.liquidateBorrow (RErc20.sol#2773) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2793,
                    "vulnerability_to_line": 2797,
                    "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint) {\n\n        return _addReservesInternal(addAmount);\n\n    }\n\n\n",
                    "message": "Function 'RErc20._addReserves' (RErc20.sol#2793-2797) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 825,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1092,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2824,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2856,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2856,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2858,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool success;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2860,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2860,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    success := not(0)          // set success to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    success := not(0)          // set success to true\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/interfaces/EIP20NonStandardInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (EIP20NonStandardInterface.sol#10-72) has incorrect ERC20 function interface(s):\n\t-transfer (EIP20NonStandardInterface.sol#36)\n\t-transferFrom (EIP20NonStandardInterface.sol#50)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in EIP20NonStandardInterface.sol:\n\t- pragma solidity^0.5.16 (EIP20NonStandardInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/interfaces/IUniswapLP.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": false,
            "errors": [
                "EXIT_CODE_255",
                "error parsing results: file could not be opened successfully:\n- method gz: ReadError('empty file')\n- method bz2: ReadError('not a bzip2 file')\n- method xz: ReadError('not an lzma file')\n- method tar: ReadError('empty file')"
            ],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/interfaces/PriceOracle.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting ironController failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(RTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newIronController.isIronController(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_notEntered, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == admin, \"only admin may initialize the market\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_IRON_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 2016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1049,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 825,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1092,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1844,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/interfaces/IPairOracle.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": false,
            "errors": [
                "EXIT_CODE_255",
                "error parsing results: file could not be opened successfully:\n- method gz: ReadError('empty file')\n- method bz2: ReadError('not a bzip2 file')\n- method xz: ReadError('not an lzma file')\n- method tar: ReadError('empty file')"
            ],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/interfaces/IRewardToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.16;\n",
                    "message": "Detected issues with version pragma in IRewardToken.sol:\n\t- pragma solidity>=0.5.16 (IRewardToken.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.5.16;\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/interfaces/EIP20Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in EIP20Interface.sol:\n\t- pragma solidity^0.5.16 (EIP20Interface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/interfaces/IronControllerInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_24"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in IronControllerInterface.sol:\n\t- pragma solidity^0.5.16 (IronControllerInterface.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function enterMarkets(address[] calldata RTokens) external returns (uint[] memory);\n",
                    "message": "Parameter 'RTokens' of IronControllerInterface.enterMarkets (IronControllerInterface.sol#11) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exitMarket(address RToken) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.exitMarket (IronControllerInterface.sol#12) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintAllowed(address RToken, address minter, uint mintAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintAllowed (IronControllerInterface.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintVerify(address RToken, address minter, uint mintAmount, uint mintTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintVerify (IronControllerInterface.sol#17) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemAllowed(address RToken, address redeemer, uint redeemTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemAllowed (IronControllerInterface.sol#19) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemVerify(address RToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemVerify (IronControllerInterface.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowAllowed(address RToken, address borrower, uint borrowAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowAllowed (IronControllerInterface.sol#22) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowVerify(address RToken, address borrower, uint borrowAmount) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowVerify (IronControllerInterface.sol#23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowAllowed (IronControllerInterface.sol#26) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowVerify (IronControllerInterface.sol#31) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowAllowed (IronControllerInterface.sol#38) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowAllowed (IronControllerInterface.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowVerify (IronControllerInterface.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowVerify (IronControllerInterface.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeAllowed (IronControllerInterface.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeAllowed (IronControllerInterface.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeVerify (IronControllerInterface.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeVerify (IronControllerInterface.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferAllowed(address RToken, address src, address dst, uint transfeRTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferAllowed (IronControllerInterface.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferVerify(address RToken, address src, address dst, uint transfeRTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferVerify (IronControllerInterface.sol#65) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateCalculateSeizeTokens (IronControllerInterface.sol#70) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateCalculateSeizeTokens (IronControllerInterface.sol#71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isIronController = true;\n",
                    "message": "Constant 'IronControllerInterface.isIronController' (IronControllerInterface.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                }
            ]
        }
    },
    "iron-lend-f9a669850885895215579e3c2ae8d7124f0ef5c8/src/interfaces/RTokenInterfaces.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_52"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": 179,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (RTokenInterfaces.sol#117-179) has incorrect ERC20 function interface(s):\n\t-transfer (RTokenInterfaces.sol#143)\n\t-transferFrom (RTokenInterfaces.sol#157)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public implementation;\n",
                    "message": "RDelegationStorage.implementation should be constant (RTokenInterfaces.sol#454)\nRErc20Storage.underlying should be constant (RTokenInterfaces.sol#428)\nRTokenStorage._notEntered should be constant (RTokenInterfaces.sol#191)\nRTokenStorage.accrualBlockNumber should be constant (RTokenInterfaces.sol#252)\nRTokenStorage.admin should be constant (RTokenInterfaces.sol#222)\nRTokenStorage.borrowIndex should be constant (RTokenInterfaces.sol#257)\nRTokenStorage.decimals should be constant (RTokenInterfaces.sol#206)\nRTokenStorage.initialExchangeRateMantissa should be constant (RTokenInterfaces.sol#242)\nRTokenStorage.name should be constant (RTokenInterfaces.sol#196)\nRTokenStorage.pendingAdmin should be constant (RTokenInterfaces.sol#227)\nRTokenStorage.reserveFactorMantissa should be constant (RTokenInterfaces.sol#247)\nRTokenStorage.symbol should be constant (RTokenInterfaces.sol#201)\nRTokenStorage.totalBorrows should be constant (RTokenInterfaces.sol#262)\nRTokenStorage.totalReserves should be constant (RTokenInterfaces.sol#267)\nRTokenStorage.totalSupply should be constant (RTokenInterfaces.sol#272)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStored(address account) public view returns (uint);\n",
                    "message": "RTokenInterface.borrowBalanceStored (RTokenInterfaces.sol#406) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateCurrent() public returns (uint);\n",
                    "message": "RTokenInterface.exchangeRateCurrent (RTokenInterfaces.sol#407) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 408,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStored() public view returns (uint);\n",
                    "message": "RTokenInterface.exchangeRateStored (RTokenInterfaces.sol#408) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function accrueInterest() public returns (uint);\n",
                    "message": "RTokenInterface.accrueInterest (RTokenInterfaces.sol#410) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint);\n",
                    "message": "RTokenInterface._setIronController (RTokenInterfaces.sol#418) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "RTokenInterface._setInterestRateModel (RTokenInterfaces.sol#421) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "rDelegatorInterface._setImplementation (RTokenInterfaces.sol#469) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "RDelegateInterface._becomeImplementation (RTokenInterfaces.sol#478) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "RDelegateInterface._resignImplementation (RTokenInterfaces.sol#483) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in RTokenInterfaces.sol:\n\t- pragma solidity^0.5.16 (RTokenInterfaces.sol#3): it allows old versions\n\t- pragma solidity^0.5.16 (RTokenInterfaces.sol#36): it allows old versions\n\t- pragma solidity^0.5.16 (RTokenInterfaces.sol#110): it allows old versions\n\t- pragma solidity^0.5.16 (RTokenInterfaces.sol#183): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'InterestRateModel.isInterestRateModel' (RTokenInterfaces.sol#11) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function enterMarkets(address[] calldata RTokens) external returns (uint[] memory);\n",
                    "message": "Parameter 'RTokens' of IronControllerInterface.enterMarkets (RTokenInterfaces.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exitMarket(address RToken) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.exitMarket (RTokenInterfaces.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintAllowed(address RToken, address minter, uint mintAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintAllowed (RTokenInterfaces.sol#49) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mintVerify(address RToken, address minter, uint mintAmount, uint mintTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.mintVerify (RTokenInterfaces.sol#50) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemAllowed(address RToken, address redeemer, uint redeemTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemAllowed (RTokenInterfaces.sol#52) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemVerify(address RToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.redeemVerify (RTokenInterfaces.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowAllowed(address RToken, address borrower, uint borrowAmount) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowAllowed (RTokenInterfaces.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowVerify(address RToken, address borrower, uint borrowAmount) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.borrowVerify (RTokenInterfaces.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowAllowed (RTokenInterfaces.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RToken,\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.repayBorrowVerify (RTokenInterfaces.sol#64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowAllowed (RTokenInterfaces.sol#71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowAllowed (RTokenInterfaces.sol#72) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateBorrowVerify (RTokenInterfaces.sol#77) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateBorrowVerify (RTokenInterfaces.sol#78) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeAllowed (RTokenInterfaces.sol#85) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeAllowed (RTokenInterfaces.sol#86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.seizeVerify (RTokenInterfaces.sol#91) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.seizeVerify (RTokenInterfaces.sol#92) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferAllowed(address RToken, address src, address dst, uint transfeRTokens) external returns (uint);\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferAllowed (RTokenInterfaces.sol#97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferVerify(address RToken, address src, address dst, uint transfeRTokens) external;\n",
                    "message": "Parameter 'RToken' of IronControllerInterface.transferVerify (RTokenInterfaces.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenBorrowed,\n",
                    "message": "Parameter 'RTokenBorrowed' of IronControllerInterface.liquidateCalculateSeizeTokens (RTokenInterfaces.sol#103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address RTokenCollateral,\n",
                    "message": "Parameter 'RTokenCollateral' of IronControllerInterface.liquidateCalculateSeizeTokens (RTokenInterfaces.sol#104) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isIronController = true;\n",
                    "message": "Constant 'IronControllerInterface.isIronController' (RTokenInterfaces.sol#40) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _notEntered;\n",
                    "message": "Variable 'RTokenStorage._notEntered' (RTokenInterfaces.sol#191) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n",
                    "message": "Constant 'RTokenStorage.borrowRateMaxMantissa' (RTokenInterfaces.sol#212) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint internal constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'RTokenStorage.reserveFactorMaxMantissa' (RTokenInterfaces.sol#217) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setPendingAdmin' (RTokenInterfaces.sol#416) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint);\n",
                    "message": "Function 'RTokenInterface._acceptAdmin' (RTokenInterfaces.sol#417) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setIronController(IronControllerInterface newIronController) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setIronController' (RTokenInterfaces.sol#418) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._setReserveFactor' (RTokenInterfaces.sol#419) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external returns (uint);\n",
                    "message": "Function 'RTokenInterface._reduceReserves' (RTokenInterfaces.sol#420) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n",
                    "message": "Function 'RTokenInterface._setInterestRateModel' (RTokenInterfaces.sol#421) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isRToken = true;\n",
                    "message": "Constant 'RTokenInterface.isRToken' (RTokenInterfaces.sol#304) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateBorrow(address borrower, uint repayAmount, RTokenInterface RTokenCollateral) external returns (uint);\n",
                    "message": "Parameter 'RTokenCollateral' of RErc20Interface.liquidateBorrow (RTokenInterfaces.sol#441) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addReserves(uint addAmount) external returns (uint);\n",
                    "message": "Function 'RErc20Interface._addReserves' (RTokenInterfaces.sol#447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": 470,
                    "vulnerability_code": "contract rDelegatorInterface is RDelegationStorage {\n\n    /**\n\n     * @notice Emitted when implementation is changed\n\n     */\n\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n\n\n    /**\n\n     * @notice Called by the admin to update the implementation of the delegator\n\n     * @param implementation_ The address of the new implementation for delegation\n\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n\n     */\n\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Contract 'rDelegatorInterface' (RTokenInterfaces.sol#457-470) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n",
                    "message": "Function 'rDelegatorInterface._setImplementation' (RTokenInterfaces.sol#469) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _becomeImplementation(bytes memory data) public;\n",
                    "message": "Function 'RDelegateInterface._becomeImplementation' (RTokenInterfaces.sol#478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _resignImplementation() public;\n",
                    "message": "Function 'RDelegateInterface._resignImplementation' (RTokenInterfaces.sol#483) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RTokenInterface is RTokenStorage {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\n",
                    "message": null
                }
            ]
        }
    }
}