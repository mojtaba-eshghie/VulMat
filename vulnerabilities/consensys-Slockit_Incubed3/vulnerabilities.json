{
    "in3-contracts-e25c758a115aef0c0640bc446027259aa7cb1a52/contracts/Migrations.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": 22,
                    "vulnerability_code": "    function setCompleted(uint completed) public restricted {\n\n        last_completed_migration = completed;\n",
                    "message": "Migrations.setCompleted (Migrations.sol#20-22) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 27,
                    "vulnerability_code": "    function upgrade(address new_address) public restricted {\n\n        Migrations upgraded = Migrations(new_address);\n\n        upgraded.setCompleted(last_completed_migration);\n",
                    "message": "Migrations.upgrade (Migrations.sol#24-27) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.10;\n",
                    "message": "Detected issues with version pragma in Migrations.sol:\n\t- pragma solidity0.5.10 (Migrations.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgrade(address new_address) public restricted {\n",
                    "message": "Parameter 'new_address' of Migrations.upgrade (Migrations.sol#24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public last_completed_migration;\n",
                    "message": "Variable 'Migrations.last_completed_migration' (Migrations.sol#8) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "in3-contracts-e25c758a115aef0c0640bc446027259aa7cb1a52/contracts/BlockhashRegistry.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _blockheaders.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        snapshot();\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (blockhashMapping[i] != 0x0) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = _startNumber; i <= (_numBlocks + _startNumber); i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _blockheaders.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(currentBlockhash != 0x0, \"parentBlock is not available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(calculatedHash != 0x0, \"invalid headers\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(bHash != 0x0, \"block not available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(first > 0xf7, \"invalid offset\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = _startNumber; i <= (_numBlocks + _startNumber); i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _blockheaders.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_13"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": 129,
                    "vulnerability_code": "    function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash) {\n\n\n\n        /// we need the 1st byte of the blockheader to calculate the position of the parentHash\n\n        uint8 first = uint8(_blockheader[0]);\n\n\n\n        /// calculates the offset\n\n        /// by using the 1st byte (usually f9) and substracting f7 to get the start point of the parentHash information\n\n        /// we also have to add \"2\" = 1 byte to it to skip the length-information\n\n        require(first > 0xf7, \"invalid offset\");\n\n        uint8 offset = first - 0xf7 + 2;\n\n\n\n        /// we are using assembly because it's the most efficent way to access the parent blockhash within the rlp-encoded blockheader\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { // solhint-disable-line no-inline-assembly\n\n            // mstore to get the memory pointer of the blockheader to 0x20\n\n            mstore(0x20, _blockheader)\n\n\n\n            // we load the pointer we just stored\n\n            // then we add 0x20 (32 bytes) to get to the start of the blockheader\n\n            // then we add the offset we calculated\n\n            // and load it to the parentHash variable\n\n            parentHash :=mload(\n\n                add(\n\n                    add(\n\n                        mload(0x20), 0x20\n\n                    ), offset)\n\n            )\n\n        }\n\n        bhash = keccak256(_blockheader);\n",
                    "message": "BlockhashRegistry.getParentAndBlockhash (BlockhashRegistry.sol#100-129) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": 129,
                    "vulnerability_code": "    function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash) {\n\n\n\n        /// we need the 1st byte of the blockheader to calculate the position of the parentHash\n\n        uint8 first = uint8(_blockheader[0]);\n\n\n\n        /// calculates the offset\n\n        /// by using the 1st byte (usually f9) and substracting f7 to get the start point of the parentHash information\n\n        /// we also have to add \"2\" = 1 byte to it to skip the length-information\n\n        require(first > 0xf7, \"invalid offset\");\n\n        uint8 offset = first - 0xf7 + 2;\n\n\n\n        /// we are using assembly because it's the most efficent way to access the parent blockhash within the rlp-encoded blockheader\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { // solhint-disable-line no-inline-assembly\n\n            // mstore to get the memory pointer of the blockheader to 0x20\n\n            mstore(0x20, _blockheader)\n\n\n\n            // we load the pointer we just stored\n\n            // then we add 0x20 (32 bytes) to get to the start of the blockheader\n\n            // then we add the offset we calculated\n\n            // and load it to the parentHash variable\n\n            parentHash :=mload(\n\n                add(\n\n                    add(\n\n                        mload(0x20), 0x20\n\n                    ), offset)\n\n            )\n\n        }\n\n        bhash = keccak256(_blockheader);\n",
                    "message": "BlockhashRegistry.getParentAndBlockhash uses assembly (BlockhashRegistry.sol#100-129)\n\t- BlockhashRegistry.sol#113-127\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.10;\n",
                    "message": "Different versions of Solidity is used in BlockhashRegistry.sol:\n\t- Version used: ['0.5.10', 'ABIEncoderV2']\n\t- BlockhashRegistry.sol#22 declares pragma solidity0.5.10\n\t- BlockhashRegistry.sol#23 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": 76,
                    "vulnerability_code": "    function recreateBlockheaders(uint _blockNumber, bytes[] memory _blockheaders) public {\n\n\n\n        bytes32 currentBlockhash = blockhashMapping[_blockNumber];\n\n        require(currentBlockhash != 0x0, \"parentBlock is not available\");\n\n\n\n        bytes32 calculatedHash = reCalculateBlockheaders(_blockheaders, currentBlockhash);\n\n        require(calculatedHash != 0x0, \"invalid headers\");\n\n\n\n        /// we should never fail this assert, as this would mean that we were able to recreate a invalid blockchain\n\n        assert(_blockNumber > _blockheaders.length);\n\n        uint bnr = _blockNumber - _blockheaders.length;\n\n        blockhashMapping[bnr] = calculatedHash;\n\n        emit LogBlockhashAdded(bnr, calculatedHash);\n",
                    "message": "BlockhashRegistry.recreateBlockheaders (BlockhashRegistry.sol#63-76) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.10;\n",
                    "message": "Detected issues with version pragma in BlockhashRegistry.sol:\n\t- pragma solidity0.5.10 (BlockhashRegistry.sol#22): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function searchForAvailableBlock(uint _startNumber, uint _numBlocks) external view returns (uint) {\n",
                    "message": "Parameter '_startNumber' of BlockhashRegistry.searchForAvailableBlock (BlockhashRegistry.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function searchForAvailableBlock(uint _startNumber, uint _numBlocks) external view returns (uint) {\n",
                    "message": "Parameter '_numBlocks' of BlockhashRegistry.searchForAvailableBlock (BlockhashRegistry.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recreateBlockheaders(uint _blockNumber, bytes[] memory _blockheaders) public {\n",
                    "message": "Parameter '_blockNumber' of BlockhashRegistry.recreateBlockheaders (BlockhashRegistry.sol#63) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function recreateBlockheaders(uint _blockNumber, bytes[] memory _blockheaders) public {\n",
                    "message": "Parameter '_blockheaders' of BlockhashRegistry.recreateBlockheaders (BlockhashRegistry.sol#63) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function saveBlockNumber(uint _blockNumber) public {\n",
                    "message": "Parameter '_blockNumber' of BlockhashRegistry.saveBlockNumber (BlockhashRegistry.sol#81) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash) {\n",
                    "message": "Parameter '_blockheader' of BlockhashRegistry.getParentAndBlockhash (BlockhashRegistry.sol#100) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reCalculateBlockheaders(bytes[] memory _blockheaders, bytes32 _bHash) public pure returns (bytes32 bhash) {\n",
                    "message": "Parameter '_blockheaders' of BlockhashRegistry.reCalculateBlockheaders (BlockhashRegistry.sol#136) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function reCalculateBlockheaders(bytes[] memory _blockheaders, bytes32 _bHash) public pure returns (bytes32 bhash) {\n",
                    "message": "Parameter '_bHash' of BlockhashRegistry.reCalculateBlockheaders (BlockhashRegistry.sol#136) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(first > 0xf7, \"invalid offset\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint8 offset = first - 0xf7 + 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32 calcParent = 0x0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32 calcBlockhash = 0x0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                return 0x0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _blockheaders.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _blockheaders.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { // solhint-disable-line no-inline-assembly\n",
                    "message": null
                }
            ]
        }
    }
}