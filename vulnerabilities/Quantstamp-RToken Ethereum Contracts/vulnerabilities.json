{
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/contracts/IAllocationStrategy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in IAllocationStrategy.sol:\n\t- pragma solidity^0.5.8 (IAllocationStrategy.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/contracts/Proxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes memory constructData, address contractLogic) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // save the code address\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { // solium-disable-line\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, contractLogic)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, /* bytes memory _*/ ) = contractLogic.delegatecall(constructData); // solium-disable-line\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"Construction failed\");\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"Construction failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "controlled-delegatecall",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": 14,
                    "vulnerability_code": "    constructor(bytes memory constructData, address contractLogic) public {\n\n        // save the code address\n\n        assembly { // solium-disable-line\n\n            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, contractLogic)\n\n        }\n\n        (bool success, /* bytes memory _*/ ) = contractLogic.delegatecall(constructData); // solium-disable-line\n\n        require(success, \"Construction failed\");\n",
                    "message": "Proxy.constructor (Proxy.sol#7-14) uses delegatecall to a input-controlled function id\n\t(success) = contractLogic.delegatecall(constructData) (Proxy.sol#12)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": 14,
                    "vulnerability_code": "    constructor(bytes memory constructData, address contractLogic) public {\n\n        // save the code address\n\n        assembly { // solium-disable-line\n\n            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, contractLogic)\n\n        }\n\n        (bool success, /* bytes memory _*/ ) = contractLogic.delegatecall(constructData); // solium-disable-line\n\n        require(success, \"Construction failed\");\n",
                    "message": "Proxy.constructor uses assembly (Proxy.sol#7-14)\n\t- Proxy.sol#9-11\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": 31,
                    "vulnerability_code": "    function() external payable {\n\n        assembly { // solium-disable-line\n\n            let contractLogic := sload(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7)\n\n            calldatacopy(0x0, 0x0, calldatasize)\n\n            let success := delegatecall(sub(gas, 10000), contractLogic, 0x0, calldatasize, 0, 0)\n\n            let retSz := returndatasize\n\n            returndatacopy(0, 0, retSz)\n\n            switch success\n\n            case 0 {\n\n                revert(0, retSz)\n\n            }\n\n            default {\n\n                return(0, retSz)\n\n            }\n\n        }\n",
                    "message": "Proxy.fallback uses assembly (Proxy.sol#16-31)\n\t- Proxy.sol#17-30\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.1;\n",
                    "message": "Detected issues with version pragma in Proxy.sol:\n\t- pragma solidity^0.5.1 (Proxy.sol#3): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": 14,
                    "vulnerability_code": "    constructor(bytes memory constructData, address contractLogic) public {\n\n        // save the code address\n\n        assembly { // solium-disable-line\n\n            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, contractLogic)\n\n        }\n\n        (bool success, /* bytes memory _*/ ) = contractLogic.delegatecall(constructData); // solium-disable-line\n\n        require(success, \"Construction failed\");\n",
                    "message": "Low level call in Proxy.constructor (Proxy.sol#7-14):\n\t-(success) = contractLogic.delegatecall(constructData) Proxy.sol#12\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Proxy {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, /* bytes memory _*/ ) = contractLogic.delegatecall(constructData); // solium-disable-line\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { // solium-disable-line\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { // solium-disable-line\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/contracts/RTokenStructs.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in RTokenStructs.sol:\n\t- pragma solidity^0.5.8 (RTokenStructs.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/contracts/Proxiable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes32(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ) ==\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                Proxiable(newAddress).proxiableUUID(),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            'Not compatible'\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": 23,
                    "vulnerability_code": "    function updateCodeAddress(address newAddress) internal {\n\n        require(\n\n            bytes32(\n\n                    0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\n\n                ) ==\n\n                Proxiable(newAddress).proxiableUUID(),\n\n            'Not compatible'\n\n        );\n\n        assembly {\n\n            // solium-disable-line\n\n            sstore(\n\n                0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7,\n\n                newAddress\n\n            )\n\n        }\n",
                    "message": "Proxiable.updateCodeAddress uses assembly (Proxiable.sol#8-23)\n\t- Proxiable.sol#16-22\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 27,
                    "vulnerability_code": "    function proxiableUUID() public pure returns (bytes32) {\n\n        return\n\n            0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\n",
                    "message": "Proxiable.proxiableUUID (Proxiable.sol#24-27) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.1;\n",
                    "message": "Detected issues with version pragma in Proxiable.sol:\n\t- pragma solidity^0.5.1 (Proxiable.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/contracts/test/ComptrollerMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokens > 0, \"redeemTokens == 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemAmount > 0, \"redeemAmount == 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokens > 0, \"redeemTokens == 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(borrowAmount > 0, \"borrowAmount == 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(borrowAmount > 0, \"borrowAmount == 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(repayAmount > 0, \"repayAmount == 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(repayAmount > 0, \"repayAmount == 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(repayAmount > 0, \"repayAmount == 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(repayAmount > 0, \"repayAmount == 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(repayAmount > 0, \"repayAmount == 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ComptrollerMock.sol:\n\t- pragma solidity^0.5.8 (ComptrollerMock.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerMock.sol#86): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint /* borrowerIndex */) external {\n",
                    "message": "Parameter '' of ComptrollerMock.repayBorrowVerify (ComptrollerMock.sol#163) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint /* seizeTokens */) external {\n",
                    "message": "Parameter '' of ComptrollerMock.liquidateBorrowVerify (ComptrollerMock.sol#189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint /* seizeTokens */) external returns (uint){\n",
                    "message": "Parameter '' of ComptrollerMock.seizeAllowed (ComptrollerMock.sol#202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint /* seizeTokens */) external {\n",
                    "message": "Parameter '' of ComptrollerMock.seizeVerify (ComptrollerMock.sol#214) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exitMarket(address cToken) external returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint amountSeizeError, uint seizeTokens) {\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/contracts/test/InterestRateModelMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in InterestRateModelMock.sol:\n\t- pragma solidity^0.5.8 (InterestRateModelMock.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (InterestRateModelMock.sol#35): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            external view returns (uint success, uint rate) {\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/contracts/test/RinkebyDaiFaucet.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allocateTo(address,uint256) public payable;\n",
                    "message": "RinkebyTestDAI.allocateTo (RinkebyDaiFaucet.sol#6) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in RinkebyDaiFaucet.sol:\n\t- pragma solidity^0.5.8 (RinkebyDaiFaucet.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allocateTo(address,uint256) public payable;\n",
                    "message": "Parameter '' of RinkebyTestDAI.allocateTo (RinkebyDaiFaucet.sol#6) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allocateTo(address,uint256) public payable;\n",
                    "message": "Parameter '_scope_0' of RinkebyTestDAI.allocateTo (RinkebyDaiFaucet.sol#6) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract RinkebyTestDAI {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/EIP20NonStandardInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (EIP20NonStandardInterface.sol#10-71) has incorrect ERC20 function interface(s):\n\t-transfer (EIP20NonStandardInterface.sol#35)\n\t-transferFrom (EIP20NonStandardInterface.sol#49)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in EIP20NonStandardInterface.sol:\n\t- pragma solidity^0.5.8 (EIP20NonStandardInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/ComptrollerInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ComptrollerInterface.sol:\n\t- pragma solidity^0.5.8 (ComptrollerInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256, uint256);\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/ReentrancyGuard.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ReentrancyGuard.sol:\n\t- pragma solidity^0.5.8 (ReentrancyGuard.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/CErc20.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 663,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1007,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1008,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1010,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1011,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1012,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 decimals_\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1014,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1015,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2562,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2563,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 decimals_\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) public CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set underlying\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 677,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1019,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1023,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1031,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1704,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1921,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1019,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1031,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1704,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_46"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (CErc20.sol#10-71) has incorrect ERC20 function interface(s):\n\t-transfer (CErc20.sol#35)\n\t-transferFrom (CErc20.sol#49)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2390,
                    "vulnerability_to_line": 2400,
                    "vulnerability_code": "    function _reduceReserves(uint256 reduceAmount) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (CErc20.sol#2390-2400):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#2391-2392)\n\tState variables written after the call(s):\n\t- totalReserves (CErc20.sol#2397-2400)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2321,
                    "vulnerability_to_line": 2340,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (CErc20.sol#2321-2340):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (CErc20.sol#2329-2331)\n\tState variables written after the call(s):\n\t- comptroller (CErc20.sol#2332-2334)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2460,
                    "vulnerability_to_line": 2471,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (CErc20.sol#2460-2471):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#2461-2462)\n\t- _setInterestRateModelFresh(newInterestRateModel) (CErc20.sol#2467-2470)\n\tState variables written after the call(s):\n\t- interestRateModel (CErc20.sol#2467-2470)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2476,
                    "vulnerability_to_line": 2506,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (CErc20.sol#2476-2506):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (CErc20.sol#2495-2497)\n\tState variables written after the call(s):\n\t- interestRateModel (CErc20.sol#2498-2500)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2345,
                    "vulnerability_to_line": 2355,
                    "vulnerability_code": "    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (CErc20.sol#2345-2355):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#2346-2347)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (CErc20.sol#2352-2353)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1415,
                    "vulnerability_to_line": 1526,
                    "vulnerability_code": "    function accrueInterest() public returns (uint256) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\n\n            getCashPrior(),\n\n            totalBorrows,\n\n            totalReserves\n\n        );\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return\n\n                failOpaque(\n\n                    Error.INTEREST_RATE_MODEL_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n\n                    vars.opaqueErr\n\n                );\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\n\n            Exp({mantissa: vars.borrowRateMantissa}),\n\n            vars.blockDelta\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\n\n            Exp({mantissa: reserveFactorMantissa}),\n\n            vars.interestAccumulated,\n\n            totalReserves\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\n\n            vars.simpleInterestFactor,\n\n            borrowIndex,\n\n            borrowIndex\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CErc20.sol#1415-1526):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CErc20.sol#1419-1424)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1517-1518)\n\t- totalReserves (CErc20.sol#1518-1520)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1832,
                    "vulnerability_to_line": 1842,
                    "vulnerability_code": "    function borrowInternal(uint256 borrowAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (CErc20.sol#1832-1842):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#1833-1834)\n\t- borrowFresh(msg.sender,borrowAmount) (CErc20.sol#1839-1840)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1839-1840)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2087,
                    "vulnerability_to_line": 2108,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint256 repayAmount, CToken cTokenCollateral)\n\n        internal\n\n        nonReentrant\n\n        returns (uint256)\n\n    {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (CErc20.sol#2087-2108):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#2092-2093)\n\t- error = cTokenCollateral.accrueInterest() (CErc20.sol#2098-2099)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (CErc20.sol#2105-2106)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#2105-2106)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": 1827,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n\n        internal\n\n        returns (uint256)\n\n    {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n\n                Exp({mantissa: vars.exchangeRateMantissa}),\n\n                redeemTokensIn\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n\n                redeemAmountIn,\n\n                Exp({mantissa: vars.exchangeRateMantissa})\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CErc20.sol#1700-1827):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CErc20.sol#1759-1760)\n\tState variables written after the call(s):\n\t- totalSupply (CErc20.sol#1814-1815)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1958,
                    "vulnerability_to_line": 1968,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint256 repayAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (CErc20.sol#1958-1968):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#1959-1960)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (CErc20.sol#1965-1966)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1965-1966)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1942,
                    "vulnerability_to_line": 1952,
                    "vulnerability_code": "    function repayBorrowInternal(uint256 repayAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (CErc20.sol#1942-1952):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#1943-1944)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (CErc20.sol#1949-1950)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1949-1950)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1997,
                    "vulnerability_to_line": 1999,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (CErc20.sol#1997-1999) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1416,
                    "vulnerability_to_line": 1418,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (CErc20.sol#1416-1418) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1872,
                    "vulnerability_to_line": 1874,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (CErc20.sol#1872-1874) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1706,
                    "vulnerability_to_line": 1708,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (CErc20.sol#1706-1708) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1570,
                    "vulnerability_to_line": 1572,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (CErc20.sol#1570-1572) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2562,
                    "vulnerability_to_line": 2576,
                    "vulnerability_code": "    constructor(\n\n        address underlying_,\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) public CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n\n        // Set underlying\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply(); // Sanity check the underlying\n\n    }\n\n\n",
                    "message": "CErc20.constructor (CErc20.sol#2562-2576) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (CErc20.sol#2573)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1415,
                    "vulnerability_to_line": 1526,
                    "vulnerability_code": "    function accrueInterest() public returns (uint256) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\n\n            getCashPrior(),\n\n            totalBorrows,\n\n            totalReserves\n\n        );\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return\n\n                failOpaque(\n\n                    Error.INTEREST_RATE_MODEL_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n\n                    vars.opaqueErr\n\n                );\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\n\n            Exp({mantissa: vars.borrowRateMantissa}),\n\n            vars.blockDelta\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\n\n            Exp({mantissa: reserveFactorMantissa}),\n\n            vars.interestAccumulated,\n\n            totalReserves\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\n\n            vars.simpleInterestFactor,\n\n            borrowIndex,\n\n            borrowIndex\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CErc20.sol#1415-1526):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CErc20.sol#1419-1424)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CErc20.sol#1515-1516)\n\t- borrowIndex (CErc20.sol#1516-1517)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1855,
                    "vulnerability_to_line": 1937,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint256 borrowAmount) internal returns (uint256) {\n\n        /* Fail if borrow not allowed */\n\n        uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (CErc20.sol#1855-1937):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (CErc20.sol#1857-1858)\n\tState variables written after the call(s):\n\t- accountBorrows (CErc20.sol#1924-1925)\n\t- accountBorrows (CErc20.sol#1925-1926)\n\t- totalBorrows (CErc20.sol#1926-1928)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": 1037,
                    "vulnerability_code": "    constructor(\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint256 err = _setComptroller(comptroller_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CErc20.sol#1006-1037):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CErc20.sol#1022)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CErc20.sol#1026)\n\t- borrowIndex (CErc20.sol#1027)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1006,
                    "vulnerability_to_line": 1037,
                    "vulnerability_code": "    constructor(\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint256 err = _setComptroller(comptroller_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CErc20.sol#1006-1037):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CErc20.sol#1022)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (CErc20.sol#1030)\n\tState variables written after the call(s):\n\t- decimals (CErc20.sol#1035)\n\t- name (CErc20.sol#1033)\n\t- symbol (CErc20.sol#1034)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1558,
                    "vulnerability_to_line": 1650,
                    "vulnerability_code": "    function mintFresh(address minter, uint256 mintAmount) internal returns (uint256) {\n\n        /* Fail if mint not allowed */\n\n        uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n\n            mintAmount,\n\n            Exp({mantissa: vars.exchangeRateMantissa})\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (CErc20.sol#1558-1650):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CErc20.sol#1560-1561)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20.sol#1638-1640)\n\t- totalSupply (CErc20.sol#1637-1638)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": 1827,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n\n        internal\n\n        returns (uint256)\n\n    {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n\n                Exp({mantissa: vars.exchangeRateMantissa}),\n\n                redeemTokensIn\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n\n                redeemAmountIn,\n\n                Exp({mantissa: vars.exchangeRateMantissa})\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CErc20.sol#1700-1827):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CErc20.sol#1759-1760)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20.sol#1815-1817)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1985,
                    "vulnerability_to_line": 2079,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint256 repayAmount) internal returns (uint256) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint256(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (CErc20.sol#1985-2079):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (CErc20.sol#1987-1988)\n\tState variables written after the call(s):\n\t- accountBorrows (CErc20.sol#2066-2067)\n\t- accountBorrows (CErc20.sol#2067-2068)\n\t- totalBorrows (CErc20.sol#2068-2070)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2213,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint256 seizeTokens) external nonReentrant returns (uint256) {\n\n        /* Fail if seize not allowed */\n\n        uint256 allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint256 borrowerTokensNew;\n\n        uint256 liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint256(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint256(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.seize (CErc20.sol#2213-2261):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (CErc20.sol#2215-2216)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20.sol#2249-2250)\n\t- accountTokens (CErc20.sol#2250-2252)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1047,
                    "vulnerability_to_line": 1108,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint256 tokens) internal returns (uint256) {\n\n        /* Fail if transfer not allowed */\n\n        uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint256 startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint256(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint256 allowanceNew;\n\n        uint256 srcTokensNew;\n\n        uint256 dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint256(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (CErc20.sol#1047-1108):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (CErc20.sol#1049)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20.sol#1092)\n\t- accountTokens (CErc20.sol#1093)\n\t- transferAllowances (CErc20.sol#1097)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2690,
                    "vulnerability_to_line": 2722,
                    "vulnerability_code": "    function doTransferIn(address from, uint256 amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize\n\n                case 0 {\n\n                    // This is a non-standard ERC-20\n\n                    result := not(0) // set result to true\n\n                }\n\n                case 32 {\n\n                    // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0) // Set `result = returndata` of external call\n\n                }\n\n                default {\n\n                    // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_IN_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n\n\n    /**\n",
                    "message": "CErc20.doTransferIn uses assembly (CErc20.sol#2690-2722)\n\t- CErc20.sol#2698-2714\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2730,
                    "vulnerability_to_line": 2760,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint256 amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transfer(to, amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize\n\n                case 0 {\n\n                    // This is a non-standard ERC-20\n\n                    result := not(0) // set result to true\n\n                }\n\n                case 32 {\n\n                    // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0) // Set `result = returndata` of external call\n\n                }\n\n                default {\n\n                    // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n",
                    "message": "CErc20.doTransferOut uses assembly (CErc20.sol#2730-2760)\n\t- CErc20.sol#2738-2754\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2460,
                    "vulnerability_to_line": 2471,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (CErc20.sol#2460-2471) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in CErc20.sol:\n\t- pragma solidity^0.5.8 (CErc20.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#75): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#136): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#218): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#441): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#648): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#683-684): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#766-767): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#798-799): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#2538-2542): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (CErc20.sol#228) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (CErc20.sol#229) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (CErc20.sol#230) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2271,
                    "vulnerability_to_line": 2289,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint256) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (CErc20.sol#2271-2289) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2294,
                    "vulnerability_to_line": 2316,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint256) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (CErc20.sol#2294-2316) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2321,
                    "vulnerability_to_line": 2340,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (CErc20.sol#2321-2340) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2345,
                    "vulnerability_to_line": 2355,
                    "vulnerability_code": "    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (CErc20.sol#2345-2355) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2360,
                    "vulnerability_to_line": 2385,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (CErc20.sol#2360-2385) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2390,
                    "vulnerability_to_line": 2400,
                    "vulnerability_code": "    function _reduceReserves(uint256 reduceAmount) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (CErc20.sol#2390-2400) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2406,
                    "vulnerability_to_line": 2455,
                    "vulnerability_code": "    function _reduceReservesFresh(uint256 reduceAmount) internal returns (uint256) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint256 totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (CErc20.sol#2406-2455) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2460,
                    "vulnerability_to_line": 2471,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (CErc20.sol#2460-2471) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2476,
                    "vulnerability_to_line": 2506,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (CErc20.sol#2476-2506) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (CErc20.sol#814) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 834,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (CErc20.sol#834) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 839,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (CErc20.sol#839) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 683,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint256 a, uint256 b, uint256 c) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (MathError, uint256)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint256, uint256, uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2697,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint256 amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 834,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 839,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 899,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 904,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => mapping(address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 919,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1702,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1704,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1706,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1709,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1709,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1709,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1709,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint256 amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint256 amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint256 amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2732,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool result;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2734,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2734,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2738,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2741,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0) // set result to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2741,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0) // set result to true\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/Exponential.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in Exponential.sol:\n\t- pragma solidity^0.5.8 (Exponential.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (Exponential.sol#85): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (Exponential.sol#95) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (Exponential.sol#96) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (Exponential.sol#97) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": "Exponential.mantissaOne (Exponential.sol#97) is never used in Exponential\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint256 a, uint256 b, uint256 c) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (MathError, uint256)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/PriceOracle.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 937,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 938,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 939,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 940,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 decimals_\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 947,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 951,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1991,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 947,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_42"
            ],
            "vulnerability_findings": [
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2318,
                    "vulnerability_to_line": 2328,
                    "vulnerability_code": "    function _reduceReserves(uint256 reduceAmount) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (PriceOracle.sol#2318-2328):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#2319-2320)\n\tState variables written after the call(s):\n\t- totalReserves (PriceOracle.sol#2325-2328)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2249,
                    "vulnerability_to_line": 2268,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (PriceOracle.sol#2249-2268):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (PriceOracle.sol#2257-2259)\n\tState variables written after the call(s):\n\t- comptroller (PriceOracle.sol#2260-2262)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2399,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (PriceOracle.sol#2388-2399):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#2389-2390)\n\t- _setInterestRateModelFresh(newInterestRateModel) (PriceOracle.sol#2395-2398)\n\tState variables written after the call(s):\n\t- interestRateModel (PriceOracle.sol#2395-2398)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2404,
                    "vulnerability_to_line": 2434,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (PriceOracle.sol#2404-2434):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (PriceOracle.sol#2423-2425)\n\tState variables written after the call(s):\n\t- interestRateModel (PriceOracle.sol#2426-2428)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2273,
                    "vulnerability_to_line": 2283,
                    "vulnerability_code": "    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (PriceOracle.sol#2273-2283):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#2274-2275)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (PriceOracle.sol#2280-2281)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1343,
                    "vulnerability_to_line": 1454,
                    "vulnerability_code": "    function accrueInterest() public returns (uint256) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\n\n            getCashPrior(),\n\n            totalBorrows,\n\n            totalReserves\n\n        );\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return\n\n                failOpaque(\n\n                    Error.INTEREST_RATE_MODEL_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n\n                    vars.opaqueErr\n\n                );\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\n\n            Exp({mantissa: vars.borrowRateMantissa}),\n\n            vars.blockDelta\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\n\n            Exp({mantissa: reserveFactorMantissa}),\n\n            vars.interestAccumulated,\n\n            totalReserves\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\n\n            vars.simpleInterestFactor,\n\n            borrowIndex,\n\n            borrowIndex\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (PriceOracle.sol#1343-1454):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (PriceOracle.sol#1347-1352)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1445-1446)\n\t- totalReserves (PriceOracle.sol#1446-1448)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1760,
                    "vulnerability_to_line": 1770,
                    "vulnerability_code": "    function borrowInternal(uint256 borrowAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (PriceOracle.sol#1760-1770):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#1761-1762)\n\t- borrowFresh(msg.sender,borrowAmount) (PriceOracle.sol#1767-1768)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1767-1768)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2015,
                    "vulnerability_to_line": 2036,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint256 repayAmount, CToken cTokenCollateral)\n\n        internal\n\n        nonReentrant\n\n        returns (uint256)\n\n    {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (PriceOracle.sol#2015-2036):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#2020-2021)\n\t- error = cTokenCollateral.accrueInterest() (PriceOracle.sol#2026-2027)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (PriceOracle.sol#2033-2034)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#2033-2034)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": 1755,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n\n        internal\n\n        returns (uint256)\n\n    {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n\n                Exp({mantissa: vars.exchangeRateMantissa}),\n\n                redeemTokensIn\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n\n                redeemAmountIn,\n\n                Exp({mantissa: vars.exchangeRateMantissa})\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (PriceOracle.sol#1628-1755):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (PriceOracle.sol#1687-1688)\n\tState variables written after the call(s):\n\t- totalSupply (PriceOracle.sol#1742-1743)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1886,
                    "vulnerability_to_line": 1896,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint256 repayAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (PriceOracle.sol#1886-1896):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#1887-1888)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (PriceOracle.sol#1893-1894)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1893-1894)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1870,
                    "vulnerability_to_line": 1880,
                    "vulnerability_code": "    function repayBorrowInternal(uint256 repayAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (PriceOracle.sol#1870-1880):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#1871-1872)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (PriceOracle.sol#1877-1878)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1877-1878)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1634,
                    "vulnerability_to_line": 1636,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (PriceOracle.sol#1634-1636) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1925,
                    "vulnerability_to_line": 1927,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (PriceOracle.sol#1925-1927) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1344,
                    "vulnerability_to_line": 1346,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (PriceOracle.sol#1344-1346) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1498,
                    "vulnerability_to_line": 1500,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (PriceOracle.sol#1498-1500) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1800,
                    "vulnerability_to_line": 1802,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (PriceOracle.sol#1800-1802) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1343,
                    "vulnerability_to_line": 1454,
                    "vulnerability_code": "    function accrueInterest() public returns (uint256) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\n\n            getCashPrior(),\n\n            totalBorrows,\n\n            totalReserves\n\n        );\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return\n\n                failOpaque(\n\n                    Error.INTEREST_RATE_MODEL_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n\n                    vars.opaqueErr\n\n                );\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\n\n            Exp({mantissa: vars.borrowRateMantissa}),\n\n            vars.blockDelta\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\n\n            Exp({mantissa: reserveFactorMantissa}),\n\n            vars.interestAccumulated,\n\n            totalReserves\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\n\n            vars.simpleInterestFactor,\n\n            borrowIndex,\n\n            borrowIndex\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (PriceOracle.sol#1343-1454):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (PriceOracle.sol#1347-1352)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (PriceOracle.sol#1443-1444)\n\t- borrowIndex (PriceOracle.sol#1444-1445)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1783,
                    "vulnerability_to_line": 1865,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint256 borrowAmount) internal returns (uint256) {\n\n        /* Fail if borrow not allowed */\n\n        uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (PriceOracle.sol#1783-1865):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (PriceOracle.sol#1785-1786)\n\tState variables written after the call(s):\n\t- accountBorrows (PriceOracle.sol#1852-1853)\n\t- accountBorrows (PriceOracle.sol#1853-1854)\n\t- totalBorrows (PriceOracle.sol#1854-1856)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": 965,
                    "vulnerability_code": "    constructor(\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint256 err = _setComptroller(comptroller_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (PriceOracle.sol#934-965):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (PriceOracle.sol#950)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (PriceOracle.sol#954)\n\t- borrowIndex (PriceOracle.sol#955)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": 965,
                    "vulnerability_code": "    constructor(\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint256 err = _setComptroller(comptroller_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (PriceOracle.sol#934-965):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (PriceOracle.sol#950)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (PriceOracle.sol#958)\n\tState variables written after the call(s):\n\t- decimals (PriceOracle.sol#963)\n\t- name (PriceOracle.sol#961)\n\t- symbol (PriceOracle.sol#962)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1486,
                    "vulnerability_to_line": 1578,
                    "vulnerability_code": "    function mintFresh(address minter, uint256 mintAmount) internal returns (uint256) {\n\n        /* Fail if mint not allowed */\n\n        uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n\n            mintAmount,\n\n            Exp({mantissa: vars.exchangeRateMantissa})\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (PriceOracle.sol#1486-1578):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (PriceOracle.sol#1488-1489)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracle.sol#1566-1568)\n\t- totalSupply (PriceOracle.sol#1565-1566)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": 1755,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n\n        internal\n\n        returns (uint256)\n\n    {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n\n                Exp({mantissa: vars.exchangeRateMantissa}),\n\n                redeemTokensIn\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n\n                redeemAmountIn,\n\n                Exp({mantissa: vars.exchangeRateMantissa})\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (PriceOracle.sol#1628-1755):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (PriceOracle.sol#1687-1688)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracle.sol#1743-1745)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1913,
                    "vulnerability_to_line": 2007,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint256 repayAmount) internal returns (uint256) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint256(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (PriceOracle.sol#1913-2007):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (PriceOracle.sol#1915-1916)\n\tState variables written after the call(s):\n\t- accountBorrows (PriceOracle.sol#1994-1995)\n\t- accountBorrows (PriceOracle.sol#1995-1996)\n\t- totalBorrows (PriceOracle.sol#1996-1998)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2141,
                    "vulnerability_to_line": 2189,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint256 seizeTokens) external nonReentrant returns (uint256) {\n\n        /* Fail if seize not allowed */\n\n        uint256 allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint256 borrowerTokensNew;\n\n        uint256 liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint256(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint256(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.seize (PriceOracle.sol#2141-2189):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (PriceOracle.sol#2143-2144)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracle.sol#2177-2178)\n\t- accountTokens (PriceOracle.sol#2178-2180)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 975,
                    "vulnerability_to_line": 1036,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint256 tokens) internal returns (uint256) {\n\n        /* Fail if transfer not allowed */\n\n        uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint256 startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint256(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint256 allowanceNew;\n\n        uint256 srcTokensNew;\n\n        uint256 dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint256(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (PriceOracle.sol#975-1036):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (PriceOracle.sol#977)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracle.sol#1020)\n\t- accountTokens (PriceOracle.sol#1021)\n\t- transferAllowances (PriceOracle.sol#1025)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2399,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (PriceOracle.sol#2388-2399) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in PriceOracle.sol:\n\t- pragma solidity^0.5.8 (PriceOracle.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#64): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#146): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#369): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#576): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#611-612): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#726-727): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#2466-2468): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (PriceOracle.sol#156) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (PriceOracle.sol#157) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (PriceOracle.sol#158) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2199,
                    "vulnerability_to_line": 2217,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint256) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (PriceOracle.sol#2199-2217) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2222,
                    "vulnerability_to_line": 2244,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint256) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (PriceOracle.sol#2222-2244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2249,
                    "vulnerability_to_line": 2268,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (PriceOracle.sol#2249-2268) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2273,
                    "vulnerability_to_line": 2283,
                    "vulnerability_code": "    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (PriceOracle.sol#2273-2283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2288,
                    "vulnerability_to_line": 2313,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (PriceOracle.sol#2288-2313) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2318,
                    "vulnerability_to_line": 2328,
                    "vulnerability_code": "    function _reduceReserves(uint256 reduceAmount) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (PriceOracle.sol#2318-2328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2334,
                    "vulnerability_to_line": 2383,
                    "vulnerability_code": "    function _reduceReservesFresh(uint256 reduceAmount) internal returns (uint256) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint256 totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (PriceOracle.sol#2334-2383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2399,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (PriceOracle.sol#2388-2399) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2404,
                    "vulnerability_to_line": 2434,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (PriceOracle.sol#2404-2434) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (PriceOracle.sol#742) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (PriceOracle.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (PriceOracle.sol#767) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint256 a, uint256 b, uint256 c) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (MathError, uint256)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint256, uint256, uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => mapping(address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1630,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/CToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 937,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 938,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 939,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 940,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 decimals_\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 947,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 951,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1991,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 947,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_42"
            ],
            "vulnerability_findings": [
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2318,
                    "vulnerability_to_line": 2328,
                    "vulnerability_code": "    function _reduceReserves(uint256 reduceAmount) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (CToken.sol#2318-2328):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#2319-2320)\n\tState variables written after the call(s):\n\t- totalReserves (CToken.sol#2325-2328)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2249,
                    "vulnerability_to_line": 2268,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (CToken.sol#2249-2268):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (CToken.sol#2257-2259)\n\tState variables written after the call(s):\n\t- comptroller (CToken.sol#2260-2262)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2399,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (CToken.sol#2388-2399):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#2389-2390)\n\t- _setInterestRateModelFresh(newInterestRateModel) (CToken.sol#2395-2398)\n\tState variables written after the call(s):\n\t- interestRateModel (CToken.sol#2395-2398)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2404,
                    "vulnerability_to_line": 2434,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (CToken.sol#2404-2434):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (CToken.sol#2423-2425)\n\tState variables written after the call(s):\n\t- interestRateModel (CToken.sol#2426-2428)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2273,
                    "vulnerability_to_line": 2283,
                    "vulnerability_code": "    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (CToken.sol#2273-2283):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#2274-2275)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (CToken.sol#2280-2281)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1343,
                    "vulnerability_to_line": 1454,
                    "vulnerability_code": "    function accrueInterest() public returns (uint256) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\n\n            getCashPrior(),\n\n            totalBorrows,\n\n            totalReserves\n\n        );\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return\n\n                failOpaque(\n\n                    Error.INTEREST_RATE_MODEL_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n\n                    vars.opaqueErr\n\n                );\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\n\n            Exp({mantissa: vars.borrowRateMantissa}),\n\n            vars.blockDelta\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\n\n            Exp({mantissa: reserveFactorMantissa}),\n\n            vars.interestAccumulated,\n\n            totalReserves\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\n\n            vars.simpleInterestFactor,\n\n            borrowIndex,\n\n            borrowIndex\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CToken.sol#1343-1454):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CToken.sol#1347-1352)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1445-1446)\n\t- totalReserves (CToken.sol#1446-1448)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1760,
                    "vulnerability_to_line": 1770,
                    "vulnerability_code": "    function borrowInternal(uint256 borrowAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (CToken.sol#1760-1770):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#1761-1762)\n\t- borrowFresh(msg.sender,borrowAmount) (CToken.sol#1767-1768)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1767-1768)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2015,
                    "vulnerability_to_line": 2036,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint256 repayAmount, CToken cTokenCollateral)\n\n        internal\n\n        nonReentrant\n\n        returns (uint256)\n\n    {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (CToken.sol#2015-2036):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#2020-2021)\n\t- error = cTokenCollateral.accrueInterest() (CToken.sol#2026-2027)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (CToken.sol#2033-2034)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#2033-2034)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": 1755,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n\n        internal\n\n        returns (uint256)\n\n    {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n\n                Exp({mantissa: vars.exchangeRateMantissa}),\n\n                redeemTokensIn\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n\n                redeemAmountIn,\n\n                Exp({mantissa: vars.exchangeRateMantissa})\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CToken.sol#1628-1755):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CToken.sol#1687-1688)\n\tState variables written after the call(s):\n\t- totalSupply (CToken.sol#1742-1743)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1886,
                    "vulnerability_to_line": 1896,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint256 repayAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (CToken.sol#1886-1896):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#1887-1888)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (CToken.sol#1893-1894)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1893-1894)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1870,
                    "vulnerability_to_line": 1880,
                    "vulnerability_code": "    function repayBorrowInternal(uint256 repayAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (CToken.sol#1870-1880):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#1871-1872)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (CToken.sol#1877-1878)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1877-1878)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1344,
                    "vulnerability_to_line": 1346,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (CToken.sol#1344-1346) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1925,
                    "vulnerability_to_line": 1927,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (CToken.sol#1925-1927) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1800,
                    "vulnerability_to_line": 1802,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (CToken.sol#1800-1802) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1634,
                    "vulnerability_to_line": 1636,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (CToken.sol#1634-1636) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1498,
                    "vulnerability_to_line": 1500,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (CToken.sol#1498-1500) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1343,
                    "vulnerability_to_line": 1454,
                    "vulnerability_code": "    function accrueInterest() public returns (uint256) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\n\n            getCashPrior(),\n\n            totalBorrows,\n\n            totalReserves\n\n        );\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return\n\n                failOpaque(\n\n                    Error.INTEREST_RATE_MODEL_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n\n                    vars.opaqueErr\n\n                );\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\n\n            Exp({mantissa: vars.borrowRateMantissa}),\n\n            vars.blockDelta\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\n\n            Exp({mantissa: reserveFactorMantissa}),\n\n            vars.interestAccumulated,\n\n            totalReserves\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\n\n            vars.simpleInterestFactor,\n\n            borrowIndex,\n\n            borrowIndex\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CToken.sol#1343-1454):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CToken.sol#1347-1352)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CToken.sol#1443-1444)\n\t- borrowIndex (CToken.sol#1444-1445)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1783,
                    "vulnerability_to_line": 1865,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint256 borrowAmount) internal returns (uint256) {\n\n        /* Fail if borrow not allowed */\n\n        uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (CToken.sol#1783-1865):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (CToken.sol#1785-1786)\n\tState variables written after the call(s):\n\t- accountBorrows (CToken.sol#1852-1853)\n\t- accountBorrows (CToken.sol#1853-1854)\n\t- totalBorrows (CToken.sol#1854-1856)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": 965,
                    "vulnerability_code": "    constructor(\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint256 err = _setComptroller(comptroller_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CToken.sol#934-965):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CToken.sol#950)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CToken.sol#954)\n\t- borrowIndex (CToken.sol#955)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": 965,
                    "vulnerability_code": "    constructor(\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint256 err = _setComptroller(comptroller_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CToken.sol#934-965):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CToken.sol#950)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (CToken.sol#958)\n\tState variables written after the call(s):\n\t- decimals (CToken.sol#963)\n\t- name (CToken.sol#961)\n\t- symbol (CToken.sol#962)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1486,
                    "vulnerability_to_line": 1578,
                    "vulnerability_code": "    function mintFresh(address minter, uint256 mintAmount) internal returns (uint256) {\n\n        /* Fail if mint not allowed */\n\n        uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n\n            mintAmount,\n\n            Exp({mantissa: vars.exchangeRateMantissa})\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (CToken.sol#1486-1578):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CToken.sol#1488-1489)\n\tState variables written after the call(s):\n\t- accountTokens (CToken.sol#1566-1568)\n\t- totalSupply (CToken.sol#1565-1566)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": 1755,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n\n        internal\n\n        returns (uint256)\n\n    {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n\n                Exp({mantissa: vars.exchangeRateMantissa}),\n\n                redeemTokensIn\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n\n                redeemAmountIn,\n\n                Exp({mantissa: vars.exchangeRateMantissa})\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CToken.sol#1628-1755):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CToken.sol#1687-1688)\n\tState variables written after the call(s):\n\t- accountTokens (CToken.sol#1743-1745)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1913,
                    "vulnerability_to_line": 2007,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint256 repayAmount) internal returns (uint256) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint256(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (CToken.sol#1913-2007):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (CToken.sol#1915-1916)\n\tState variables written after the call(s):\n\t- accountBorrows (CToken.sol#1994-1995)\n\t- accountBorrows (CToken.sol#1995-1996)\n\t- totalBorrows (CToken.sol#1996-1998)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2141,
                    "vulnerability_to_line": 2189,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint256 seizeTokens) external nonReentrant returns (uint256) {\n\n        /* Fail if seize not allowed */\n\n        uint256 allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint256 borrowerTokensNew;\n\n        uint256 liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint256(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint256(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.seize (CToken.sol#2141-2189):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (CToken.sol#2143-2144)\n\tState variables written after the call(s):\n\t- accountTokens (CToken.sol#2177-2178)\n\t- accountTokens (CToken.sol#2178-2180)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 975,
                    "vulnerability_to_line": 1036,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint256 tokens) internal returns (uint256) {\n\n        /* Fail if transfer not allowed */\n\n        uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint256 startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint256(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint256 allowanceNew;\n\n        uint256 srcTokensNew;\n\n        uint256 dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint256(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (CToken.sol#975-1036):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (CToken.sol#977)\n\tState variables written after the call(s):\n\t- accountTokens (CToken.sol#1020)\n\t- accountTokens (CToken.sol#1021)\n\t- transferAllowances (CToken.sol#1025)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2399,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (CToken.sol#2388-2399) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in CToken.sol:\n\t- pragma solidity^0.5.8 (CToken.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#64): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#146): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#369): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#576): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#611-612): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#726-727): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (CToken.sol#156) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (CToken.sol#157) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (CToken.sol#158) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2199,
                    "vulnerability_to_line": 2217,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint256) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (CToken.sol#2199-2217) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2222,
                    "vulnerability_to_line": 2244,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint256) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (CToken.sol#2222-2244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2249,
                    "vulnerability_to_line": 2268,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (CToken.sol#2249-2268) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2273,
                    "vulnerability_to_line": 2283,
                    "vulnerability_code": "    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (CToken.sol#2273-2283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2288,
                    "vulnerability_to_line": 2313,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (CToken.sol#2288-2313) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2318,
                    "vulnerability_to_line": 2328,
                    "vulnerability_code": "    function _reduceReserves(uint256 reduceAmount) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (CToken.sol#2318-2328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2334,
                    "vulnerability_to_line": 2383,
                    "vulnerability_code": "    function _reduceReservesFresh(uint256 reduceAmount) internal returns (uint256) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint256 totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (CToken.sol#2334-2383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2399,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (CToken.sol#2388-2399) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2404,
                    "vulnerability_to_line": 2434,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (CToken.sol#2404-2434) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (CToken.sol#742) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (CToken.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (CToken.sol#767) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint256 a, uint256 b, uint256 c) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (MathError, uint256)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint256, uint256, uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => mapping(address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1630,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/CErc20Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.21 <0.6.0;\n",
                    "message": "Detected issues with version pragma in CErc20Interface.sol:\n\t- pragma solidity>=0.4.21<0.6.0 (CErc20Interface.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function _setComptroller(\n\n        address newComptroller\n\n    ) external returns (\n\n        uint256\n",
                    "message": "Function 'CErc20Interface._setComptroller' (CErc20Interface.sol#76-80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function _reduceReserves(\n\n        uint256 reduceAmount\n\n    ) external returns (\n\n        uint256\n",
                    "message": "Function 'CErc20Interface._reduceReserves' (CErc20Interface.sol#90-94) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": 175,
                    "vulnerability_code": "    function _setPendingAdmin(\n\n        address newPendingAdmin\n\n    ) external returns (\n\n        uint256\n",
                    "message": "Function 'CErc20Interface._setPendingAdmin' (CErc20Interface.sol#171-175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": 211,
                    "vulnerability_code": "    function _acceptAdmin() external returns (\n\n        uint256\n",
                    "message": "Function 'CErc20Interface._acceptAdmin' (CErc20Interface.sol#209-211) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 217,
                    "vulnerability_code": "    function _setInterestRateModel(\n\n        address newInterestRateModel\n\n    ) external returns (\n\n        uint256\n",
                    "message": "Function 'CErc20Interface._setInterestRateModel' (CErc20Interface.sol#213-217) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function _setReserveFactor(\n\n        uint256 newReserveFactorMantissa\n\n    ) external returns (\n\n        uint256\n",
                    "message": "Function 'CErc20Interface._setReserveFactor' (CErc20Interface.sol#239-243) is not in mixedCase\n"
                },
                {
                    "name": "erc20-indexed",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": 351,
                    "vulnerability_code": "interface CErc20Interface {\n\n\n\n    function name() external view returns (\n\n        string memory\n\n    );\n\n\n\n    function approve(\n\n        address spender,\n\n        uint256 amount\n\n    ) external returns (\n\n        bool\n\n    );\n\n\n\n    function repayBorrow(\n\n        uint256 repayAmount\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function reserveFactorMantissa() external view returns (\n\n        uint256\n\n    );\n\n\n\n    function borrowBalanceCurrent(\n\n        address account\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function totalSupply() external view returns (\n\n        uint256\n\n    );\n\n\n\n    function exchangeRateStored() external view returns (\n\n        uint256\n\n    );\n\n\n\n    function transferFrom(\n\n        address src,\n\n        address dst,\n\n        uint256 amount\n\n    ) external returns (\n\n        bool\n\n    );\n\n\n\n    function repayBorrowBehalf(\n\n        address borrower,\n\n        uint256 repayAmount\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function pendingAdmin() external view returns (\n\n        address\n\n    );\n\n\n\n    function decimals() external view returns (\n\n        uint256\n\n    );\n\n\n\n    function balanceOfUnderlying(\n\n        address owner\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function getCash() external view returns (\n\n        uint256\n\n    );\n\n\n\n    function _setComptroller(\n\n        address newComptroller\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function totalBorrows() external view returns (\n\n        uint256\n\n    );\n\n\n\n    function comptroller() external view returns (\n\n        address\n\n    );\n\n\n\n    function _reduceReserves(\n\n        uint256 reduceAmount\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function initialExchangeRateMantissa() external view returns (\n\n        uint256\n\n    );\n\n\n\n    function accrualBlockNumber() external view returns (\n\n        uint256\n\n    );\n\n\n\n    function underlying() external view returns (\n\n        address\n\n    );\n\n\n\n    function balanceOf(\n\n        address owner\n\n    ) external view returns (\n\n        uint256\n\n    );\n\n\n\n    function totalBorrowsCurrent() external returns (\n\n        uint256\n\n    );\n\n\n\n    function redeemUnderlying(\n\n        uint256 redeemAmount\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function totalReserves() external view returns (\n\n        uint256\n\n    );\n\n\n\n    function symbol() external view returns (\n\n        string memory\n\n    );\n\n\n\n    function borrowBalanceStored(\n\n        address account\n\n    ) external view returns (\n\n        uint256\n\n    );\n\n\n\n    function mint(\n\n        uint256 mintAmount\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function accrueInterest() external returns (\n\n        uint256\n\n    );\n\n\n\n    function transfer(\n\n        address dst,\n\n        uint256 amount\n\n    ) external returns (\n\n        bool\n\n    );\n\n\n\n    function borrowIndex() external view returns (\n\n        uint256\n\n    );\n\n\n\n    function supplyRatePerBlock() external view returns (\n\n        uint256\n\n    );\n\n\n\n    function seize(\n\n        address liquidator,\n\n        address borrower,\n\n        uint256 seizeTokens\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function _setPendingAdmin(\n\n        address newPendingAdmin\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function exchangeRateCurrent() external returns (\n\n        uint256\n\n    );\n\n\n\n    function getAccountSnapshot(\n\n        address account\n\n    ) external view returns (\n\n        uint256,\n\n        uint256,\n\n        uint256,\n\n        uint256\n\n    );\n\n\n\n    function borrow(\n\n        uint256 borrowAmount\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function redeem(\n\n        uint256 redeemTokens\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function allowance(\n\n        address owner,\n\n        address spender\n\n    ) external view returns (\n\n        uint256\n\n    );\n\n\n\n    function _acceptAdmin() external returns (\n\n        uint256\n\n    );\n\n\n\n    function _setInterestRateModel(\n\n        address newInterestRateModel\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function interestRateModel() external view returns (\n\n        address\n\n    );\n\n\n\n    function liquidateBorrow(\n\n        address borrower,\n\n        uint256 repayAmount,\n\n        address cTokenCollateral\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function admin() external view returns (\n\n        address\n\n    );\n\n\n\n    function borrowRatePerBlock() external view returns (\n\n        uint256\n\n    );\n\n\n\n    function _setReserveFactor(\n\n        uint256 newReserveFactorMantissa\n\n    ) external returns (\n\n        uint256\n\n    );\n\n\n\n    function isCToken() external view returns (\n\n        bool\n\n    );\n\n\n\n    /*\n\n    constructor(\n\n        address underlying_,\n\n        address comptroller_,\n\n        address interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string  calldata name_,\n\n        string  calldata symbol_,\n\n        uint256 decimals_\n\n    );\n\n    */\n\n\n\n    event AccrueInterest(\n\n        uint256 interestAccumulated,\n\n        uint256 borrowIndex,\n\n        uint256 totalBorrows\n\n    );\n\n\n\n    event Mint(\n\n        address minter,\n\n        uint256 mintAmount,\n\n        uint256 mintTokens\n\n    );\n\n\n\n    event Redeem(\n\n        address redeemer,\n\n        uint256 redeemAmount,\n\n        uint256 redeemTokens\n\n    );\n\n\n\n    event Borrow(\n\n        address borrower,\n\n        uint256 borrowAmount,\n\n        uint256 accountBorrows,\n\n        uint256 totalBorrows\n\n    );\n\n\n\n    event RepayBorrow(\n\n        address payer,\n\n        address borrower,\n\n        uint256 repayAmount,\n\n        uint256 accountBorrows,\n\n        uint256 totalBorrows\n\n    );\n\n\n\n    event LiquidateBorrow(\n\n        address liquidator,\n\n        address borrower,\n\n        uint256 repayAmount,\n\n        address cTokenCollateral,\n\n        uint256 seizeTokens\n\n    );\n\n\n\n    event NewPendingAdmin(\n\n        address oldPendingAdmin,\n\n        address newPendingAdmin\n\n    );\n\n\n\n    event NewAdmin(\n\n        address oldAdmin,\n\n        address newAdmin\n\n    );\n\n\n\n    event NewComptroller(\n\n        address oldComptroller,\n\n        address newComptroller\n\n    );\n\n\n\n    event NewMarketInterestRateModel(\n\n        address oldInterestRateModel,\n\n        address newInterestRateModel\n\n    );\n\n\n\n    event NewReserveFactor(\n\n        uint256 oldReserveFactorMantissa,\n\n        uint256 newReserveFactorMantissa\n\n    );\n\n\n\n    event ReservesReduced(\n\n        address admin,\n\n        uint256 reduceAmount,\n\n        uint256 newTotalReserves\n\n    );\n\n\n\n    event Failure(\n\n        uint256 error,\n\n        uint256 info,\n\n        uint256 detail\n\n    );\n\n\n\n    event Transfer(\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    );\n\n\n\n    event Approval(\n\n        address owner,\n\n        address spender,\n\n        uint256 amount\n\n    );\n\n\n",
                    "message": "CErc20Interface (CErc20Interface.sol#6-351) does not mark important ERC20 parameters as 'indexed':\n\t-Transfer (CErc20Interface.sol#339-343) does not index parameter 'from'\n\t-Transfer (CErc20Interface.sol#339-343) does not index parameter 'to'\n\t-Approval (CErc20Interface.sol#345-349) does not index parameter 'owner'\n\t-Approval (CErc20Interface.sol#345-349) does not index parameter 'spender'\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.21 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.21 <0.6.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) external view returns (\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/ErrorReporter.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ErrorReporter.sol:\n\t- pragma solidity^0.5.8 (ErrorReporter.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/Unitroller.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 937,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 938,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 939,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 940,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 decimals_\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to caller\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 947,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 951,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1991,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 947,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_54"
            ],
            "vulnerability_findings": [
                {
                    "name": "controlled-delegatecall",
                    "vulnerability_from_line": 2672,
                    "vulnerability_to_line": 2690,
                    "vulnerability_code": "    function() external payable {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n                case 0 {\n\n                    revert(free_mem_ptr, returndatasize)\n\n                }\n\n                default {\n\n                    return(free_mem_ptr, returndatasize)\n\n                }\n\n        }\n\n    }\n",
                    "message": "Unitroller.fallback (Unitroller.sol#2672-2690) uses delegatecall to a input-controlled function id\n\t(success) = comptrollerImplementation.delegatecall(msg.data) (Unitroller.sol#2674-2676)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2318,
                    "vulnerability_to_line": 2328,
                    "vulnerability_code": "    function _reduceReserves(uint256 reduceAmount) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (Unitroller.sol#2318-2328):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#2319-2320)\n\tState variables written after the call(s):\n\t- totalReserves (Unitroller.sol#2325-2328)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2249,
                    "vulnerability_to_line": 2268,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (Unitroller.sol#2249-2268):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (Unitroller.sol#2257-2259)\n\tState variables written after the call(s):\n\t- comptroller (Unitroller.sol#2260-2262)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2399,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (Unitroller.sol#2388-2399):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#2389-2390)\n\t- _setInterestRateModelFresh(newInterestRateModel) (Unitroller.sol#2395-2398)\n\tState variables written after the call(s):\n\t- interestRateModel (Unitroller.sol#2395-2398)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2404,
                    "vulnerability_to_line": 2434,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (Unitroller.sol#2404-2434):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (Unitroller.sol#2423-2425)\n\tState variables written after the call(s):\n\t- interestRateModel (Unitroller.sol#2426-2428)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2273,
                    "vulnerability_to_line": 2283,
                    "vulnerability_code": "    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (Unitroller.sol#2273-2283):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#2274-2275)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (Unitroller.sol#2280-2281)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1343,
                    "vulnerability_to_line": 1454,
                    "vulnerability_code": "    function accrueInterest() public returns (uint256) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\n\n            getCashPrior(),\n\n            totalBorrows,\n\n            totalReserves\n\n        );\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return\n\n                failOpaque(\n\n                    Error.INTEREST_RATE_MODEL_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n\n                    vars.opaqueErr\n\n                );\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\n\n            Exp({mantissa: vars.borrowRateMantissa}),\n\n            vars.blockDelta\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\n\n            Exp({mantissa: reserveFactorMantissa}),\n\n            vars.interestAccumulated,\n\n            totalReserves\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\n\n            vars.simpleInterestFactor,\n\n            borrowIndex,\n\n            borrowIndex\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (Unitroller.sol#1343-1454):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Unitroller.sol#1347-1352)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1445-1446)\n\t- totalReserves (Unitroller.sol#1446-1448)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1760,
                    "vulnerability_to_line": 1770,
                    "vulnerability_code": "    function borrowInternal(uint256 borrowAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (Unitroller.sol#1760-1770):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#1761-1762)\n\t- borrowFresh(msg.sender,borrowAmount) (Unitroller.sol#1767-1768)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1767-1768)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2015,
                    "vulnerability_to_line": 2036,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint256 repayAmount, CToken cTokenCollateral)\n\n        internal\n\n        nonReentrant\n\n        returns (uint256)\n\n    {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (Unitroller.sol#2015-2036):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#2020-2021)\n\t- error = cTokenCollateral.accrueInterest() (Unitroller.sol#2026-2027)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (Unitroller.sol#2033-2034)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#2033-2034)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": 1755,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n\n        internal\n\n        returns (uint256)\n\n    {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n\n                Exp({mantissa: vars.exchangeRateMantissa}),\n\n                redeemTokensIn\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n\n                redeemAmountIn,\n\n                Exp({mantissa: vars.exchangeRateMantissa})\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (Unitroller.sol#1628-1755):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Unitroller.sol#1687-1688)\n\tState variables written after the call(s):\n\t- totalSupply (Unitroller.sol#1742-1743)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1886,
                    "vulnerability_to_line": 1896,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint256 repayAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (Unitroller.sol#1886-1896):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#1887-1888)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (Unitroller.sol#1893-1894)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1893-1894)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1870,
                    "vulnerability_to_line": 1880,
                    "vulnerability_code": "    function repayBorrowInternal(uint256 repayAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (Unitroller.sol#1870-1880):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#1871-1872)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (Unitroller.sol#1877-1878)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1877-1878)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1498,
                    "vulnerability_to_line": 1500,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (Unitroller.sol#1498-1500) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1634,
                    "vulnerability_to_line": 1636,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (Unitroller.sol#1634-1636) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1344,
                    "vulnerability_to_line": 1346,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (Unitroller.sol#1344-1346) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1925,
                    "vulnerability_to_line": 1927,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (Unitroller.sol#1925-1927) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1800,
                    "vulnerability_to_line": 1802,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (Unitroller.sol#1800-1802) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1343,
                    "vulnerability_to_line": 1454,
                    "vulnerability_code": "    function accrueInterest() public returns (uint256) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\n\n            getCashPrior(),\n\n            totalBorrows,\n\n            totalReserves\n\n        );\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return\n\n                failOpaque(\n\n                    Error.INTEREST_RATE_MODEL_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n\n                    vars.opaqueErr\n\n                );\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\n\n            Exp({mantissa: vars.borrowRateMantissa}),\n\n            vars.blockDelta\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\n\n            Exp({mantissa: reserveFactorMantissa}),\n\n            vars.interestAccumulated,\n\n            totalReserves\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\n\n            vars.simpleInterestFactor,\n\n            borrowIndex,\n\n            borrowIndex\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (Unitroller.sol#1343-1454):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Unitroller.sol#1347-1352)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Unitroller.sol#1443-1444)\n\t- borrowIndex (Unitroller.sol#1444-1445)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1783,
                    "vulnerability_to_line": 1865,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint256 borrowAmount) internal returns (uint256) {\n\n        /* Fail if borrow not allowed */\n\n        uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (Unitroller.sol#1783-1865):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (Unitroller.sol#1785-1786)\n\tState variables written after the call(s):\n\t- accountBorrows (Unitroller.sol#1852-1853)\n\t- accountBorrows (Unitroller.sol#1853-1854)\n\t- totalBorrows (Unitroller.sol#1854-1856)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": 965,
                    "vulnerability_code": "    constructor(\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint256 err = _setComptroller(comptroller_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (Unitroller.sol#934-965):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Unitroller.sol#950)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Unitroller.sol#954)\n\t- borrowIndex (Unitroller.sol#955)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": 965,
                    "vulnerability_code": "    constructor(\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint256 err = _setComptroller(comptroller_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (Unitroller.sol#934-965):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Unitroller.sol#950)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (Unitroller.sol#958)\n\tState variables written after the call(s):\n\t- decimals (Unitroller.sol#963)\n\t- name (Unitroller.sol#961)\n\t- symbol (Unitroller.sol#962)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1486,
                    "vulnerability_to_line": 1578,
                    "vulnerability_code": "    function mintFresh(address minter, uint256 mintAmount) internal returns (uint256) {\n\n        /* Fail if mint not allowed */\n\n        uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n\n            mintAmount,\n\n            Exp({mantissa: vars.exchangeRateMantissa})\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (Unitroller.sol#1486-1578):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (Unitroller.sol#1488-1489)\n\tState variables written after the call(s):\n\t- accountTokens (Unitroller.sol#1566-1568)\n\t- totalSupply (Unitroller.sol#1565-1566)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": 1755,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n\n        internal\n\n        returns (uint256)\n\n    {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n\n                Exp({mantissa: vars.exchangeRateMantissa}),\n\n                redeemTokensIn\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n\n                redeemAmountIn,\n\n                Exp({mantissa: vars.exchangeRateMantissa})\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (Unitroller.sol#1628-1755):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Unitroller.sol#1687-1688)\n\tState variables written after the call(s):\n\t- accountTokens (Unitroller.sol#1743-1745)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1913,
                    "vulnerability_to_line": 2007,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint256 repayAmount) internal returns (uint256) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint256(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (Unitroller.sol#1913-2007):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (Unitroller.sol#1915-1916)\n\tState variables written after the call(s):\n\t- accountBorrows (Unitroller.sol#1994-1995)\n\t- accountBorrows (Unitroller.sol#1995-1996)\n\t- totalBorrows (Unitroller.sol#1996-1998)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2141,
                    "vulnerability_to_line": 2189,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint256 seizeTokens) external nonReentrant returns (uint256) {\n\n        /* Fail if seize not allowed */\n\n        uint256 allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint256 borrowerTokensNew;\n\n        uint256 liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint256(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint256(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.seize (Unitroller.sol#2141-2189):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (Unitroller.sol#2143-2144)\n\tState variables written after the call(s):\n\t- accountTokens (Unitroller.sol#2177-2178)\n\t- accountTokens (Unitroller.sol#2178-2180)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 975,
                    "vulnerability_to_line": 1036,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint256 tokens) internal returns (uint256) {\n\n        /* Fail if transfer not allowed */\n\n        uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint256 startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint256(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint256 allowanceNew;\n\n        uint256 srcTokensNew;\n\n        uint256 dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint256(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (Unitroller.sol#975-1036):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (Unitroller.sol#977)\n\tState variables written after the call(s):\n\t- accountTokens (Unitroller.sol#1020)\n\t- accountTokens (Unitroller.sol#1021)\n\t- transferAllowances (Unitroller.sol#1025)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2672,
                    "vulnerability_to_line": 2690,
                    "vulnerability_code": "    function() external payable {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n                case 0 {\n\n                    revert(free_mem_ptr, returndatasize)\n\n                }\n\n                default {\n\n                    return(free_mem_ptr, returndatasize)\n\n                }\n\n        }\n\n    }\n",
                    "message": "Unitroller.fallback uses assembly (Unitroller.sol#2672-2690)\n\t- Unitroller.sol#2678-2690\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 2518,
                    "vulnerability_to_line": 2521,
                    "vulnerability_code": "    uint256 public closeFactorMantissa;\n\n\n\n    /**\n",
                    "message": "ComptrollerV1Storage.closeFactorMantissa should be constant (Unitroller.sol#2518-2521)\nComptrollerV1Storage.liquidationIncentiveMantissa should be constant (Unitroller.sol#2523-2526)\nComptrollerV1Storage.maxAssets should be constant (Unitroller.sol#2528-2531)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2399,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (Unitroller.sol#2388-2399) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2575,
                    "vulnerability_to_line": 2590,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint256) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingImplementation (Unitroller.sol#2575-2590) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2594,
                    "vulnerability_to_line": 2615,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint256) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptImplementation (Unitroller.sol#2594-2615) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2622,
                    "vulnerability_to_line": 2641,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint256) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingAdmin (Unitroller.sol#2622-2641) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2645,
                    "vulnerability_to_line": 2668,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint256) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptAdmin (Unitroller.sol#2645-2668) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in Unitroller.sol:\n\t- pragma solidity^0.5.8 (Unitroller.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#64): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#146): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#369): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#576): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#611-612): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#726-727): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#2466-2468): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#2485-2487): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#2539-2543): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 2672,
                    "vulnerability_to_line": 2690,
                    "vulnerability_code": "    function() external payable {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            let free_mem_ptr := mload(0x40)\n\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n            switch success\n\n                case 0 {\n\n                    revert(free_mem_ptr, returndatasize)\n\n                }\n\n                default {\n\n                    return(free_mem_ptr, returndatasize)\n\n                }\n\n        }\n\n    }\n",
                    "message": "Low level call in Unitroller.fallback (Unitroller.sol#2672-2690):\n\t-(success) = comptrollerImplementation.delegatecall(msg.data) Unitroller.sol#2674-2676\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (Unitroller.sol#156) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (Unitroller.sol#157) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (Unitroller.sol#158) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2199,
                    "vulnerability_to_line": 2217,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint256) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (Unitroller.sol#2199-2217) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2222,
                    "vulnerability_to_line": 2244,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint256) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (Unitroller.sol#2222-2244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2249,
                    "vulnerability_to_line": 2268,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (Unitroller.sol#2249-2268) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2273,
                    "vulnerability_to_line": 2283,
                    "vulnerability_code": "    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (Unitroller.sol#2273-2283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2288,
                    "vulnerability_to_line": 2313,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (Unitroller.sol#2288-2313) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2318,
                    "vulnerability_to_line": 2328,
                    "vulnerability_code": "    function _reduceReserves(uint256 reduceAmount) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (Unitroller.sol#2318-2328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2334,
                    "vulnerability_to_line": 2383,
                    "vulnerability_code": "    function _reduceReservesFresh(uint256 reduceAmount) internal returns (uint256) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint256 totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (Unitroller.sol#2334-2383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2399,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (Unitroller.sol#2388-2399) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2404,
                    "vulnerability_to_line": 2434,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (Unitroller.sol#2404-2434) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (Unitroller.sol#742) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (Unitroller.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (Unitroller.sol#767) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2575,
                    "vulnerability_to_line": 2590,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint256) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingImplementation' (Unitroller.sol#2575-2590) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2594,
                    "vulnerability_to_line": 2615,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint256) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptImplementation' (Unitroller.sol#2594-2615) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2622,
                    "vulnerability_to_line": 2641,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint256) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingAdmin' (Unitroller.sol#2622-2641) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2645,
                    "vulnerability_to_line": 2668,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint256) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptAdmin' (Unitroller.sol#2645-2668) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingComptrollerImplementation = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingAdmin = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2485,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint256 a, uint256 b, uint256 c) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (MathError, uint256)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint256, uint256, uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 2674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2677,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => mapping(address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1630,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/CarefulMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in CarefulMath.sol:\n\t- pragma solidity^0.5.8 (CarefulMath.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint256 a, uint256 b, uint256 c) internal pure returns (MathError, uint256) {\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/EIP20Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in EIP20Interface.sol:\n\t- pragma solidity^0.5.8 (EIP20Interface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/InterestRateModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in InterestRateModel.sol:\n\t- pragma solidity^0.5.8 (InterestRateModel.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256, uint256);\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/ComptrollerStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 592,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 937,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 938,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 939,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 940,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 decimals_\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 947,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 951,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1991,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 947,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_43"
            ],
            "vulnerability_findings": [
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2318,
                    "vulnerability_to_line": 2328,
                    "vulnerability_code": "    function _reduceReserves(uint256 reduceAmount) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (ComptrollerStorage.sol#2318-2328):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2319-2320)\n\tState variables written after the call(s):\n\t- totalReserves (ComptrollerStorage.sol#2325-2328)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2249,
                    "vulnerability_to_line": 2268,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (ComptrollerStorage.sol#2249-2268):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (ComptrollerStorage.sol#2257-2259)\n\tState variables written after the call(s):\n\t- comptroller (ComptrollerStorage.sol#2260-2262)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2399,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (ComptrollerStorage.sol#2388-2399):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2389-2390)\n\t- _setInterestRateModelFresh(newInterestRateModel) (ComptrollerStorage.sol#2395-2398)\n\tState variables written after the call(s):\n\t- interestRateModel (ComptrollerStorage.sol#2395-2398)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2404,
                    "vulnerability_to_line": 2434,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (ComptrollerStorage.sol#2404-2434):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (ComptrollerStorage.sol#2423-2425)\n\tState variables written after the call(s):\n\t- interestRateModel (ComptrollerStorage.sol#2426-2428)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2273,
                    "vulnerability_to_line": 2283,
                    "vulnerability_code": "    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (ComptrollerStorage.sol#2273-2283):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2274-2275)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (ComptrollerStorage.sol#2280-2281)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1343,
                    "vulnerability_to_line": 1454,
                    "vulnerability_code": "    function accrueInterest() public returns (uint256) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\n\n            getCashPrior(),\n\n            totalBorrows,\n\n            totalReserves\n\n        );\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return\n\n                failOpaque(\n\n                    Error.INTEREST_RATE_MODEL_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n\n                    vars.opaqueErr\n\n                );\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\n\n            Exp({mantissa: vars.borrowRateMantissa}),\n\n            vars.blockDelta\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\n\n            Exp({mantissa: reserveFactorMantissa}),\n\n            vars.interestAccumulated,\n\n            totalReserves\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\n\n            vars.simpleInterestFactor,\n\n            borrowIndex,\n\n            borrowIndex\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (ComptrollerStorage.sol#1343-1454):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (ComptrollerStorage.sol#1347-1352)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1445-1446)\n\t- totalReserves (ComptrollerStorage.sol#1446-1448)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1760,
                    "vulnerability_to_line": 1770,
                    "vulnerability_code": "    function borrowInternal(uint256 borrowAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (ComptrollerStorage.sol#1760-1770):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1761-1762)\n\t- borrowFresh(msg.sender,borrowAmount) (ComptrollerStorage.sol#1767-1768)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1767-1768)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2015,
                    "vulnerability_to_line": 2036,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint256 repayAmount, CToken cTokenCollateral)\n\n        internal\n\n        nonReentrant\n\n        returns (uint256)\n\n    {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (ComptrollerStorage.sol#2015-2036):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2020-2021)\n\t- error = cTokenCollateral.accrueInterest() (ComptrollerStorage.sol#2026-2027)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (ComptrollerStorage.sol#2033-2034)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#2033-2034)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": 1755,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n\n        internal\n\n        returns (uint256)\n\n    {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n\n                Exp({mantissa: vars.exchangeRateMantissa}),\n\n                redeemTokensIn\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n\n                redeemAmountIn,\n\n                Exp({mantissa: vars.exchangeRateMantissa})\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (ComptrollerStorage.sol#1628-1755):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ComptrollerStorage.sol#1687-1688)\n\tState variables written after the call(s):\n\t- totalSupply (ComptrollerStorage.sol#1742-1743)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1886,
                    "vulnerability_to_line": 1896,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint256 repayAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (ComptrollerStorage.sol#1886-1896):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1887-1888)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (ComptrollerStorage.sol#1893-1894)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1893-1894)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1870,
                    "vulnerability_to_line": 1880,
                    "vulnerability_code": "    function repayBorrowInternal(uint256 repayAmount) internal nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (ComptrollerStorage.sol#1870-1880):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1871-1872)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (ComptrollerStorage.sol#1877-1878)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1877-1878)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1800,
                    "vulnerability_to_line": 1802,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (ComptrollerStorage.sol#1800-1802) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1925,
                    "vulnerability_to_line": 1927,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (ComptrollerStorage.sol#1925-1927) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1344,
                    "vulnerability_to_line": 1346,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (ComptrollerStorage.sol#1344-1346) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1498,
                    "vulnerability_to_line": 1500,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (ComptrollerStorage.sol#1498-1500) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1634,
                    "vulnerability_to_line": 1636,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (ComptrollerStorage.sol#1634-1636) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1343,
                    "vulnerability_to_line": 1454,
                    "vulnerability_code": "    function accrueInterest() public returns (uint256) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\n\n            getCashPrior(),\n\n            totalBorrows,\n\n            totalReserves\n\n        );\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return\n\n                failOpaque(\n\n                    Error.INTEREST_RATE_MODEL_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n\n                    vars.opaqueErr\n\n                );\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\n\n            Exp({mantissa: vars.borrowRateMantissa}),\n\n            vars.blockDelta\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\n\n            Exp({mantissa: reserveFactorMantissa}),\n\n            vars.interestAccumulated,\n\n            totalReserves\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\n\n            vars.simpleInterestFactor,\n\n            borrowIndex,\n\n            borrowIndex\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (ComptrollerStorage.sol#1343-1454):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (ComptrollerStorage.sol#1347-1352)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ComptrollerStorage.sol#1443-1444)\n\t- borrowIndex (ComptrollerStorage.sol#1444-1445)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1783,
                    "vulnerability_to_line": 1865,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint256 borrowAmount) internal returns (uint256) {\n\n        /* Fail if borrow not allowed */\n\n        uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (ComptrollerStorage.sol#1783-1865):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (ComptrollerStorage.sol#1785-1786)\n\tState variables written after the call(s):\n\t- accountBorrows (ComptrollerStorage.sol#1852-1853)\n\t- accountBorrows (ComptrollerStorage.sol#1853-1854)\n\t- totalBorrows (ComptrollerStorage.sol#1854-1856)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": 965,
                    "vulnerability_code": "    constructor(\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint256 err = _setComptroller(comptroller_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (ComptrollerStorage.sol#934-965):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ComptrollerStorage.sol#950)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ComptrollerStorage.sol#954)\n\t- borrowIndex (ComptrollerStorage.sol#955)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": 965,
                    "vulnerability_code": "    constructor(\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint256 initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 decimals_\n\n    ) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint256 err = _setComptroller(comptroller_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint256(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (ComptrollerStorage.sol#934-965):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ComptrollerStorage.sol#950)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (ComptrollerStorage.sol#958)\n\tState variables written after the call(s):\n\t- decimals (ComptrollerStorage.sol#963)\n\t- name (ComptrollerStorage.sol#961)\n\t- symbol (ComptrollerStorage.sol#962)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1486,
                    "vulnerability_to_line": 1578,
                    "vulnerability_code": "    function mintFresh(address minter, uint256 mintAmount) internal returns (uint256) {\n\n        /* Fail if mint not allowed */\n\n        uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n\n            mintAmount,\n\n            Exp({mantissa: vars.exchangeRateMantissa})\n\n        );\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (ComptrollerStorage.sol#1486-1578):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (ComptrollerStorage.sol#1488-1489)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#1566-1568)\n\t- totalSupply (ComptrollerStorage.sol#1565-1566)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": 1755,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n\n        internal\n\n        returns (uint256)\n\n    {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n\n                Exp({mantissa: vars.exchangeRateMantissa}),\n\n                redeemTokensIn\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n\n                redeemAmountIn,\n\n                Exp({mantissa: vars.exchangeRateMantissa})\n\n            );\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return\n\n                    failOpaque(\n\n                        Error.MATH_ERROR,\n\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n\n                        uint256(vars.mathErr)\n\n                    );\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (ComptrollerStorage.sol#1628-1755):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ComptrollerStorage.sol#1687-1688)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#1743-1745)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1913,
                    "vulnerability_to_line": 2007,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint256 repayAmount) internal returns (uint256) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint256(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return\n\n                failOpaque(\n\n                    Error.MATH_ERROR,\n\n                    FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n                    uint256(vars.mathErr)\n\n                );\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (ComptrollerStorage.sol#1913-2007):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (ComptrollerStorage.sol#1915-1916)\n\tState variables written after the call(s):\n\t- accountBorrows (ComptrollerStorage.sol#1994-1995)\n\t- accountBorrows (ComptrollerStorage.sol#1995-1996)\n\t- totalBorrows (ComptrollerStorage.sol#1996-1998)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2141,
                    "vulnerability_to_line": 2189,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint256 seizeTokens) external nonReentrant returns (uint256) {\n\n        /* Fail if seize not allowed */\n\n        uint256 allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint256 borrowerTokensNew;\n\n        uint256 liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint256(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint256(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.seize (ComptrollerStorage.sol#2141-2189):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (ComptrollerStorage.sol#2143-2144)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#2177-2178)\n\t- accountTokens (ComptrollerStorage.sol#2178-2180)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 975,
                    "vulnerability_to_line": 1036,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint256 tokens) internal returns (uint256) {\n\n        /* Fail if transfer not allowed */\n\n        uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint256 startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint256(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint256 allowanceNew;\n\n        uint256 srcTokensNew;\n\n        uint256 dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint256(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (ComptrollerStorage.sol#975-1036):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (ComptrollerStorage.sol#977)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#1020)\n\t- accountTokens (ComptrollerStorage.sol#1021)\n\t- transferAllowances (ComptrollerStorage.sol#1025)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 2518,
                    "vulnerability_to_line": 2521,
                    "vulnerability_code": "    uint256 public closeFactorMantissa;\n\n\n\n    /**\n",
                    "message": "ComptrollerV1Storage.closeFactorMantissa should be constant (ComptrollerStorage.sol#2518-2521)\nComptrollerV1Storage.liquidationIncentiveMantissa should be constant (ComptrollerStorage.sol#2523-2526)\nComptrollerV1Storage.maxAssets should be constant (ComptrollerStorage.sol#2528-2531)\nUnitrollerAdminStorage.admin should be constant (ComptrollerStorage.sol#2491-2494)\nUnitrollerAdminStorage.comptrollerImplementation should be constant (ComptrollerStorage.sol#2501-2504)\nUnitrollerAdminStorage.pendingAdmin should be constant (ComptrollerStorage.sol#2496-2499)\nUnitrollerAdminStorage.pendingComptrollerImplementation should be constant (ComptrollerStorage.sol#2506-2509)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2399,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (ComptrollerStorage.sol#2388-2399) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ComptrollerStorage.sol:\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#64): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#146): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#369): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#576): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#611-612): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#726-727): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#2466-2468): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#2485-2487): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (ComptrollerStorage.sol#156) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (ComptrollerStorage.sol#157) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (ComptrollerStorage.sol#158) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2199,
                    "vulnerability_to_line": 2217,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint256) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (ComptrollerStorage.sol#2199-2217) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2222,
                    "vulnerability_to_line": 2244,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint256) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (ComptrollerStorage.sol#2222-2244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2249,
                    "vulnerability_to_line": 2268,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (ComptrollerStorage.sol#2249-2268) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2273,
                    "vulnerability_to_line": 2283,
                    "vulnerability_code": "    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (ComptrollerStorage.sol#2273-2283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2288,
                    "vulnerability_to_line": 2313,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (ComptrollerStorage.sol#2288-2313) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2318,
                    "vulnerability_to_line": 2328,
                    "vulnerability_code": "    function _reduceReserves(uint256 reduceAmount) external nonReentrant returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (ComptrollerStorage.sol#2318-2328) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2334,
                    "vulnerability_to_line": 2383,
                    "vulnerability_code": "    function _reduceReservesFresh(uint256 reduceAmount) internal returns (uint256) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint256 totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (ComptrollerStorage.sol#2334-2383) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": 2399,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n\n        uint256 error = accrueInterest();\n\n        if (error != uint256(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (ComptrollerStorage.sol#2388-2399) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2404,
                    "vulnerability_to_line": 2434,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint256(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (ComptrollerStorage.sol#2404-2434) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (ComptrollerStorage.sol#742) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (ComptrollerStorage.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (ComptrollerStorage.sol#767) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2485,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint256 a, uint256 b, uint256 c) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (MathError, uint256)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint256, uint256, uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => mapping(address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1630,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "rtoken-monorepo-1d3c5df6cf87b3bbf5ac7bc74753a157ac2c49db/compound/contracts/WhitePaperInterestRateModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 baseRate_, uint256 multiplier_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        baseRate = baseRate_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        multiplier = multiplier_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": 476,
                    "vulnerability_code": "    function getBorrowRate(uint256 cash, uint256 borrows, uint256 _reserves) public view returns (uint256, uint256) {\n\n        _reserves; // pragma ignore unused argument\n\n\n\n        (IRError err0, Exp memory _utilizationRate, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(\n\n            cash,\n\n            borrows\n\n        );\n\n        if (err0 != IRError.NO_ERROR) {\n\n            return (uint256(err0), 0);\n\n        }\n\n\n\n        // And then divide down by blocks per year.\n\n        (MathError err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\n\n        // divScalar only fails when divisor is zero. This is clearly not the case.\n\n        assert(err1 == MathError.NO_ERROR);\n\n\n\n        _utilizationRate; // pragma ignore unused variable\n\n\n\n        // Note: mantissa is the rate scaled 1e18, which matches the expected result\n\n        return (uint256(IRError.NO_ERROR), borrowRate.mantissa);\n",
                    "message": "WhitePaperInterestRateModel.getBorrowRate (WhitePaperInterestRateModel.sol#456-476) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256, uint256);\n",
                    "message": "InterestRateModel.getBorrowRate (WhitePaperInterestRateModel.sol#23) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in WhitePaperInterestRateModel.sol:\n\t- pragma solidity^0.5.8 (WhitePaperInterestRateModel.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (WhitePaperInterestRateModel.sol#35): it allows old versions\n\t- pragma solidity^0.5.8 (WhitePaperInterestRateModel.sol#117): it allows old versions\n\t- pragma solidity^0.5.8 (WhitePaperInterestRateModel.sol#340): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (WhitePaperInterestRateModel.sol#127) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (WhitePaperInterestRateModel.sol#128) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (WhitePaperInterestRateModel.sol#129) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'WhitePaperInterestRateModel.isInterestRateModel' (WhitePaperInterestRateModel.sol#352) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public constant blocksPerYear = 2102400;\n",
                    "message": "Constant 'WhitePaperInterestRateModel.blocksPerYear' (WhitePaperInterestRateModel.sol#367) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) external view returns (uint256, uint256);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint256 a, uint256 b, uint256 c) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (MathError, uint256)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationRate(uint256 cash, uint256 borrows) internal pure returns (IRError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (IRError, Exp memory, Exp memory)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint256 cash, uint256 borrows, uint256 _reserves) public view returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant halfExpScale = expScale / 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant mantissaOne = expScale;\n",
                    "message": null
                }
            ]
        }
    }
}